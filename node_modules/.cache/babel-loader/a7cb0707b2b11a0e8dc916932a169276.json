{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _keys from \"lodash/keys\";\nimport { Ref } from '@fluentui/react-component-ref';\nimport { callable } from '@fluentui/styles';\nimport * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport getElementType from '../utils/getElementType';\nimport getUnhandledProps from '../utils/getUnhandledProps';\nimport { getNextElement, focusAsync } from './focusUtilities';\n/** AutoFocusZone is used to focus inner element on mount. */\n\nvar AutoFocusZone = /*#__PURE__*/function (_React$Component) {\n  _inherits(AutoFocusZone, _React$Component);\n\n  function AutoFocusZone() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, AutoFocusZone);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AutoFocusZone)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_this), \"root\", React.createRef());\n\n    _defineProperty(_assertThisInitialized(_this), \"findElementAndFocusAsync\", function () {\n      if (!_this.root.current) return;\n      var firstFocusableSelector = _this.props.firstFocusableSelector;\n      var focusSelector = callable(firstFocusableSelector)();\n      var firstFocusableChild = focusSelector ? _this.root.current.querySelector(focusSelector) : getNextElement(_this.root.current, _this.root.current.firstChild, true, false, false, true);\n      firstFocusableChild && focusAsync(firstFocusableChild);\n    });\n\n    return _this;\n  }\n\n  _createClass(AutoFocusZone, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.findElementAndFocusAsync();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var unhandledProps = getUnhandledProps(AutoFocusZone.handledProps, this.props);\n      var ElementType = getElementType(this.props);\n      return React.createElement(Ref, {\n        innerRef: this.root\n      }, React.createElement(ElementType, unhandledProps, this.props.children));\n    }\n  }]);\n\n  return AutoFocusZone;\n}(React.Component);\n\n_defineProperty(AutoFocusZone, \"propTypes\", {\n  as: PropTypes.elementType,\n  firstFocusableSelector: PropTypes.oneOfType([PropTypes.func, PropTypes.string])\n});\n\n_defineProperty(AutoFocusZone, \"handledProps\", _keys(AutoFocusZone.propTypes));\n\nexport { AutoFocusZone as default };","map":{"version":3,"sources":["FocusZone/AutoFocusZone.tsx"],"names":["AutoFocusZone","React","Component","as","PropTypes","firstFocusableSelector","unhandledProps","getUnhandledProps","ElementType","getElementType","root","focusSelector","callable","firstFocusableChild","getNextElement","focusAsync"],"mappings":";;;;;;;;AAAA,SAAA,GAAA,QAAA,+BAAA;AACA,SAAA,QAAA,QAAA,kBAAA;AACA,OAAO,KAAP,KAAA,MAAA,OAAA;AACA,OAAO,KAAP,SAAA,MAAA,YAAA;AAGA,OAAA,cAAA,MAAA,yBAAA;AACA,OAAA,iBAAA,MAAA,4BAAA;AAEA,SAAA,cAAA,EAAA,UAAA,QAAA,kBAAA;AAEA;;IACqBA,a;;;;;;;;;;;;;;;;2DACZC,KAAK,CAALA,SAAAA,E;;+EAwBoB,YAAM;AAC/B,UAAI,CAAC,KAAA,CAAA,IAAA,CAAL,OAAA,EAAwB;AADO,UAEvBI,sBAFuB,GAEI,KAAA,CAFJ,KAEI,CAFJ,sBAAA;AAI/B,UAAMM,aAAa,GAAGC,QAAQ,CAA9B,sBAA8B,CAARA,EAAtB;AAEA,UAAMC,mBAAmB,GAAGF,aAAa,GACpC,KAAA,CAAA,IAAA,CAAA,OAAA,CAAA,aAAA,CADoC,aACpC,CADoC,GAErCG,cAAc,CAAC,KAAA,CAAA,IAAA,CAAD,OAAA,EAAoB,KAAA,CAAA,IAAA,CAAA,OAAA,CAApB,UAAA,EAAA,IAAA,EAAA,KAAA,EAAA,KAAA,EAFlB,IAEkB,CAFlB;AAIAD,MAAAA,mBAAmB,IAAIE,UAAU,CAAjCF,mBAAiC,CAAjCA;;;;;;;;wCAzBwB;AACxB,WAAA,wBAAA;AACD;;;6BAEqB;AACpB,UAAMP,cAAc,GAAGC,iBAAiB,CAACP,aAAa,CAAd,YAAA,EAA6B,KAArE,KAAwC,CAAxC;AACA,UAAMQ,WAAW,GAAGC,cAAc,CAAC,KAAnC,KAAkC,CAAlC;AAEA,aACE,KAAA,CAAA,aAAA,CAAA,GAAA,EAAA;AAAK,QAAA,QAAQ,EAAE,KAAKC;AAApB,OAAA,EACE,KAAA,CAAA,aAAA,CAAA,WAAA,EAAA,cAAA,EAAkC,KAAA,KAAA,CAFtC,QAEI,CADF,CADF;AAKD;;;;EAvBwCT,KAAK,CAACC,S;;gBAA5BF,a,eAGA;AACjBG,EAAAA,EAAE,EAAEC,SAAS,CADI,WAAA;AAEjBC,EAAAA,sBAAsB,EAAED,SAAS,CAATA,SAAAA,CAAoB,CAACA,SAAS,CAAV,IAAA,EAAiBA,SAAS,CAA9CA,MAAoB,CAApBA;AAFP,C;;gBAHAJ,a,kBAQG,KAAA,CAAOA,aAAa,CAApB,SAAA,C;;SARHA,a","sourcesContent":["import { Ref } from '@fluentui/react-component-ref';\nimport { callable } from '@fluentui/styles';\nimport * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport * as _ from 'lodash';\n\nimport getElementType from '../utils/getElementType';\nimport getUnhandledProps from '../utils/getUnhandledProps';\nimport { AutoFocusZoneProps } from './AutoFocusZone.types';\nimport { getNextElement, focusAsync } from './focusUtilities';\n\n/** AutoFocusZone is used to focus inner element on mount. */\nexport default class AutoFocusZone extends React.Component<AutoFocusZoneProps> {\n  root = React.createRef<HTMLElement>();\n\n  static propTypes = {\n    as: PropTypes.elementType,\n    firstFocusableSelector: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n  };\n\n  static handledProps = _.keys(AutoFocusZone.propTypes) as any;\n\n  componentDidMount(): void {\n    this.findElementAndFocusAsync();\n  }\n\n  render(): JSX.Element {\n    const unhandledProps = getUnhandledProps(AutoFocusZone.handledProps, this.props);\n    const ElementType = getElementType(this.props);\n\n    return (\n      <Ref innerRef={this.root}>\n        <ElementType {...unhandledProps}>{this.props.children}</ElementType>\n      </Ref>\n    );\n  }\n\n  findElementAndFocusAsync = () => {\n    if (!this.root.current) return;\n    const { firstFocusableSelector } = this.props;\n\n    const focusSelector = callable(firstFocusableSelector)();\n\n    const firstFocusableChild = focusSelector\n      ? (this.root.current.querySelector(focusSelector) as HTMLElement)\n      : getNextElement(this.root.current, this.root.current.firstChild as HTMLElement, true, false, false, true);\n\n    firstFocusableChild && focusAsync(firstFocusableChild);\n  };\n}\n"]},"metadata":{},"sourceType":"module"}