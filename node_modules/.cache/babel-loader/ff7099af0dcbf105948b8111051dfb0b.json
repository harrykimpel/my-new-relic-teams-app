{"ast":null,"code":"import { __assign, __spreadArrays } from \"tslib\";\nimport * as ReactIs from 'react-is';\n\nfunction computeDisplayNames(inputOptions, parentOptions) {\n  if (inputOptions.overrideStyles) {\n    return [inputOptions.displayName].filter(Boolean);\n  } // To support styles composition we need to properly pick up display names\n\n\n  return inputOptions.displayName ? parentOptions.displayNames.concat(inputOptions.displayName) : parentOptions.displayNames;\n}\n\nexport var defaultComposeOptions = {\n  className: process.env.NODE_ENV === 'production' ? '' : 'no-classname-ðŸ™‰',\n  displayName: '',\n  displayNames: [],\n  mapPropsToStylesPropsChain: [],\n  render: function render() {\n    return null;\n  },\n  handledProps: [],\n  overrideStyles: false,\n  slots: {},\n  mapPropsToSlotPropsChain: [],\n  resolveSlotProps: function resolveSlotProps() {\n    return {};\n  }\n};\nexport function mergeComposeOptions(input, inputOptions, parentOptions) {\n  if (parentOptions === void 0) {\n    parentOptions = defaultComposeOptions;\n  }\n\n  var mapPropsToSlotPropsChain = inputOptions.mapPropsToSlotProps ? __spreadArrays(parentOptions.mapPropsToSlotPropsChain, [inputOptions.mapPropsToSlotProps]) : parentOptions.mapPropsToSlotPropsChain;\n\n  var resolveSlotProps = function resolveSlotProps(props) {\n    return mapPropsToSlotPropsChain.reduce(function (acc, definition) {\n      var nextProps = __assign({}, definition(props));\n\n      var slots = __spreadArrays(Object.keys(acc), Object.keys(nextProps));\n\n      var mergedSlotProps = {};\n      slots.forEach(function (slot) {\n        if (!mergedSlotProps[slot]) {\n          mergedSlotProps[slot] = __assign(__assign({}, acc[slot]), nextProps[slot]);\n        }\n      });\n      return mergedSlotProps;\n    }, {});\n  };\n\n  return {\n    className: inputOptions.className || parentOptions.className,\n    displayName: inputOptions.displayName || parentOptions.displayName,\n    displayNames: computeDisplayNames(inputOptions, parentOptions),\n    mapPropsToStylesPropsChain: inputOptions.mapPropsToStylesProps ? __spreadArrays(parentOptions.mapPropsToStylesPropsChain, [inputOptions.mapPropsToStylesProps]) : parentOptions.mapPropsToStylesPropsChain,\n    render: typeof input === 'function' ? input : parentOptions.render,\n    handledProps: __spreadArrays(parentOptions.handledProps, inputOptions.handledProps || []),\n    overrideStyles: inputOptions.overrideStyles || false,\n    slots: __assign(__assign({}, parentOptions.slots), inputOptions.slots),\n    mapPropsToSlotPropsChain: mapPropsToSlotPropsChain,\n    resolveSlotProps: resolveSlotProps\n  };\n}\n/**\n * compose() allows you to pass two inputs:\n * - React.forwardRef + static fluentComposeConfig, i.e. previously composed component\n * - a function\n */\n\nexport function wasComposedPreviously(input) {\n  var isForwardRef = input.$$typeof === ReactIs.ForwardRef;\n  return isForwardRef && !!input.fluentComposeConfig;\n}","map":{"version":3,"sources":["utils.ts"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport * as ReactIs from 'react-is';\n\nimport { ComposedComponent, ComposeOptions, ComposePreparedOptions, Input } from './types';\n\nfunction computeDisplayNames(inputOptions: ComposeOptions, parentOptions: ComposePreparedOptions): string[] {\n  if (inputOptions.overrideStyles) {\n    return [inputOptions.displayName].filter(Boolean) as string[];\n  }\n\n  // To support styles composition we need to properly pick up display names\n  return inputOptions.displayName\n    ? parentOptions.displayNames.concat(inputOptions.displayName)\n    : parentOptions.displayNames;\n}\n\nexport const defaultComposeOptions: ComposePreparedOptions = {\n  className: process.env.NODE_ENV === 'production' ? '' : 'no-classname-ðŸ™‰',\n  displayName: '',\n  displayNames: [],\n\n  mapPropsToStylesPropsChain: [],\n  render: () => null,\n\n  handledProps: [] as never[],\n  overrideStyles: false,\n  slots: {},\n  mapPropsToSlotPropsChain: [],\n  resolveSlotProps: () => ({}),\n};\n\nexport function mergeComposeOptions(\n  input: Input,\n  inputOptions: ComposeOptions,\n  parentOptions: ComposePreparedOptions = defaultComposeOptions,\n): ComposePreparedOptions {\n  const mapPropsToSlotPropsChain = inputOptions.mapPropsToSlotProps\n    ? [...parentOptions.mapPropsToSlotPropsChain, inputOptions.mapPropsToSlotProps]\n    : parentOptions.mapPropsToSlotPropsChain;\n\n  const resolveSlotProps = <P = {}>(props: P) =>\n    mapPropsToSlotPropsChain.reduce<Record<string, object>>((acc, definition) => {\n      const nextProps = { ...definition(props) };\n      const slots: string[] = [...Object.keys(acc), ...Object.keys(nextProps)];\n\n      const mergedSlotProps: Record<string, object> = {};\n\n      slots.forEach(slot => {\n        if (!mergedSlotProps[slot]) {\n          mergedSlotProps[slot] = {\n            ...acc[slot],\n            ...nextProps[slot],\n          };\n        }\n      });\n\n      return mergedSlotProps;\n    }, {});\n\n  return {\n    className: inputOptions.className || parentOptions.className,\n    displayName: inputOptions.displayName || parentOptions.displayName,\n    displayNames: computeDisplayNames(inputOptions, parentOptions),\n\n    mapPropsToStylesPropsChain: inputOptions.mapPropsToStylesProps\n      ? [...parentOptions.mapPropsToStylesPropsChain, inputOptions.mapPropsToStylesProps]\n      : parentOptions.mapPropsToStylesPropsChain,\n    render: typeof input === 'function' ? input : parentOptions.render,\n\n    handledProps: [...parentOptions.handledProps, ...((inputOptions.handledProps as never[]) || ([] as never[]))],\n    overrideStyles: inputOptions.overrideStyles || false,\n\n    slots: {\n      ...parentOptions.slots,\n      ...inputOptions.slots,\n    },\n    mapPropsToSlotPropsChain,\n    resolveSlotProps,\n  };\n}\n\n/**\n * compose() allows you to pass two inputs:\n * - React.forwardRef + static fluentComposeConfig, i.e. previously composed component\n * - a function\n */\nexport function wasComposedPreviously<T extends React.ElementType = 'div', P = {}>(\n  input: Input<T, P>,\n): input is ComposedComponent<P> {\n  const isForwardRef: boolean = (input as React.ExoticComponent).$$typeof === ReactIs.ForwardRef;\n\n  return isForwardRef && !!(input as ComposedComponent<P>).fluentComposeConfig;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}