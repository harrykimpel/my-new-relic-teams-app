{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport * as PropTypes from 'prop-types';\nimport * as React from 'react';\nimport handleRef from './handleRef';\nimport { refPropType } from './types';\n\nvar RefForward = /*#__PURE__*/function (_React$Component) {\n  _inherits(RefForward, _React$Component);\n\n  function RefForward() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, RefForward);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RefForward)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_this), \"currentNode\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"handleRefOverride\", function (node) {\n      var _this$props = _this.props,\n          children = _this$props.children,\n          innerRef = _this$props.innerRef;\n      handleRef(children.ref, node);\n      handleRef(innerRef, node);\n      _this.currentNode = node;\n    });\n\n    return _this;\n  }\n\n  _createClass(RefForward, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (prevProps.innerRef !== this.props.innerRef) {\n        handleRef(this.props.innerRef, this.currentNode);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      delete this.currentNode;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var children = this.props.children;\n      return React.cloneElement(children, {\n        ref: this.handleRefOverride\n      });\n    }\n  }]);\n\n  return RefForward;\n}(React.Component);\n\n_defineProperty(RefForward, \"displayName\", 'RefForward');\n\n_defineProperty(RefForward, \"propTypes\", process.env.NODE_ENV !== 'production' ? {\n  children: PropTypes.element.isRequired,\n  innerRef: refPropType.isRequired\n} : {});\n\nexport { RefForward as default };","map":{"version":3,"sources":["RefForward.tsx"],"names":["RefForward","React","Component","children","PropTypes","innerRef","refPropType","isRequired","handleRef","prevProps","ref","handleRefOverride"],"mappings":";;;;;;;AAAA,OAAO,KAAP,SAAA,MAAA,YAAA;AACA,OAAO,KAAP,KAAA,MAAA,OAAA;AAEA,OAAA,SAAA,MAAA,aAAA;AACA,SAAA,WAAA,QAAA,SAAA;;IAEqBA,U;;;;;;;;;;;;;;;;kEAYQ,I;;wEAEP,UAAA,IAAA,EAAuB;AAAA,UAAA,WAAA,GACV,KAAA,CADU,KAAA;AAAA,UACjCG,QADiC,GAAA,WAAA,CAAA,QAAA;AAAA,UACvBE,QADuB,GAAA,WAAA,CAAA,QAAA;AAGzCG,MAAAA,SAAS,CAAEL,QAAD,CAAD,GAAA,EAATK,IAAS,CAATA;AACAA,MAAAA,SAAS,CAAA,QAAA,EAATA,IAAS,CAATA;AAEA,MAAA,KAAA,CAAA,WAAA,GAAA,IAAA;;;;;;;;uCAGiBC,S,EAAqB;AACtC,UAAIA,SAAS,CAATA,QAAAA,KAAuB,KAAA,KAAA,CAA3B,QAAA,EAAgD;AAC9CD,QAAAA,SAAS,CAAC,KAAA,KAAA,CAAD,QAAA,EAAsB,KAA/BA,WAAS,CAATA;AACD;AACF;;;2CAEsB;AACrB,aAAO,KAAP,WAAA;AACD;;;6BAEQ;AAAA,UACCL,QADD,GACc,KADd,KACc,CADd,QAAA;AAGP,aAAO,KAAK,CAAL,YAAA,CAAA,QAAA,EAA6B;AAClCO,QAAAA,GAAG,EAAE,KAAKC;AADwB,OAA7B,CAAP;AAGD;;;;EAvCqCV,KAAK,CAACC,S;;gBAAzBF,U,iBACE,Y;;gBADFA,U,eAKjB,OAAO,CAAP,GAAA,CAAA,QAAA,KAAA,YAAA,GACI;AACEG,EAAAA,QAAQ,EAAEC,SAAS,CAATA,OAAAA,CADZ,UAAA;AAEEC,EAAAA,QAAQ,EAAEC,WAAW,CAACC;AAFxB,CADJ,GAKI,E;;SAVaP,U","sourcesContent":["import * as PropTypes from 'prop-types';\nimport * as React from 'react';\n\nimport handleRef from './handleRef';\nimport { RefProps, refPropType } from './types';\n\nexport default class RefForward extends React.Component<RefProps> {\n  static displayName = 'RefForward';\n\n  // TODO: use Babel plugin for this\n  static propTypes =\n    process.env.NODE_ENV !== 'production'\n      ? {\n          children: PropTypes.element.isRequired,\n          innerRef: refPropType.isRequired,\n        }\n      : {};\n\n  currentNode: Node | null = null;\n\n  handleRefOverride = (node: HTMLElement) => {\n    const { children, innerRef } = this.props;\n\n    handleRef((children as React.ReactElement & { ref: React.Ref<any> }).ref, node);\n    handleRef(innerRef, node);\n\n    this.currentNode = node;\n  };\n\n  componentDidUpdate(prevProps: RefProps) {\n    if (prevProps.innerRef !== this.props.innerRef) {\n      handleRef(this.props.innerRef, this.currentNode);\n    }\n  }\n\n  componentWillUnmount() {\n    delete this.currentNode;\n  }\n\n  render() {\n    const { children } = this.props;\n\n    return React.cloneElement(children, {\n      ref: this.handleRefOverride,\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}