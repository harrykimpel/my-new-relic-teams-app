{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar defaultColor = 'transparent';\n\nvar getPseudoElementStyles = function getPseudoElementStyles(args) {\n  var borderEdgeValue = args.borderEdgeValue,\n      styles = _objectWithoutProperties(args, [\"borderEdgeValue\"]);\n\n  return Object.assign({\n    content: '\"\"',\n    position: 'absolute',\n    borderStyle: 'solid',\n    pointerEvents: 'none',\n    top: borderEdgeValue,\n    right: borderEdgeValue,\n    bottom: borderEdgeValue,\n    left: borderEdgeValue\n  }, styles);\n};\n/**\n * Returns style object that can be used for styling components on focus state.\n * NOTE: the element where this is used needs to have relative positioning so that the\n * pseudo elements created on focus can be properly positioned.\n */\n\n\nvar getBorderFocusStyles = function getBorderFocusStyles(args) {\n  var sv = args.variables;\n  var _args$borderWidth = args.borderWidth,\n      borderWidth = _args$borderWidth === void 0 ? sv.borderWidth : _args$borderWidth,\n      _args$borderRadius = args.borderRadius,\n      borderRadius = _args$borderRadius === void 0 ? sv.borderRadius : _args$borderRadius,\n      _args$focusInnerBorde = args.focusInnerBorderColor,\n      focusInnerBorderColor = _args$focusInnerBorde === void 0 ? sv.focusInnerBorderColor || defaultColor : _args$focusInnerBorde,\n      _args$focusOuterBorde = args.focusOuterBorderColor,\n      focusOuterBorderColor = _args$focusOuterBorde === void 0 ? sv.focusOuterBorderColor || defaultColor : _args$focusOuterBorde,\n      borderPadding = args.borderPadding;\n  var defaultBorderStyles = {\n    borderWidth: borderWidth,\n    borderRadius: borderRadius\n  };\n  return {\n    ':focus': {\n      outline: 0\n    },\n    ':focus-visible': {\n      borderColor: 'transparent',\n      ':before': getPseudoElementStyles(Object.assign({\n        zIndex: sv.zIndexes.foreground,\n        borderEdgeValue: borderPadding == null ? '0' : \"-\".concat(borderPadding),\n        borderColor: focusInnerBorderColor\n      }, defaultBorderStyles)),\n      ':after': getPseudoElementStyles(Object.assign({\n        zIndex: sv.zIndexes.foreground,\n        borderEdgeValue: borderPadding == null ? \"-\".concat(borderWidth) : \"calc(0px - \".concat(borderPadding, \" - \").concat(borderWidth, \")\"),\n        borderColor: focusOuterBorderColor\n      }, defaultBorderStyles))\n    }\n  };\n};\n\nexport default getBorderFocusStyles;","map":{"version":3,"sources":["themes/teams/getBorderFocusStyles.ts"],"names":["defaultColor","getPseudoElementStyles","borderEdgeValue","styles","args","content","position","borderStyle","pointerEvents","top","right","bottom","left","getBorderFocusStyles","sv","borderWidth","borderRadius","focusInnerBorderColor","focusOuterBorderColor","borderPadding","defaultBorderStyles","outline","borderColor","zIndex"],"mappings":";AAuBA,IAAMA,YAAY,GAAlB,aAAA;;AAEA,IAAMC,sBAAsB,GAAG,SAAzBA,sBAAyB,CAAA,IAAA,EAAoD;AAAA,MACzEC,eADyE,GAC1CE,IAD0C,CAAA,eAAA;AAAA,MACrDD,MADqD,GAAA,wBAAA,CAAA,IAAA,EAAA,CAAA,iBAAA,CAAA,CAAA;;AAGjF,SAAA,MAAA,CAAA,MAAA,CAAA;AACEE,IAAAA,OAAO,EADT,IAAA;AAEEC,IAAAA,QAAQ,EAFV,UAAA;AAGEC,IAAAA,WAAW,EAHb,OAAA;AAIEC,IAAAA,aAAa,EAJf,MAAA;AAKEC,IAAAA,GAAG,EALL,eAAA;AAMEC,IAAAA,KAAK,EANP,eAAA;AAOEC,IAAAA,MAAM,EAPR,eAAA;AAQEC,IAAAA,IAAI,EAAEV;AARR,GAAA,EAAA,MAAA,CAAA;AAHF,CAAA;AAgBA;;;;;;;AAKA,IAAMW,oBAAoB,GAAG,SAAvBA,oBAAuB,CAAA,IAAA,EAA4C;AACvE,MAAMC,EAAE,GAAGV,IAAI,CAAf,SAAA;AADuE,MAAA,iBAAA,GAQnEA,IARmE,CAAA,WAAA;AAAA,MAGrEW,WAHqE,GAAA,iBAAA,KAAA,KAAA,CAAA,GAGvDD,EAAE,CAHqD,WAAA,GAAA,iBAAA;AAAA,MAAA,kBAAA,GAQnEV,IARmE,CAAA,YAAA;AAAA,MAIrEY,YAJqE,GAAA,kBAAA,KAAA,KAAA,CAAA,GAItDF,EAAE,CAJoD,YAAA,GAAA,kBAAA;AAAA,MAAA,qBAAA,GAQnEV,IARmE,CAAA,qBAAA;AAAA,MAKrEa,qBALqE,GAAA,qBAAA,KAAA,KAAA,CAAA,GAK7CH,EAAE,CAAFA,qBAAAA,IAL6C,YAAA,GAAA,qBAAA;AAAA,MAAA,qBAAA,GAQnEV,IARmE,CAAA,qBAAA;AAAA,MAMrEc,qBANqE,GAAA,qBAAA,KAAA,KAAA,CAAA,GAM7CJ,EAAE,CAAFA,qBAAAA,IAN6C,YAAA,GAAA,qBAAA;AAAA,MAOrEK,aAPqE,GAQnEf,IARmE,CAAA,aAAA;AAUvE,MAAMgB,mBAAwC,GAAG;AAAEL,IAAAA,WAAW,EAAb,WAAA;AAAeC,IAAAA,YAAY,EAAZA;AAAf,GAAjD;AAEA,SAAO;AACL,cAAU;AACRK,MAAAA,OAAO,EAAE;AADD,KADL;AAIL,sBAAkB;AAChBC,MAAAA,WAAW,EADK,aAAA;AAGhB,iBAAWrB,sBAAsB,CAAA,MAAA,CAAA,MAAA,CAAA;AAC/BsB,QAAAA,MAAM,EAAET,EAAE,CAAFA,QAAAA,CADuB,UAAA;AAE/BZ,QAAAA,eAAe,EAAEiB,aAAa,IAAbA,IAAAA,GAAAA,GAAAA,GAAAA,IAAAA,MAAAA,CAFc,aAEdA,CAFc;AAG/BG,QAAAA,WAAW,EAAEL;AAHkB,OAAA,EAHjB,mBAGiB,CAAA,CAHjB;AAUhB,gBAAUhB,sBAAsB,CAAA,MAAA,CAAA,MAAA,CAAA;AAC9BsB,QAAAA,MAAM,EAAET,EAAE,CAAFA,QAAAA,CADsB,UAAA;AAE9BZ,QAAAA,eAAe,EAAEiB,aAAa,IAAbA,IAAAA,GAAAA,IAAAA,MAAAA,CAAAA,WAAAA,CAAAA,GAAAA,cAAAA,MAAAA,CAAAA,aAAAA,EAAAA,KAAAA,EAAAA,MAAAA,CAAAA,WAAAA,EAFa,GAEbA,CAFa;AAG9BG,QAAAA,WAAW,EAAEJ;AAHiB,OAAA,EAAA,mBAAA,CAAA;AAVhB;AAJb,GAAP;AAZF,CAAA;;AAoCA,eAAA,oBAAA","sourcesContent":["import { ICSSInJSStyle, SiteVariablesPrepared } from '@fluentui/styles';\nimport * as React from 'react';\n\ntype CSSBorderStyles = Pick<React.CSSProperties, 'borderWidth' | 'borderRadius'>;\n\ntype BorderFocusStyles = CSSBorderStyles & {\n  variables?:\n    | SiteVariablesPrepared\n    | {\n        borderWidth: string;\n        borderRadius: string;\n        focusInnerBorderColor: string;\n        focusOuterBorderColor: string;\n\n        zIndexes: { foreground: string };\n      };\n  focusInnerBorderColor?: string;\n  focusOuterBorderColor?: string;\n  borderPadding?: React.CSSProperties['padding'];\n};\n\ntype BorderPseudoElementStyles = CSSBorderStyles & { borderEdgeValue: string };\n\nconst defaultColor = 'transparent';\n\nconst getPseudoElementStyles = (args: BorderPseudoElementStyles): ICSSInJSStyle => {\n  const { borderEdgeValue, ...styles } = args;\n\n  return {\n    content: '\"\"',\n    position: 'absolute',\n    borderStyle: 'solid',\n    pointerEvents: 'none',\n    top: borderEdgeValue,\n    right: borderEdgeValue,\n    bottom: borderEdgeValue,\n    left: borderEdgeValue,\n    ...styles,\n  };\n};\n\n/**\n * Returns style object that can be used for styling components on focus state.\n * NOTE: the element where this is used needs to have relative positioning so that the\n * pseudo elements created on focus can be properly positioned.\n */\nconst getBorderFocusStyles = (args: BorderFocusStyles): ICSSInJSStyle => {\n  const sv = args.variables;\n  const {\n    borderWidth = sv.borderWidth,\n    borderRadius = sv.borderRadius,\n    focusInnerBorderColor = sv.focusInnerBorderColor || defaultColor,\n    focusOuterBorderColor = sv.focusOuterBorderColor || defaultColor,\n    borderPadding,\n  } = args;\n\n  const defaultBorderStyles: React.CSSProperties = { borderWidth, borderRadius };\n\n  return {\n    ':focus': {\n      outline: 0,\n    },\n    ':focus-visible': {\n      borderColor: 'transparent',\n\n      ':before': getPseudoElementStyles({\n        zIndex: sv.zIndexes.foreground,\n        borderEdgeValue: borderPadding == null ? '0' : `-${borderPadding}`,\n        borderColor: focusInnerBorderColor,\n        ...defaultBorderStyles,\n      }),\n\n      ':after': getPseudoElementStyles({\n        zIndex: sv.zIndexes.foreground,\n        borderEdgeValue: borderPadding == null ? `-${borderWidth}` : `calc(0px - ${borderPadding} - ${borderWidth})`,\n        borderColor: focusOuterBorderColor,\n        ...defaultBorderStyles,\n      }),\n    },\n  };\n};\n\nexport default getBorderFocusStyles;\n"]},"metadata":{},"sourceType":"module"}