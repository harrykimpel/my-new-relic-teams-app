{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\n\nvar isObject = function isObject(o) {\n  return o !== null && _typeof(o) === 'object' && !Array.isArray(o);\n}; // Heads Up!\n// Changes here need to consider breaking all object references.\n// Merging should result in a themes that are non-mutated and have broken references.\n\n\nvar deepmerge = function deepmerge() {\n  var inner = function inner(target, source) {\n    Object.keys(source).forEach(function (k) {\n      if (isObject(source[k])) {\n        if (!isObject(target[k])) {\n          target[k] = {};\n        }\n\n        inner(target[k], source[k]);\n      } else {\n        target[k] = source[k]; // TODO: do deep clone for arrays? We currently do not have any deep arrays in variables\n      }\n    });\n    return target;\n  };\n\n  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n    sources[_key] = arguments[_key];\n  }\n\n  return sources.filter(Boolean).reduce(function (acc, src) {\n    return inner(acc, src);\n  }, {});\n};\n\nexport default deepmerge;","map":{"version":3,"sources":["deepmerge.ts"],"names":["isObject","o","Array","deepmerge","sources","inner","Object","source","target"],"mappings":";;AAAA,IAAMA,QAAQ,GAAG,SAAXA,QAAW,CAAA,CAAA,EAAC;AAAA,SAAIC,CAAC,KAADA,IAAAA,IAAc,OAAA,CAAA,CAAA,CAAA,KAAdA,QAAAA,IAAuC,CAACC,KAAK,CAALA,OAAAA,CAA5C,CAA4CA,CAA5C;AAAlB,CAAA,C,CAEA;AACA;AACA;;;AACA,IAAMC,SAAS,GAAG,SAAZA,SAAY,GAAgB;AAChC,MAAME,KAAK,GAAG,SAARA,KAAQ,CAAA,MAAA,EAAA,MAAA,EAAoB;AAChCC,IAAAA,MAAM,CAANA,IAAAA,CAAAA,MAAAA,EAAAA,OAAAA,CAA4B,UAAA,CAAA,EAAK;AAC/B,UAAIN,QAAQ,CAACO,MAAM,CAAnB,CAAmB,CAAP,CAAZ,EAAyB;AACvB,YAAI,CAACP,QAAQ,CAACQ,MAAM,CAApB,CAAoB,CAAP,CAAb,EAA0B;AACxBA,UAAAA,MAAM,CAANA,CAAM,CAANA,GAAAA,EAAAA;AACD;;AAEDH,QAAAA,KAAK,CAACG,MAAM,CAAP,CAAO,CAAP,EAAYD,MAAM,CAAvBF,CAAuB,CAAlB,CAALA;AALF,OAAA,MAMO;AACLG,QAAAA,MAAM,CAANA,CAAM,CAANA,GAAYD,MAAM,CADb,CACa,CAAlBC,CADK,CACkB;AACxB;AATHF,KAAAA;AAWA,WAAA,MAAA;AAZF,GAAA;;AADgC,OAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,EAAZF,OAAY,GAAA,IAAA,KAAA,CAAA,IAAA,CAAA,EAAA,IAAA,GAAA,CAAA,EAAA,IAAA,GAAA,IAAA,EAAA,IAAA,EAAA,EAAA;AAAZA,IAAAA,OAAY,CAAA,IAAA,CAAZA,GAAY,SAAA,CAAA,IAAA,CAAZA;AAAY;;AAehC,SAAO,OAAO,CAAP,MAAA,CAAA,OAAA,EAAA,MAAA,CAA+B,UAAA,GAAA,EAAA,GAAA,EAAA;AAAA,WAAcC,KAAK,CAAA,GAAA,EAAnB,GAAmB,CAAnB;AAA/B,GAAA,EAAP,EAAO,CAAP;AAfF,CAAA;;AAkBA,eAAA,SAAA","sourcesContent":["const isObject = o => o !== null && typeof o === 'object' && !Array.isArray(o);\n\n// Heads Up!\n// Changes here need to consider breaking all object references.\n// Merging should result in a themes that are non-mutated and have broken references.\nconst deepmerge = (...sources) => {\n  const inner = (target, source) => {\n    Object.keys(source).forEach(k => {\n      if (isObject(source[k])) {\n        if (!isObject(target[k])) {\n          target[k] = {};\n        }\n\n        inner(target[k], source[k]);\n      } else {\n        target[k] = source[k]; // TODO: do deep clone for arrays? We currently do not have any deep arrays in variables\n      }\n    });\n    return target;\n  };\n  return sources.filter(Boolean).reduce((acc, src) => inner(acc, src), {});\n};\n\nexport default deepmerge;\n"]},"metadata":{},"sourceType":"module"}