{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _startsWith from \"lodash/startsWith\";\nimport _filter from \"lodash/filter\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _keys from \"lodash/keys\";\nimport _intersection from \"lodash/intersection\";\nimport _has from \"lodash/has\";\nimport _each from \"lodash/each\";\nimport _invoke from \"lodash/invoke\";\nimport UIComponent from './UIComponent';\n\nvar getDefaultPropName = function getDefaultPropName(prop) {\n  return \"default\".concat(prop[0].toUpperCase() + prop.slice(1));\n};\n/**\n * Return the auto controlled state value for a give prop. The initial value is chosen in this order:\n *  - regular props\n *  - then, default props\n *  - then, initial state\n *  - then, `checked` defaults to false\n *  - then, `value` defaults to '' or [] if props.multiple\n *  - else, undefined\n *\n *  @param propName - A prop name\n *  @param props - A props object\n *  @param state - A state object\n *  @param includeDefaults - Whether or not to heed the default props or initial state\n */\n\n\nexport var getAutoControlledStateValue = function getAutoControlledStateValue(propName, props) {\n  var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  var includeDefaults = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false; // regular props\n\n  var propValue = props[propName];\n  if (propValue !== undefined) return propValue;\n\n  if (includeDefaults) {\n    // defaultProps\n    var defaultProp = props[getDefaultPropName(propName)];\n    if (defaultProp !== undefined) return defaultProp; // initial state - state may be null or undefined\n\n    if (state) {\n      var initialState = state[propName];\n      if (initialState !== undefined) return initialState;\n    }\n  } // React doesn't allow changing from uncontrolled to controlled components,\n  // default checked/value if they were not present.\n\n\n  if (propName === 'checked') return false;\n  if (propName === 'value') return props.multiple ? [] : ''; // otherwise, undefined\n};\n\nvar AutoControlledComponent = /*#__PURE__*/function (_UIComponent) {\n  _inherits(AutoControlledComponent, _UIComponent);\n\n  function AutoControlledComponent(props, ctx) {\n    var _this;\n\n    _classCallCheck(this, AutoControlledComponent);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(AutoControlledComponent).call(this, props, ctx));\n    var _ref = _this.constructor,\n        autoControlledProps = _ref.autoControlledProps,\n        getAutoControlledStateFromProps = _ref.getAutoControlledStateFromProps;\n    var state = _invoke(_assertThisInitialized(_this), 'getInitialAutoControlledState', _this.props) || {};\n\n    if (process.env.NODE_ENV !== 'production') {\n      var _ref2 = _this.constructor,\n          defaultProps = _ref2.defaultProps,\n          name = _ref2.name,\n          propTypes = _ref2.propTypes,\n          getDerivedStateFromProps = _ref2.getDerivedStateFromProps; // require usage of getAutoControlledStateFromProps()\n\n      if (getDerivedStateFromProps !== AutoControlledComponent.getDerivedStateFromProps) {\n        /* eslint-disable-next-line no-console */\n        console.error(\"Auto controlled \".concat(name, \" must specify a static getAutoControlledStateFromProps() instead of getDerivedStateFromProps().\"));\n      } // require static autoControlledProps\n\n\n      if (!autoControlledProps) {\n        /* eslint-disable-next-line no-console */\n        console.error(\"Auto controlled \".concat(name, \" must specify a static autoControlledProps array.\"));\n      } // require propTypes\n\n\n      _each(autoControlledProps, function (prop) {\n        var defaultProp = getDefaultPropName(prop); // regular prop\n\n        if (!_has(propTypes, defaultProp)) {\n          /* eslint-disable-next-line no-console */\n          console.error(\"\".concat(name, \" is missing \\\"\").concat(defaultProp, \"\\\" propTypes validation for auto controlled prop \\\"\").concat(prop, \"\\\".\"));\n        } // its default prop\n\n\n        if (!_has(propTypes, prop)) {\n          /* eslint-disable-next-line no-console */\n          console.error(\"\".concat(name, \" is missing propTypes validation for auto controlled prop \\\"\").concat(prop, \"\\\".\"));\n        }\n      }); // prevent autoControlledProps in defaultProps\n      //\n      // When setting state, auto controlled props values always win (so the parent can manage them).\n      // It is not reasonable to decipher the difference between props from the parent and defaultProps.\n      // Allowing defaultProps results in trySetState always deferring to the defaultProp value.\n      // Auto controlled props also listed in defaultProps can never be updated.\n      //\n      // To set defaults for an AutoControlled prop, you can set the initial state in the\n      // constructor or by using an ES7 property initializer:\n      // https://babeljs.io/blog/2015/06/07/react-on-es6-plus#property-initializers\n\n\n      var illegalDefaults = _intersection(autoControlledProps, _keys(defaultProps));\n\n      if (!_isEmpty(illegalDefaults)) {\n        /* eslint-disable-next-line no-console */\n        console.error(['Do not set defaultProps for autoControlledProps. You can set defaults by', 'setting state in the constructor or using an ES7 property initializer', '(https://babeljs.io/blog/2015/06/07/react-on-es6-plus#property-initializers)', \"See \".concat(name, \" props: \\\"\").concat(illegalDefaults, \"\\\".\")].join(' '));\n      } // prevent listing defaultProps in autoControlledProps\n      //\n      // Default props are automatically handled.\n      // Listing defaults in autoControlledProps would result in allowing defaultDefaultValue props.\n\n\n      var illegalAutoControlled = _filter(autoControlledProps, function (prop) {\n        return _startsWith(prop, 'default');\n      });\n\n      if (!_isEmpty(illegalAutoControlled)) {\n        /* eslint-disable-next-line no-console */\n        console.error(['Do not add default props to autoControlledProps.', 'Default props are automatically handled.', \"See \".concat(name, \" autoControlledProps: \\\"\").concat(illegalAutoControlled, \"\\\".\")].join(' '));\n      }\n    } // Auto controlled props are copied to state.\n    // Set initial state by copying auto controlled props to state.\n    // Also look for the default prop for any auto controlled props (foo => defaultFoo)\n    // so we can set initial values from defaults.\n\n\n    var initialAutoControlledState = autoControlledProps.reduce(function (acc, prop) {\n      acc[prop] = getAutoControlledStateValue(prop, _this.props, state, true);\n\n      if (process.env.NODE_ENV !== 'production') {\n        var defaultPropName = getDefaultPropName(prop);\n        var _name = _this.constructor.name; // prevent defaultFoo={} along side foo={}\n\n        if (!_isUndefined(_this.props[defaultPropName]) && !_isUndefined(_this.props[prop])) {\n          /* eslint-disable-next-line no-console */\n          console.error(\"\".concat(_name, \" prop \\\"\").concat(prop, \"\\\" is auto controlled. Specify either \").concat(defaultPropName, \" or \").concat(prop, \", but not both.\"));\n        }\n      }\n\n      return acc;\n    }, {});\n    _this.state = Object.assign({}, state, {}, initialAutoControlledState, {\n      autoControlledProps: autoControlledProps,\n      getAutoControlledStateFromProps: getAutoControlledStateFromProps\n    });\n    return _this;\n  }\n\n  return AutoControlledComponent;\n}(UIComponent); // eslint-disable-next-line func-names\n\n\n_defineProperty(AutoControlledComponent, \"getDerivedStateFromProps\", void 0);\n\n_defineProperty(AutoControlledComponent, \"getAutoControlledStateFromProps\", void 0);\n\nexport { AutoControlledComponent as default };\n\nAutoControlledComponent.getDerivedStateFromProps = function (props, state) {\n  var autoControlledProps = state.autoControlledProps,\n      getAutoControlledStateFromProps = state.getAutoControlledStateFromProps; // Solve the next state for autoControlledProps\n\n  var newStateFromProps = autoControlledProps.reduce(function (acc, prop) {\n    var isNextDefined = !_isUndefined(props[prop]); // if next is defined then use its value\n\n    if (isNextDefined) acc[prop] = props[prop];\n    return acc;\n  }, {}); // Due to the inheritance of the AutoControlledComponent we should call its\n  // getAutoControlledStateFromProps() and merge it with the existing state\n\n  if (getAutoControlledStateFromProps) {\n    var computedState = getAutoControlledStateFromProps(props, Object.assign({}, state, {}, newStateFromProps)); // We should follow the idea of getDerivedStateFromProps() and return only modified state\n\n    return Object.assign({}, newStateFromProps, {}, computedState);\n  }\n\n  return newStateFromProps;\n}; // eslint-disable-next-line func-names\n\n\nAutoControlledComponent.getAutoControlledStateFromProps = function (props, state) {\n  return null;\n};","map":{"version":3,"sources":["utils/AutoControlledComponent.tsx"],"names":["getDefaultPropName","prop","getAutoControlledStateValue","state","undefined","includeDefaults","propValue","props","defaultProp","initialState","propName","AutoControlledComponent","UIComponent","autoControlledProps","getAutoControlledStateFromProps","process","defaultProps","name","propTypes","getDerivedStateFromProps","console","illegalDefaults","illegalAutoControlled","initialAutoControlledState","acc","defaultPropName","newStateFromProps","isNextDefined","computedState"],"mappings":"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","sourcesContent":["/**\n * Why choose inheritance over a HOC?  Multiple advantages for this particular use case.\n * In short, we need identical functionality to setState(), unless there is a prop defined\n * for the state key.  Also:\n *\n * 1. Single Renders\n *    Calling trySetState() in constructor(), componentWillMount(), or componentWillReceiveProps()\n *    does not cause two renders. Consumers and tests do not have to wait two renders to get state.\n *    See www.react.run/4kJFdKoxb/27 for an example of this issue.\n *\n * 2. Simple Testing\n *    Using a HOC means you must either test the undecorated component or test through the decorator.\n *    Testing the undecorated component means you must mock the decorator functionality.\n *    Testing through the HOC means you can not simply shallow render your component.\n *\n * 3. Statics\n *    HOC wrap instances, so statics are no longer accessible.  They can be hoisted, but this is more\n *    looping over properties and storing references.  We rely heavily on statics for testing and sub\n *    components.\n *\n * 4. Instance Methods\n *    Some instance methods may be exposed to users via refs.  Again, these are lost with HOC unless\n *    hoisted and exposed by the HOC.\n */\nimport * as _ from 'lodash';\nimport * as React from 'react';\n\nimport UIComponent from './UIComponent';\n\nconst getDefaultPropName = prop => `default${prop[0].toUpperCase() + prop.slice(1)}`;\n\n/**\n * Return the auto controlled state value for a give prop. The initial value is chosen in this order:\n *  - regular props\n *  - then, default props\n *  - then, initial state\n *  - then, `checked` defaults to false\n *  - then, `value` defaults to '' or [] if props.multiple\n *  - else, undefined\n *\n *  @param propName - A prop name\n *  @param props - A props object\n *  @param state - A state object\n *  @param includeDefaults - Whether or not to heed the default props or initial state\n */\nexport const getAutoControlledStateValue = (\n  propName: string,\n  props: any,\n  state: any = undefined,\n  includeDefaults: boolean = false,\n) => {\n  // regular props\n  const propValue = props[propName];\n  if (propValue !== undefined) return propValue;\n\n  if (includeDefaults) {\n    // defaultProps\n    const defaultProp = props[getDefaultPropName(propName)];\n    if (defaultProp !== undefined) return defaultProp;\n\n    // initial state - state may be null or undefined\n    if (state) {\n      const initialState = state[propName];\n      if (initialState !== undefined) return initialState;\n    }\n  }\n\n  // React doesn't allow changing from uncontrolled to controlled components,\n  // default checked/value if they were not present.\n  if (propName === 'checked') return false;\n  if (propName === 'value') return props.multiple ? [] : '';\n\n  // otherwise, undefined\n};\n\nexport default class AutoControlledComponent<P = {}, S = {}> extends UIComponent<P, S> {\n  constructor(props: P, ctx: any) {\n    super(props, ctx);\n\n    const { autoControlledProps, getAutoControlledStateFromProps } = this.constructor as any;\n    const state = _.invoke(this, 'getInitialAutoControlledState', this.props) || {};\n\n    if (process.env.NODE_ENV !== 'production') {\n      const { defaultProps, name, propTypes, getDerivedStateFromProps } = this.constructor as any;\n\n      // require usage of getAutoControlledStateFromProps()\n      if (getDerivedStateFromProps !== AutoControlledComponent.getDerivedStateFromProps) {\n        /* eslint-disable-next-line no-console */\n        console.error(\n          `Auto controlled ${name} must specify a static getAutoControlledStateFromProps() instead of getDerivedStateFromProps().`,\n        );\n      }\n\n      // require static autoControlledProps\n      if (!autoControlledProps) {\n        /* eslint-disable-next-line no-console */\n        console.error(`Auto controlled ${name} must specify a static autoControlledProps array.`);\n      }\n\n      // require propTypes\n      _.each(autoControlledProps, prop => {\n        const defaultProp = getDefaultPropName(prop);\n        // regular prop\n        if (!_.has(propTypes, defaultProp)) {\n          /* eslint-disable-next-line no-console */\n          console.error(`${name} is missing \"${defaultProp}\" propTypes validation for auto controlled prop \"${prop}\".`);\n        }\n        // its default prop\n        if (!_.has(propTypes, prop)) {\n          /* eslint-disable-next-line no-console */\n          console.error(`${name} is missing propTypes validation for auto controlled prop \"${prop}\".`);\n        }\n      });\n\n      // prevent autoControlledProps in defaultProps\n      //\n      // When setting state, auto controlled props values always win (so the parent can manage them).\n      // It is not reasonable to decipher the difference between props from the parent and defaultProps.\n      // Allowing defaultProps results in trySetState always deferring to the defaultProp value.\n      // Auto controlled props also listed in defaultProps can never be updated.\n      //\n      // To set defaults for an AutoControlled prop, you can set the initial state in the\n      // constructor or by using an ES7 property initializer:\n      // https://babeljs.io/blog/2015/06/07/react-on-es6-plus#property-initializers\n      const illegalDefaults = _.intersection(autoControlledProps, _.keys(defaultProps));\n      if (!_.isEmpty(illegalDefaults)) {\n        /* eslint-disable-next-line no-console */\n        console.error(\n          [\n            'Do not set defaultProps for autoControlledProps. You can set defaults by',\n            'setting state in the constructor or using an ES7 property initializer',\n            '(https://babeljs.io/blog/2015/06/07/react-on-es6-plus#property-initializers)',\n            `See ${name} props: \"${illegalDefaults}\".`,\n          ].join(' '),\n        );\n      }\n\n      // prevent listing defaultProps in autoControlledProps\n      //\n      // Default props are automatically handled.\n      // Listing defaults in autoControlledProps would result in allowing defaultDefaultValue props.\n      const illegalAutoControlled = _.filter(autoControlledProps, prop => _.startsWith(prop, 'default'));\n      if (!_.isEmpty(illegalAutoControlled)) {\n        /* eslint-disable-next-line no-console */\n        console.error(\n          [\n            'Do not add default props to autoControlledProps.',\n            'Default props are automatically handled.',\n            `See ${name} autoControlledProps: \"${illegalAutoControlled}\".`,\n          ].join(' '),\n        );\n      }\n    }\n\n    // Auto controlled props are copied to state.\n    // Set initial state by copying auto controlled props to state.\n    // Also look for the default prop for any auto controlled props (foo => defaultFoo)\n    // so we can set initial values from defaults.\n    const initialAutoControlledState = autoControlledProps.reduce((acc, prop) => {\n      acc[prop] = getAutoControlledStateValue(prop, this.props, state, true);\n\n      if (process.env.NODE_ENV !== 'production') {\n        const defaultPropName = getDefaultPropName(prop);\n        const { name } = this.constructor;\n        // prevent defaultFoo={} along side foo={}\n        if (!_.isUndefined(this.props[defaultPropName]) && !_.isUndefined(this.props[prop])) {\n          /* eslint-disable-next-line no-console */\n          console.error(\n            `${name} prop \"${prop}\" is auto controlled. Specify either ${defaultPropName} or ${prop}, but not both.`,\n          );\n        }\n      }\n\n      return acc;\n    }, {});\n\n    this.state = {\n      ...state,\n      ...initialAutoControlledState,\n      autoControlledProps,\n      getAutoControlledStateFromProps,\n    };\n  }\n\n  static getDerivedStateFromProps: React.GetDerivedStateFromProps<any, any>;\n\n  /**\n   * Override this method to use getDerivedStateFromProps() in child components.\n   */\n  static getAutoControlledStateFromProps: React.GetDerivedStateFromProps<any, any>;\n}\n\n// eslint-disable-next-line func-names\nAutoControlledComponent.getDerivedStateFromProps = function(props, state) {\n  const { autoControlledProps, getAutoControlledStateFromProps } = state;\n\n  // Solve the next state for autoControlledProps\n  const newStateFromProps = autoControlledProps.reduce((acc, prop) => {\n    const isNextDefined = !_.isUndefined(props[prop]);\n\n    // if next is defined then use its value\n    if (isNextDefined) acc[prop] = props[prop];\n\n    return acc;\n  }, {});\n\n  // Due to the inheritance of the AutoControlledComponent we should call its\n  // getAutoControlledStateFromProps() and merge it with the existing state\n  if (getAutoControlledStateFromProps) {\n    const computedState = getAutoControlledStateFromProps(props, {\n      ...state,\n      ...newStateFromProps,\n    });\n\n    // We should follow the idea of getDerivedStateFromProps() and return only modified state\n    return { ...newStateFromProps, ...computedState };\n  }\n\n  return newStateFromProps;\n};\n\n// eslint-disable-next-line func-names\nAutoControlledComponent.getAutoControlledStateFromProps = function(props, state) {\n  return null;\n};\n"]},"metadata":{},"sourceType":"module"}