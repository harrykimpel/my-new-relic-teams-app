{"ast":null,"code":"import _get from \"lodash/get\";\nimport _map from \"lodash/map\";\nimport _debounce from \"lodash/debounce\";\nimport _invoke from \"lodash/invoke\";\nimport _forEachRight from \"lodash/forEachRight\";\nimport { toolbarBehavior, toggleButtonBehavior, IS_FOCUSABLE_ATTRIBUTE } from '@fluentui/accessibility';\nimport { getElementType, getFirstFocusable, useAccessibility, useStyles, useTelemetry, useUnhandledProps } from '@fluentui/react-bindings';\nimport { EventListener } from '@fluentui/react-component-event-listener';\nimport { Ref } from '@fluentui/react-component-ref';\nimport { MoreIcon } from '@fluentui/react-icons-northstar';\nimport * as customPropTypes from '@fluentui/react-proptypes';\nimport * as PropTypes from 'prop-types';\nimport * as React from 'react'; // @ts-ignore\n\nimport { ThemeContext } from 'react-fela';\nimport { withSafeTypeForAs } from '../../types';\nimport { childrenExist, createShorthandFactory, commonPropTypes } from '../../utils';\nimport ToolbarCustomItem from './ToolbarCustomItem';\nimport ToolbarDivider from './ToolbarDivider';\nimport ToolbarItem from './ToolbarItem';\nimport ToolbarMenu from './ToolbarMenu';\nimport ToolbarMenuDivider from './ToolbarMenuDivider';\nimport ToolbarMenuItem from './ToolbarMenuItem';\nimport ToolbarMenuRadioGroup from './ToolbarMenuRadioGroup';\nimport ToolbarRadioGroup from './ToolbarRadioGroup';\nimport { ToolbarVariablesProvider } from './toolbarVariablesContext';\nvar WAS_FOCUSABLE_ATTRIBUTE = 'data-was-focusable';\nexport var toolbarClassName = 'ui-toolbar';\n\nvar Toolbar = function Toolbar(props) {\n  var context = React.useContext(ThemeContext);\n\n  var _useTelemetry = useTelemetry(Toolbar.displayName, context.telemetry),\n      setStart = _useTelemetry.setStart,\n      setEnd = _useTelemetry.setEnd;\n\n  setStart();\n  var accessibility = props.accessibility,\n      className = props.className,\n      children = props.children,\n      design = props.design,\n      getOverflowItems = props.getOverflowItems,\n      items = props.items,\n      overflow = props.overflow,\n      overflowItem = props.overflowItem,\n      overflowOpen = props.overflowOpen,\n      styles = props.styles,\n      variables = props.variables;\n  var overflowContainerRef = React.useRef();\n  var overflowItemRef = React.useRef();\n  var offsetMeasureRef = React.useRef();\n  var containerRef = React.useRef(); // index of the last visible item in Toolbar, the rest goes to overflow menu\n\n  var lastVisibleItemIndex = React.useRef();\n  var animationFrameId = React.useRef();\n  var getA11Props = useAccessibility(accessibility, {\n    debugName: Toolbar.displayName,\n    rtl: context.rtl\n  });\n\n  var _useStyles = useStyles(Toolbar.displayName, {\n    className: toolbarClassName,\n    mapPropsToInlineStyles: function mapPropsToInlineStyles() {\n      return {\n        className: className,\n        design: design,\n        styles: styles,\n        variables: variables\n      };\n    },\n    rtl: context.rtl\n  }),\n      classes = _useStyles.classes;\n\n  var ElementType = getElementType(props);\n  var unhandledProps = useUnhandledProps(Toolbar.handledProps, props);\n\n  var hide = function hide(el) {\n    if (el.style.visibility === 'hidden') {\n      return;\n    }\n\n    if (context.target.activeElement === el || el.contains(context.target.activeElement)) {\n      if (containerRef.current) {\n        var firstFocusableItem = getFirstFocusable(containerRef.current, containerRef.current.firstElementChild);\n\n        if (firstFocusableItem) {\n          firstFocusableItem.focus();\n        }\n      }\n    }\n\n    el.style.visibility = 'hidden';\n    var wasFocusable = el.getAttribute(IS_FOCUSABLE_ATTRIBUTE);\n\n    if (wasFocusable) {\n      el.setAttribute(WAS_FOCUSABLE_ATTRIBUTE, wasFocusable);\n    }\n\n    el.setAttribute(IS_FOCUSABLE_ATTRIBUTE, 'false');\n  };\n\n  var show = function show(el) {\n    if (el.style.visibility !== 'hidden') {\n      return false;\n    }\n\n    el.style.visibility = null;\n    var wasFocusable = el.getAttribute(WAS_FOCUSABLE_ATTRIBUTE);\n\n    if (wasFocusable) {\n      el.setAttribute(IS_FOCUSABLE_ATTRIBUTE, wasFocusable);\n      el.removeAttribute(WAS_FOCUSABLE_ATTRIBUTE);\n    } else {\n      el.removeAttribute(IS_FOCUSABLE_ATTRIBUTE);\n    }\n\n    return true;\n  };\n  /**\n   * Checks if `item` overflows a `container`.\n   * TODO: check and fix all margin combination\n   */\n\n\n  var isItemOverflowing = function isItemOverflowing(itemBoundingRect, containerBoundingRect) {\n    return itemBoundingRect.right > containerBoundingRect.right || itemBoundingRect.left < containerBoundingRect.left;\n  };\n  /**\n   * Checks if `item` would collide with eventual position of `overflowItem`.\n   */\n\n\n  var wouldItemCollide = function wouldItemCollide($item, itemBoundingRect, overflowItemBoundingRect, containerBoundingRect) {\n    var actualWindow = context.target.defaultView;\n    var wouldCollide;\n\n    if (context.rtl) {\n      var itemLeftMargin = parseFloat(actualWindow.getComputedStyle($item).marginLeft) || 0;\n      wouldCollide = itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin < containerBoundingRect.left; // console.log('Collision [RTL]', {\n      //   wouldCollide,\n      //   'itemBoundingRect.left': itemBoundingRect.left,\n      //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,\n      //   itemRightMargin: itemLeftMargin,\n      //   sum: itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin,\n      //   'overflowContainerBoundingRect.left': containerBoundingRect.left,\n      // })\n    } else {\n      var itemRightMargin = parseFloat(actualWindow.getComputedStyle($item).marginRight) || 0;\n      wouldCollide = itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin > containerBoundingRect.right; // console.log('Collision', {\n      //   wouldCollide,\n      //   'itemBoundingRect.right': itemBoundingRect.right,\n      //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,\n      //   itemRightMargin,\n      //   sum: itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin,\n      //   'overflowContainerBoundingRect.right': containerBoundingRect.right,\n      // })\n    }\n\n    return wouldCollide;\n  };\n  /**\n   * Positions overflowItem next to lastVisible item\n   * TODO: consider overflowItem margin\n   */\n\n\n  var setOverflowPosition = function setOverflowPosition($overflowItem, $lastVisibleItem, lastVisibleItemRect, containerBoundingRect, absolutePositioningOffset) {\n    var actualWindow = context.target.defaultView;\n\n    if ($lastVisibleItem) {\n      if (context.rtl) {\n        var lastVisibleItemMarginLeft = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginLeft) || 0;\n        $overflowItem.style.right = \"\".concat(containerBoundingRect.right - lastVisibleItemRect.left + lastVisibleItemMarginLeft + absolutePositioningOffset.horizontal, \"px\");\n      } else {\n        var lastVisibleItemRightMargin = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginRight) || 0;\n        $overflowItem.style.left = \"\".concat(lastVisibleItemRect.right - containerBoundingRect.left + lastVisibleItemRightMargin + absolutePositioningOffset.horizontal, \"px\");\n      }\n    } else {\n      // there is no last visible item -> position the overflow as the first item\n      lastVisibleItemIndex.current = -1;\n\n      if (context.rtl) {\n        $overflowItem.style.right = \"\".concat(absolutePositioningOffset.horizontal, \"px\");\n      } else {\n        $overflowItem.style.left = \"\".concat(absolutePositioningOffset.horizontal, \"px\");\n      }\n    }\n  };\n\n  var hideOverflowItems = function hideOverflowItems() {\n    var $overflowContainer = overflowContainerRef.current;\n    var $overflowItem = overflowItemRef.current;\n    var $offsetMeasure = offsetMeasureRef.current;\n\n    if (!$overflowContainer || !$overflowItem || !$offsetMeasure) {\n      return;\n    } // workaround: when resizing window with popup opened the container contents scroll for some reason\n\n\n    if (context.rtl) {\n      $overflowContainer.scrollTo(Number.MAX_SAFE_INTEGER, 0);\n    } else {\n      $overflowContainer.scrollTo(0, 0);\n    }\n\n    var $items = $overflowContainer.children;\n    var overflowContainerBoundingRect = $overflowContainer.getBoundingClientRect();\n    var overflowItemBoundingRect = $overflowItem.getBoundingClientRect();\n    var offsetMeasureBoundingRect = $offsetMeasure.getBoundingClientRect(); // Absolute positioning offset\n    // Overflow menu is absolutely positioned relative to root slot\n    // If there is padding set on the root slot boundingClientRect computations use inner content box,\n    // but absolute position is relative to root slot's PADDING box.\n    // We compute absolute positioning offset\n    // By measuring position of an offsetMeasure element absolutely positioned to 0,0.\n    // TODO: replace by getComputedStyle('padding')\n\n    var absolutePositioningOffset = {\n      horizontal: context.rtl ? offsetMeasureBoundingRect.right - overflowContainerBoundingRect.right : overflowContainerBoundingRect.left - offsetMeasureBoundingRect.left,\n      vertical: overflowContainerBoundingRect.top - offsetMeasureBoundingRect.top\n    };\n    var isOverflowing = false;\n    var $lastVisibleItem;\n    var lastVisibleItemRect; // check all items from the last one back\n\n    _forEachRight($items, function ($item, i) {\n      if ($item === $overflowItem) {\n        return true;\n      }\n\n      var itemBoundingRect = $item.getBoundingClientRect(); // if the item is out of the crop rectangle, hide it\n\n      if (isItemOverflowing(itemBoundingRect, overflowContainerBoundingRect)) {\n        isOverflowing = true; // console.log('Overflow', i, {\n        //   item: [itemBoundingRect.left, itemBoundingRect.right],\n        //   crop: [\n        //     overflowContainerBoundingRect.left,\n        //     overflowContainerBoundingRect.right,\n        //     overflowContainerBoundingRect.width,\n        //   ],\n        //   container: $overflowContainer,\n        // })\n\n        hide($item);\n        return true;\n      } // if there is an overflow, check collision of remaining items with eventual overflow position\n\n\n      if (isOverflowing && !$lastVisibleItem && wouldItemCollide($item, itemBoundingRect, overflowItemBoundingRect, overflowContainerBoundingRect)) {\n        hide($item);\n        return true;\n      } // Remember the last visible item\n\n\n      if (!$lastVisibleItem) {\n        $lastVisibleItem = $item;\n        lastVisibleItemRect = itemBoundingRect;\n        lastVisibleItemIndex.current = i;\n      }\n\n      return show($item); // exit the loop when first visible item is found\n    }); // if there is an overflow,  position and show overflow item, otherwise hide it\n\n\n    if (isOverflowing || overflowOpen) {\n      $overflowItem.style.position = 'absolute';\n      setOverflowPosition($overflowItem, $lastVisibleItem, lastVisibleItemRect, overflowContainerBoundingRect, absolutePositioningOffset);\n      show($overflowItem);\n    } else {\n      lastVisibleItemIndex.current = items.length - 1;\n      hide($overflowItem);\n    }\n\n    _invoke(props, 'onOverflow', lastVisibleItemIndex.current + 1);\n  };\n\n  var collectOverflowItems = function collectOverflowItems() {\n    // console.log('getOverflowItems()', items.slice(lastVisibleItemIndex.current + 1))\n    return getOverflowItems ? getOverflowItems(lastVisibleItemIndex.current + 1) : items.slice(lastVisibleItemIndex.current + 1);\n  };\n\n  var getVisibleItems = function getVisibleItems() {\n    // console.log('allItems()', items)\n    var end = overflowOpen ? lastVisibleItemIndex.current + 1 : items.length; // console.log('getVisibleItems()', items.slice(0, end))\n\n    return items.slice(0, end);\n  };\n\n  var handleWindowResize = _debounce(function (e) {\n    hideOverflowItems();\n\n    if (overflowOpen) {\n      _invoke(props, 'onOverflowOpenChange', e, Object.assign({}, props, {\n        overflowOpen: false\n      }));\n    }\n  }, 16);\n\n  var renderItems = function renderItems(items) {\n    return _map(items, function (item) {\n      var kind = _get(item, 'kind', 'item');\n\n      switch (kind) {\n        case 'divider':\n          return ToolbarDivider.create(item);\n\n        case 'group':\n          return ToolbarRadioGroup.create(item);\n\n        case 'toggle':\n          return ToolbarItem.create(item, {\n            defaultProps: function defaultProps() {\n              return {\n                accessibility: toggleButtonBehavior\n              };\n            }\n          });\n\n        case 'custom':\n          return ToolbarCustomItem.create(item);\n\n        default:\n          return ToolbarItem.create(item);\n      }\n    });\n  };\n\n  var renderOverflowItem = function renderOverflowItem(overflowItem) {\n    return React.createElement(Ref, {\n      innerRef: overflowItemRef\n    }, ToolbarItem.create(overflowItem, {\n      defaultProps: function defaultProps() {\n        return {\n          icon: React.createElement(MoreIcon, {\n            outline: true\n          })\n        };\n      },\n      overrideProps: {\n        menu: {\n          items: overflowOpen ? collectOverflowItems() : [],\n          popper: {\n            positionFixed: true\n          }\n        },\n        menuOpen: overflowOpen,\n        onMenuOpenChange: function onMenuOpenChange(e, _ref) {\n          var menuOpen = _ref.menuOpen;\n\n          _invoke(props, 'onOverflowOpenChange', e, Object.assign({}, props, {\n            overflowOpen: menuOpen\n          }));\n        }\n      }\n    }));\n  };\n\n  React.useEffect(function () {\n    var actualWindow = context.target.defaultView;\n    actualWindow.cancelAnimationFrame(animationFrameId.current); // Heads up! There are cases (like opening a portal and rendering the Toolbar there immediately) when rAF is necessary\n\n    animationFrameId.current = actualWindow.requestAnimationFrame(function () {\n      hideOverflowItems();\n    });\n    return function () {\n      if (animationFrameId.current !== undefined) {\n        context.target.defaultView.cancelAnimationFrame(animationFrameId.current);\n        animationFrameId.current = undefined;\n      }\n    };\n  });\n  var element = overflow ? React.createElement(React.Fragment, null, React.createElement(Ref, {\n    innerRef: containerRef\n  }, getA11Props.unstable_wrapWithFocusZone(React.createElement(ElementType, getA11Props('root', Object.assign({\n    className: classes.root\n  }, unhandledProps)), React.createElement(\"div\", {\n    className: classes.overflowContainer,\n    ref: overflowContainerRef\n  }, React.createElement(ToolbarVariablesProvider, {\n    value: variables\n  }, childrenExist(children) ? children : renderItems(getVisibleItems()), renderOverflowItem(overflowItem))), React.createElement(\"div\", {\n    className: classes.offsetMeasure,\n    ref: offsetMeasureRef\n  })))), React.createElement(EventListener, {\n    listener: handleWindowResize,\n    target: context.target.defaultView,\n    type: \"resize\"\n  })) : React.createElement(Ref, {\n    innerRef: containerRef\n  }, getA11Props.unstable_wrapWithFocusZone(React.createElement(ElementType, getA11Props('root', Object.assign({\n    className: classes.root\n  }, unhandledProps)), React.createElement(ToolbarVariablesProvider, {\n    value: variables\n  }, childrenExist(children) ? children : renderItems(items)))));\n  setEnd();\n  return element;\n};\n\nToolbar.displayName = 'Toolbar';\nToolbar.propTypes = Object.assign({}, commonPropTypes.createCommon(), {\n  items: customPropTypes.collectionShorthandWithKindProp(['divider', 'item', 'group', 'toggle', 'custom']),\n  overflow: PropTypes.bool,\n  overflowOpen: PropTypes.bool,\n  overflowItem: customPropTypes.shorthandAllowingChildren,\n  onOverflow: PropTypes.func,\n  onOverflowOpenChange: PropTypes.func,\n  getOverflowItems: PropTypes.func\n});\nToolbar.defaultProps = {\n  accessibility: toolbarBehavior,\n  items: [],\n  overflowItem: {}\n};\nToolbar.handledProps = Object.keys(Toolbar.propTypes);\nToolbar.CustomItem = ToolbarCustomItem;\nToolbar.Divider = ToolbarDivider;\nToolbar.Item = ToolbarItem;\nToolbar.Menu = ToolbarMenu;\nToolbar.MenuDivider = ToolbarMenuDivider;\nToolbar.MenuItem = ToolbarMenuItem;\nToolbar.MenuRadioGroup = ToolbarMenuRadioGroup;\nToolbar.RadioGroup = ToolbarRadioGroup;\nToolbar.create = createShorthandFactory({\n  Component: Toolbar,\n  mappedProp: 'content'\n});\n/**\n * A Toolbar is a container for grouping a set of controls, often action controls (e.g. buttons) or input controls (e.g. checkboxes).\n *\n * @accessibility\n *  * Implements [ARIA Toolbar](https://www.w3.org/TR/wai-aria-practices-1.1/#toolbar) design pattern.\n * @accessibilityIssues\n * [Issue 988424: VoiceOver narrates selected for button in toolbar](https://bugs.chromium.org/p/chromium/issues/detail?id=988424)\n */\n\nexport default withSafeTypeForAs(Toolbar);","map":{"version":3,"sources":["components/Toolbar/Toolbar.tsx"],"names":["WAS_FOCUSABLE_ATTRIBUTE","toolbarClassName","Toolbar","context","React","setStart","setEnd","useTelemetry","accessibility","className","children","design","getOverflowItems","items","overflow","overflowItem","overflowOpen","styles","variables","props","overflowContainerRef","overflowItemRef","offsetMeasureRef","containerRef","lastVisibleItemIndex","animationFrameId","getA11Props","useAccessibility","debugName","rtl","classes","useStyles","mapPropsToInlineStyles","ElementType","getElementType","unhandledProps","useUnhandledProps","hide","el","firstFocusableItem","getFirstFocusable","wasFocusable","show","isItemOverflowing","itemBoundingRect","containerBoundingRect","wouldItemCollide","actualWindow","itemLeftMargin","parseFloat","wouldCollide","overflowItemBoundingRect","itemRightMargin","setOverflowPosition","lastVisibleItemMarginLeft","$overflowItem","lastVisibleItemRect","absolutePositioningOffset","lastVisibleItemRightMargin","hideOverflowItems","$overflowContainer","$offsetMeasure","Number","$items","overflowContainerBoundingRect","offsetMeasureBoundingRect","horizontal","vertical","top","isOverflowing","$item","$lastVisibleItem","collectOverflowItems","getVisibleItems","end","handleWindowResize","renderItems","kind","ToolbarDivider","ToolbarRadioGroup","defaultProps","toggleButtonBehavior","ToolbarCustomItem","ToolbarItem","renderOverflowItem","icon","overrideProps","menu","popper","positionFixed","menuOpen","onMenuOpenChange","element","root","childrenExist","commonPropTypes","customPropTypes","PropTypes","onOverflow","onOverflowOpenChange","func","Object","createShorthandFactory","Component","mappedProp","withSafeTypeForAs"],"mappings":"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","sourcesContent":["import {\n  Accessibility,\n  toolbarBehavior,\n  ToolbarBehaviorProps,\n  toggleButtonBehavior,\n  IS_FOCUSABLE_ATTRIBUTE,\n} from '@fluentui/accessibility';\nimport {\n  getElementType,\n  getFirstFocusable,\n  useAccessibility,\n  useStyles,\n  useTelemetry,\n  useUnhandledProps,\n} from '@fluentui/react-bindings';\nimport { EventListener } from '@fluentui/react-component-event-listener';\nimport { Ref } from '@fluentui/react-component-ref';\nimport { MoreIcon } from '@fluentui/react-icons-northstar';\nimport * as customPropTypes from '@fluentui/react-proptypes';\nimport * as _ from 'lodash';\nimport * as PropTypes from 'prop-types';\nimport * as React from 'react';\n// @ts-ignore\nimport { ThemeContext } from 'react-fela';\n\nimport {\n  ComponentEventHandler,\n  FluentComponentStaticProps,\n  ProviderContextPrepared,\n  ShorthandCollection,\n  ShorthandValue,\n  WithAsProp,\n  withSafeTypeForAs,\n} from '../../types';\nimport {\n  childrenExist,\n  createShorthandFactory,\n  UIComponentProps,\n  ContentComponentProps,\n  ChildrenComponentProps,\n  commonPropTypes,\n  ColorComponentProps,\n} from '../../utils';\nimport ToolbarCustomItem from './ToolbarCustomItem';\nimport ToolbarDivider from './ToolbarDivider';\nimport ToolbarItem, { ToolbarItemProps } from './ToolbarItem';\nimport ToolbarMenu from './ToolbarMenu';\nimport ToolbarMenuDivider from './ToolbarMenuDivider';\nimport ToolbarMenuItem, { ToolbarMenuItemProps } from './ToolbarMenuItem';\nimport ToolbarMenuRadioGroup from './ToolbarMenuRadioGroup';\nimport ToolbarRadioGroup from './ToolbarRadioGroup';\nimport { ToolbarVariablesProvider } from './toolbarVariablesContext';\n\nexport type ToolbarItemShorthandKinds = 'divider' | 'item' | 'group' | 'toggle' | 'custom';\n\ntype PositionOffset = {\n  vertical: number;\n  horizontal: number;\n};\n\nconst WAS_FOCUSABLE_ATTRIBUTE = 'data-was-focusable';\n\nexport interface ToolbarProps\n  extends UIComponentProps,\n    ContentComponentProps,\n    ChildrenComponentProps,\n    ColorComponentProps {\n  /** Accessibility behavior if overridden by the user. */\n  accessibility?: Accessibility<ToolbarBehaviorProps>;\n\n  /** Shorthand array of props for Toolbar. */\n  items?: ShorthandCollection<ToolbarItemProps, ToolbarItemShorthandKinds>;\n\n  /**\n   *  Automatically move overflow items to overflow menu.\n   *  For automatic overflow to work correctly, toolbar items including overflowMenuItem\n   *  must NOT change their size! If you need to change item's size, rerender the Toolbar.\n   */\n  overflow?: boolean;\n\n  /** Indicates if the overflow menu is open. Only valid if `overflow` is enabled and regular items do not fit. */\n  overflowOpen?: boolean;\n\n  /**\n   * Shorthand for the overflow item which is displayed when `overflow` is enabled and regular toolbar items do not fit.\n   * Do not set any menu on this item, Toolbar overrides it.\n   */\n  overflowItem?: ShorthandValue<ToolbarItemProps>;\n\n  /**\n   * Called when overflow is recomputed (after render, update or window resize). Even if all items fit.\n   * @param itemsVisible - number of items visible\n   */\n  onOverflow?: (itemsVisible: number) => void;\n\n  /**\n   * Event for request to change 'overflowOpen' value.\n   * @param event - React's original SyntheticEvent.\n   * @param data - All props and proposed value.\n   */\n  onOverflowOpenChange?: ComponentEventHandler<ToolbarProps>;\n\n  /**\n   * Callback to get items to be rendered in overflow menu.\n   * Called when overflow menu is rendered opened.\n   * @param startIndex - Index of the first item to be displayed in the overflow menu (the first item which does not fit the toolbar).\n   */\n  getOverflowItems?: (startIndex: number) => ShorthandCollection<ToolbarMenuItemProps, ToolbarItemShorthandKinds>; // FIXME: use correct kind\n}\n\nexport type ToolbarStylesProps = never;\n\nexport const toolbarClassName = 'ui-toolbar';\n\nconst Toolbar: React.FC<WithAsProp<ToolbarProps>> &\n  FluentComponentStaticProps<ToolbarProps> & {\n    CustomItem: typeof ToolbarCustomItem;\n    Divider: typeof ToolbarDivider;\n    Item: typeof ToolbarItem;\n    Menu: typeof ToolbarMenu;\n    MenuDivider: typeof ToolbarMenuDivider;\n    MenuItem: typeof ToolbarMenuItem;\n    MenuRadioGroup: typeof ToolbarMenuRadioGroup;\n    RadioGroup: typeof ToolbarRadioGroup;\n  } = props => {\n  const context: ProviderContextPrepared = React.useContext(ThemeContext);\n  const { setStart, setEnd } = useTelemetry(Toolbar.displayName, context.telemetry);\n  setStart();\n\n  const {\n    accessibility,\n    className,\n    children,\n    design,\n    getOverflowItems,\n    items,\n    overflow,\n    overflowItem,\n    overflowOpen,\n    styles,\n    variables,\n  } = props;\n\n  const overflowContainerRef = React.useRef<HTMLDivElement>();\n  const overflowItemRef = React.useRef<HTMLElement>();\n  const offsetMeasureRef = React.useRef<HTMLDivElement>();\n  const containerRef = React.useRef<HTMLElement>();\n\n  // index of the last visible item in Toolbar, the rest goes to overflow menu\n  const lastVisibleItemIndex = React.useRef<number>();\n  const animationFrameId = React.useRef<number>();\n\n  const getA11Props = useAccessibility(accessibility, {\n    debugName: Toolbar.displayName,\n    rtl: context.rtl,\n  });\n  const { classes } = useStyles<ToolbarStylesProps>(Toolbar.displayName, {\n    className: toolbarClassName,\n    mapPropsToInlineStyles: () => ({\n      className,\n      design,\n      styles,\n      variables,\n    }),\n    rtl: context.rtl,\n  });\n\n  const ElementType = getElementType(props);\n  const unhandledProps = useUnhandledProps(Toolbar.handledProps, props);\n\n  const hide = (el: HTMLElement) => {\n    if (el.style.visibility === 'hidden') {\n      return;\n    }\n\n    if (context.target.activeElement === el || el.contains(context.target.activeElement)) {\n      if (containerRef.current) {\n        const firstFocusableItem = getFirstFocusable(\n          containerRef.current,\n          containerRef.current.firstElementChild as HTMLElement,\n        );\n\n        if (firstFocusableItem) {\n          firstFocusableItem.focus();\n        }\n      }\n    }\n\n    el.style.visibility = 'hidden';\n    const wasFocusable = el.getAttribute(IS_FOCUSABLE_ATTRIBUTE);\n    if (wasFocusable) {\n      el.setAttribute(WAS_FOCUSABLE_ATTRIBUTE, wasFocusable);\n    }\n    el.setAttribute(IS_FOCUSABLE_ATTRIBUTE, 'false');\n  };\n\n  const show = (el: HTMLElement) => {\n    if (el.style.visibility !== 'hidden') {\n      return false;\n    }\n\n    el.style.visibility = null;\n    const wasFocusable = el.getAttribute(WAS_FOCUSABLE_ATTRIBUTE);\n    if (wasFocusable) {\n      el.setAttribute(IS_FOCUSABLE_ATTRIBUTE, wasFocusable);\n      el.removeAttribute(WAS_FOCUSABLE_ATTRIBUTE);\n    } else {\n      el.removeAttribute(IS_FOCUSABLE_ATTRIBUTE);\n    }\n\n    return true;\n  };\n\n  /**\n   * Checks if `item` overflows a `container`.\n   * TODO: check and fix all margin combination\n   */\n  const isItemOverflowing = (itemBoundingRect: ClientRect, containerBoundingRect: ClientRect) => {\n    return itemBoundingRect.right > containerBoundingRect.right || itemBoundingRect.left < containerBoundingRect.left;\n  };\n\n  /**\n   * Checks if `item` would collide with eventual position of `overflowItem`.\n   */\n  const wouldItemCollide = (\n    $item: Element,\n    itemBoundingRect: ClientRect,\n    overflowItemBoundingRect: ClientRect,\n    containerBoundingRect: ClientRect,\n  ) => {\n    const actualWindow: Window = context.target.defaultView;\n    let wouldCollide;\n\n    if (context.rtl) {\n      const itemLeftMargin = parseFloat(actualWindow.getComputedStyle($item).marginLeft) || 0;\n      wouldCollide =\n        itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin < containerBoundingRect.left;\n\n      // console.log('Collision [RTL]', {\n      //   wouldCollide,\n      //   'itemBoundingRect.left': itemBoundingRect.left,\n      //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,\n      //   itemRightMargin: itemLeftMargin,\n      //   sum: itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin,\n      //   'overflowContainerBoundingRect.left': containerBoundingRect.left,\n      // })\n    } else {\n      const itemRightMargin = parseFloat(actualWindow.getComputedStyle($item).marginRight) || 0;\n      wouldCollide =\n        itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin > containerBoundingRect.right;\n\n      // console.log('Collision', {\n      //   wouldCollide,\n      //   'itemBoundingRect.right': itemBoundingRect.right,\n      //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,\n      //   itemRightMargin,\n      //   sum: itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin,\n      //   'overflowContainerBoundingRect.right': containerBoundingRect.right,\n      // })\n    }\n\n    return wouldCollide;\n  };\n\n  /**\n   * Positions overflowItem next to lastVisible item\n   * TODO: consider overflowItem margin\n   */\n  const setOverflowPosition = (\n    $overflowItem: HTMLElement,\n    $lastVisibleItem: HTMLElement | undefined,\n    lastVisibleItemRect: ClientRect | undefined,\n    containerBoundingRect: ClientRect,\n    absolutePositioningOffset: PositionOffset,\n  ) => {\n    const actualWindow: Window = context.target.defaultView;\n\n    if ($lastVisibleItem) {\n      if (context.rtl) {\n        const lastVisibleItemMarginLeft = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginLeft) || 0;\n\n        $overflowItem.style.right = `${containerBoundingRect.right -\n          lastVisibleItemRect.left +\n          lastVisibleItemMarginLeft +\n          absolutePositioningOffset.horizontal}px`;\n      } else {\n        const lastVisibleItemRightMargin = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginRight) || 0;\n\n        $overflowItem.style.left = `${lastVisibleItemRect.right -\n          containerBoundingRect.left +\n          lastVisibleItemRightMargin +\n          absolutePositioningOffset.horizontal}px`;\n      }\n    } else {\n      // there is no last visible item -> position the overflow as the first item\n      lastVisibleItemIndex.current = -1;\n      if (context.rtl) {\n        $overflowItem.style.right = `${absolutePositioningOffset.horizontal}px`;\n      } else {\n        $overflowItem.style.left = `${absolutePositioningOffset.horizontal}px`;\n      }\n    }\n  };\n\n  const hideOverflowItems = () => {\n    const $overflowContainer = overflowContainerRef.current;\n    const $overflowItem = overflowItemRef.current;\n    const $offsetMeasure = offsetMeasureRef.current;\n    if (!$overflowContainer || !$overflowItem || !$offsetMeasure) {\n      return;\n    }\n\n    // workaround: when resizing window with popup opened the container contents scroll for some reason\n    if (context.rtl) {\n      $overflowContainer.scrollTo(Number.MAX_SAFE_INTEGER, 0);\n    } else {\n      $overflowContainer.scrollTo(0, 0);\n    }\n\n    const $items = $overflowContainer.children;\n\n    const overflowContainerBoundingRect = $overflowContainer.getBoundingClientRect();\n    const overflowItemBoundingRect = $overflowItem.getBoundingClientRect();\n    const offsetMeasureBoundingRect = $offsetMeasure.getBoundingClientRect();\n\n    // Absolute positioning offset\n    // Overflow menu is absolutely positioned relative to root slot\n    // If there is padding set on the root slot boundingClientRect computations use inner content box,\n    // but absolute position is relative to root slot's PADDING box.\n    // We compute absolute positioning offset\n    // By measuring position of an offsetMeasure element absolutely positioned to 0,0.\n    // TODO: replace by getComputedStyle('padding')\n    const absolutePositioningOffset: PositionOffset = {\n      horizontal: context.rtl\n        ? offsetMeasureBoundingRect.right - overflowContainerBoundingRect.right\n        : overflowContainerBoundingRect.left - offsetMeasureBoundingRect.left,\n      vertical: overflowContainerBoundingRect.top - offsetMeasureBoundingRect.top,\n    };\n\n    let isOverflowing = false;\n    let $lastVisibleItem;\n    let lastVisibleItemRect;\n\n    // check all items from the last one back\n    _.forEachRight($items, ($item: HTMLElement, i: number) => {\n      if ($item === $overflowItem) {\n        return true;\n      }\n\n      const itemBoundingRect = $item.getBoundingClientRect();\n\n      // if the item is out of the crop rectangle, hide it\n      if (isItemOverflowing(itemBoundingRect, overflowContainerBoundingRect)) {\n        isOverflowing = true;\n        // console.log('Overflow', i, {\n        //   item: [itemBoundingRect.left, itemBoundingRect.right],\n        //   crop: [\n        //     overflowContainerBoundingRect.left,\n        //     overflowContainerBoundingRect.right,\n        //     overflowContainerBoundingRect.width,\n        //   ],\n        //   container: $overflowContainer,\n        // })\n        hide($item);\n        return true;\n      }\n\n      // if there is an overflow, check collision of remaining items with eventual overflow position\n      if (\n        isOverflowing &&\n        !$lastVisibleItem &&\n        wouldItemCollide($item, itemBoundingRect, overflowItemBoundingRect, overflowContainerBoundingRect)\n      ) {\n        hide($item);\n        return true;\n      }\n\n      // Remember the last visible item\n      if (!$lastVisibleItem) {\n        $lastVisibleItem = $item;\n        lastVisibleItemRect = itemBoundingRect;\n        lastVisibleItemIndex.current = i;\n      }\n\n      return show($item); // exit the loop when first visible item is found\n    });\n\n    // if there is an overflow,  position and show overflow item, otherwise hide it\n    if (isOverflowing || overflowOpen) {\n      $overflowItem.style.position = 'absolute';\n      setOverflowPosition(\n        $overflowItem,\n        $lastVisibleItem,\n        lastVisibleItemRect,\n        overflowContainerBoundingRect,\n        absolutePositioningOffset,\n      );\n      show($overflowItem);\n    } else {\n      lastVisibleItemIndex.current = items.length - 1;\n      hide($overflowItem);\n    }\n\n    _.invoke(props, 'onOverflow', lastVisibleItemIndex.current + 1);\n  };\n\n  const collectOverflowItems = () => {\n    // console.log('getOverflowItems()', items.slice(lastVisibleItemIndex.current + 1))\n    return getOverflowItems\n      ? getOverflowItems(lastVisibleItemIndex.current + 1)\n      : items.slice(lastVisibleItemIndex.current + 1);\n  };\n\n  const getVisibleItems = () => {\n    // console.log('allItems()', items)\n    const end = overflowOpen ? lastVisibleItemIndex.current + 1 : items.length;\n    // console.log('getVisibleItems()', items.slice(0, end))\n    return items.slice(0, end);\n  };\n\n  const handleWindowResize = _.debounce((e: UIEvent) => {\n    hideOverflowItems();\n\n    if (overflowOpen) {\n      _.invoke(props, 'onOverflowOpenChange', e, { ...props, overflowOpen: false });\n    }\n  }, 16);\n\n  const renderItems = (items: ShorthandCollection<ToolbarItemProps, ToolbarItemShorthandKinds>) =>\n    _.map(items, (item: ShorthandValue<ToolbarItemProps & { kind?: ToolbarItemShorthandKinds }>) => {\n      const kind = _.get(item, 'kind', 'item');\n\n      switch (kind) {\n        case 'divider':\n          return ToolbarDivider.create(item);\n        case 'group':\n          return ToolbarRadioGroup.create(item);\n        case 'toggle':\n          return ToolbarItem.create(item, {\n            defaultProps: () => ({ accessibility: toggleButtonBehavior }),\n          });\n        case 'custom':\n          return ToolbarCustomItem.create(item);\n        default:\n          return ToolbarItem.create(item);\n      }\n    });\n\n  const renderOverflowItem = overflowItem => {\n    return (\n      <Ref innerRef={overflowItemRef}>\n        {ToolbarItem.create(overflowItem, {\n          defaultProps: () => ({\n            icon: <MoreIcon outline />,\n          }),\n          overrideProps: {\n            menu: { items: overflowOpen ? collectOverflowItems() : [], popper: { positionFixed: true } },\n            menuOpen: overflowOpen,\n            onMenuOpenChange: (e, { menuOpen }) => {\n              _.invoke(props, 'onOverflowOpenChange', e, { ...props, overflowOpen: menuOpen });\n            },\n          },\n        })}\n      </Ref>\n    );\n  };\n\n  React.useEffect(() => {\n    const actualWindow: Window = context.target.defaultView;\n\n    actualWindow.cancelAnimationFrame(animationFrameId.current);\n    // Heads up! There are cases (like opening a portal and rendering the Toolbar there immediately) when rAF is necessary\n    animationFrameId.current = actualWindow.requestAnimationFrame(() => {\n      hideOverflowItems();\n    });\n\n    return () => {\n      if (animationFrameId.current !== undefined) {\n        context.target.defaultView.cancelAnimationFrame(animationFrameId.current);\n        animationFrameId.current = undefined;\n      }\n    };\n  });\n\n  const element = overflow ? (\n    <>\n      <Ref innerRef={containerRef}>\n        {getA11Props.unstable_wrapWithFocusZone(\n          <ElementType {...getA11Props('root', { className: classes.root, ...unhandledProps })}>\n            <div className={classes.overflowContainer} ref={overflowContainerRef}>\n              <ToolbarVariablesProvider value={variables}>\n                {childrenExist(children) ? children : renderItems(getVisibleItems())}\n                {renderOverflowItem(overflowItem)}\n              </ToolbarVariablesProvider>\n            </div>\n            <div className={classes.offsetMeasure} ref={offsetMeasureRef} />\n          </ElementType>,\n        )}\n      </Ref>\n      <EventListener listener={handleWindowResize} target={context.target.defaultView} type=\"resize\" />\n    </>\n  ) : (\n    <Ref innerRef={containerRef}>\n      {getA11Props.unstable_wrapWithFocusZone(\n        <ElementType {...getA11Props('root', { className: classes.root, ...unhandledProps })}>\n          <ToolbarVariablesProvider value={variables}>\n            {childrenExist(children) ? children : renderItems(items)}\n          </ToolbarVariablesProvider>\n        </ElementType>,\n      )}\n    </Ref>\n  );\n  setEnd();\n\n  return element;\n};\n\nToolbar.displayName = 'Toolbar';\n\nToolbar.propTypes = {\n  ...commonPropTypes.createCommon(),\n  items: customPropTypes.collectionShorthandWithKindProp(['divider', 'item', 'group', 'toggle', 'custom']),\n  overflow: PropTypes.bool,\n  overflowOpen: PropTypes.bool,\n  overflowItem: customPropTypes.shorthandAllowingChildren,\n  onOverflow: PropTypes.func,\n  onOverflowOpenChange: PropTypes.func,\n  getOverflowItems: PropTypes.func,\n};\nToolbar.defaultProps = {\n  accessibility: toolbarBehavior,\n  items: [],\n  overflowItem: {},\n};\nToolbar.handledProps = Object.keys(Toolbar.propTypes) as any;\n\nToolbar.CustomItem = ToolbarCustomItem;\nToolbar.Divider = ToolbarDivider;\nToolbar.Item = ToolbarItem;\nToolbar.Menu = ToolbarMenu;\nToolbar.MenuDivider = ToolbarMenuDivider;\nToolbar.MenuItem = ToolbarMenuItem;\nToolbar.MenuRadioGroup = ToolbarMenuRadioGroup;\nToolbar.RadioGroup = ToolbarRadioGroup;\n\nToolbar.create = createShorthandFactory({ Component: Toolbar, mappedProp: 'content' });\n\n/**\n * A Toolbar is a container for grouping a set of controls, often action controls (e.g. buttons) or input controls (e.g. checkboxes).\n *\n * @accessibility\n *  * Implements [ARIA Toolbar](https://www.w3.org/TR/wai-aria-practices-1.1/#toolbar) design pattern.\n * @accessibilityIssues\n * [Issue 988424: VoiceOver narrates selected for button in toolbar](https://bugs.chromium.org/p/chromium/issues/detail?id=988424)\n */\nexport default withSafeTypeForAs<typeof Toolbar, ToolbarProps>(Toolbar);\n"]},"metadata":{},"sourceType":"module"}