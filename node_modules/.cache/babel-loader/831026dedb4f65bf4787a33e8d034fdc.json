{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _isEqual from \"lodash/isEqual\";\nimport { useIsomorphicLayoutEffect } from '@fluentui/react-bindings';\nimport { Ref, isRefObject } from '@fluentui/react-component-ref';\nimport * as PopperJs from '@popperjs/core';\nimport * as React from 'react';\nimport isBrowser from '../isBrowser';\nimport getBoundary from './getBoundary';\nimport getScrollParent from './getScrollParent';\nimport { getPlacement, applyRtlToOffset } from './positioningHelper';\n/**\n * Memoize a result using deep equality. This hook has two advantages over\n * React.useMemo: it uses deep equality to compare memo keys, and it guarantees\n * that the memo function will only be called if the keys are unequal.\n * React.useMemo cannot be relied on to do this, since it is only a performance\n * optimization (see https://reactjs.org/docs/hooks-reference.html#usememo).\n *\n * Copied from https://github.com/apollographql/react-apollo/blob/master/packages/hooks/src/utils/useDeepMemo.ts.\n */\n\nfunction useDeepMemo(memoFn, key) {\n  var ref = React.useRef();\n\n  if (!ref.current || !_isEqual(key, ref.current.key)) {\n    ref.current = {\n      key: key,\n      value: memoFn()\n    };\n  }\n\n  return ref.current.value;\n}\n/**\n * Popper relies on the 3rd party library [Popper.js](https://github.com/FezVrasta/popper.js) for positioning.\n */\n\n\nvar Popper = function Popper(props) {\n  var align = props.align,\n      children = props.children,\n      enabled = props.enabled,\n      flipBoundary = props.flipBoundary,\n      userModifiers = props.modifiers,\n      offset = props.offset,\n      overflowBoundary = props.overflowBoundary,\n      pointerTargetRef = props.pointerTargetRef,\n      position = props.position,\n      positionFixed = props.positionFixed,\n      _props$positioningDep = props.positioningDependencies,\n      positioningDependencies = _props$positioningDep === void 0 ? [] : _props$positioningDep,\n      rtl = props.rtl,\n      targetRef = props.targetRef,\n      unstable_pinned = props.unstable_pinned;\n  var proposedPlacement = getPlacement({\n    align: align,\n    position: position,\n    rtl: rtl\n  });\n  var popperRef = React.useRef();\n  var contentRef = React.useRef(null);\n  var latestPlacement = React.useRef(proposedPlacement);\n\n  var _React$useState = React.useState(proposedPlacement),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      computedPlacement = _React$useState2[0],\n      setComputedPlacement = _React$useState2[1];\n\n  var computedModifiers = useDeepMemo(function () {\n    return [offset && {\n      name: 'offset',\n      options: {\n        offset: rtl ? applyRtlToOffset(offset) : offset\n      }\n    }].concat(_toConsumableArray(userModifiers));\n  }, [offset, flipBoundary, overflowBoundary, userModifiers]);\n  var createInstance = React.useCallback(function () {\n    var reference = targetRef && isRefObject(targetRef) ? targetRef.current : targetRef;\n\n    if (!enabled || !reference || !contentRef.current) {\n      return;\n    }\n\n    var handleUpdate = function handleUpdate(_ref) {\n      var state = _ref.state; // PopperJS performs computations that might update the computed placement: auto positioning, flipping the\n      // placement in case the popper box should be rendered at the edge of the viewport and does not fit\n\n      if (state.placement !== latestPlacement.current) {\n        latestPlacement.current = state.placement;\n        setComputedPlacement(state.placement);\n      }\n    };\n\n    var hasDocument = isBrowser();\n    var scrollParentElement = hasDocument ? getScrollParent(contentRef.current) : null;\n    var hasScrollableElement = scrollParentElement ? scrollParentElement !== scrollParentElement.ownerDocument.body : false;\n    var hasPointer = !!(pointerTargetRef && pointerTargetRef.current);\n    var modifiers = [{\n      name: 'flip',\n      options: {\n        flipVariations: true\n      }\n    },\n    /**\n     * unstable_pinned disables the flip modifier by setting flip.enabled to false; this\n     * disables automatic repositioning of the popper box; it will always be placed according to\n     * the values of `align` and `position` props, regardless of the size of the component, the\n     * reference element or the viewport.\n     */\n    unstable_pinned && {\n      name: 'flip',\n      enabled: false\n    },\n    /**\n     * When the popper box is placed in the context of a scrollable element, we need to set\n     * preventOverflow.escapeWithReference to true and flip.boundariesElement to 'scrollParent'\n     * (default is 'viewport') so that the popper box will stick with the targetRef when we\n     * scroll targetRef out of the viewport.\n     */\n    hasScrollableElement && {\n      name: 'flip',\n      options: {\n        boundary: 'clippingParents'\n      }\n    }, hasScrollableElement && {\n      name: 'preventOverflow',\n      options: {\n        boundary: 'clippingParents'\n      }\n    }];\n    var options = {\n      placement: proposedPlacement,\n      strategy: positionFixed ? 'fixed' : 'absolute',\n      modifiers: [].concat(_toConsumableArray(modifiers), _toConsumableArray(computedModifiers), [\n      /**\n       * This modifier is necessary in order to render the pointer. Refs are resolved in effects, so it can't be\n       * placed under computed modifiers. Deep merge is not required as this modifier has only these properties.\n       */\n      {\n        name: 'arrow',\n        enabled: hasPointer,\n        options: {\n          element: pointerTargetRef && pointerTargetRef.current\n        }\n      }, flipBoundary && {\n        name: 'flip',\n        options: {\n          altBoundary: true,\n          boundary: getBoundary(contentRef.current, flipBoundary)\n        }\n      }, overflowBoundary && {\n        name: 'preventOverflow',\n        options: {\n          altBoundary: true,\n          boundary: getBoundary(contentRef.current, overflowBoundary)\n        }\n      }, {\n        name: 'onUpdate',\n        enabled: true,\n        phase: 'afterWrite',\n        fn: handleUpdate\n      }]).filter(Boolean),\n      onFirstUpdate: function onFirstUpdate(state) {\n        return handleUpdate({\n          state: state\n        });\n      }\n    };\n    popperRef.current = PopperJs.createPopper(reference, contentRef.current, options);\n  }, [contentRef, computedModifiers, enabled, pointerTargetRef, positionFixed, proposedPlacement, targetRef]);\n  var destroyInstance = React.useCallback(function () {\n    if (popperRef.current) {\n      popperRef.current.destroy();\n      popperRef.current = null;\n    }\n  }, []);\n  var scheduleUpdate = React.useCallback(function () {\n    if (popperRef.current) {\n      popperRef.current.update();\n    }\n  }, []);\n  useIsomorphicLayoutEffect(function () {\n    createInstance();\n    return destroyInstance;\n  }, [createInstance]);\n  React.useEffect(scheduleUpdate, [].concat(_toConsumableArray(positioningDependencies), [computedPlacement]));\n  var child = typeof children === 'function' ? children({\n    placement: computedPlacement,\n    scheduleUpdate: scheduleUpdate\n  }) : children;\n  return child ? React.createElement(Ref, {\n    innerRef: contentRef\n  }, React.Children.only(child)) : null;\n};\n\nPopper.defaultProps = {\n  enabled: true,\n  modifiers: [],\n  positionFixed: false,\n  positioningDependencies: []\n};\nexport default Popper;","map":{"version":3,"sources":["utils/positioner/Popper.tsx"],"names":["ref","React","key","value","memoFn","Popper","align","children","enabled","flipBoundary","userModifiers","offset","overflowBoundary","pointerTargetRef","position","positionFixed","positioningDependencies","rtl","targetRef","unstable_pinned","props","proposedPlacement","getPlacement","popperRef","contentRef","latestPlacement","computedPlacement","setComputedPlacement","computedModifiers","useDeepMemo","name","options","applyRtlToOffset","createInstance","reference","isRefObject","handleUpdate","state","hasDocument","isBrowser","scrollParentElement","getScrollParent","hasScrollableElement","hasPointer","modifiers","flipVariations","boundary","placement","strategy","element","current","altBoundary","getBoundary","phase","fn","onFirstUpdate","PopperJs","destroyInstance","scheduleUpdate","useIsomorphicLayoutEffect","child"],"mappings":"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","sourcesContent":["import { useIsomorphicLayoutEffect } from '@fluentui/react-bindings';\nimport { Ref, isRefObject } from '@fluentui/react-component-ref';\nimport * as PopperJs from '@popperjs/core';\nimport * as _ from 'lodash';\nimport * as React from 'react';\n\nimport isBrowser from '../isBrowser';\nimport getBoundary from './getBoundary';\nimport getScrollParent from './getScrollParent';\nimport { getPlacement, applyRtlToOffset } from './positioningHelper';\nimport { PopperModifiers, PopperProps } from './types';\n\n/**\n * Memoize a result using deep equality. This hook has two advantages over\n * React.useMemo: it uses deep equality to compare memo keys, and it guarantees\n * that the memo function will only be called if the keys are unequal.\n * React.useMemo cannot be relied on to do this, since it is only a performance\n * optimization (see https://reactjs.org/docs/hooks-reference.html#usememo).\n *\n * Copied from https://github.com/apollographql/react-apollo/blob/master/packages/hooks/src/utils/useDeepMemo.ts.\n */\nfunction useDeepMemo<TKey, TValue>(memoFn: () => TValue, key: TKey): TValue {\n  const ref = React.useRef<{ key: TKey; value: TValue }>();\n\n  if (!ref.current || !_.isEqual(key, ref.current.key)) {\n    ref.current = { key, value: memoFn() };\n  }\n\n  return ref.current.value;\n}\n\n/**\n * Popper relies on the 3rd party library [Popper.js](https://github.com/FezVrasta/popper.js) for positioning.\n */\nconst Popper: React.FunctionComponent<PopperProps> = props => {\n  const {\n    align,\n    children,\n    enabled,\n    flipBoundary,\n    modifiers: userModifiers,\n    offset,\n    overflowBoundary,\n    pointerTargetRef,\n    position,\n    positionFixed,\n    positioningDependencies = [],\n    rtl,\n    targetRef,\n    unstable_pinned,\n  } = props;\n\n  const proposedPlacement = getPlacement({ align, position, rtl });\n\n  const popperRef = React.useRef<PopperJs.Instance>();\n  const contentRef = React.useRef<HTMLElement>(null);\n\n  const latestPlacement = React.useRef<PopperJs.Placement>(proposedPlacement);\n  const [computedPlacement, setComputedPlacement] = React.useState<PopperJs.Placement>(proposedPlacement);\n\n  const computedModifiers = useDeepMemo<any, PopperModifiers>(\n    () => [\n      offset && {\n        name: 'offset',\n        options: { offset: rtl ? applyRtlToOffset(offset) : offset },\n      },\n      ...userModifiers,\n    ],\n    [offset, flipBoundary, overflowBoundary, userModifiers],\n  );\n\n  const createInstance = React.useCallback(() => {\n    const reference: Element | PopperJs.VirtualElement =\n      targetRef && isRefObject(targetRef)\n        ? (targetRef as React.RefObject<Element>).current\n        : (targetRef as PopperJs.VirtualElement);\n\n    if (!enabled || !reference || !contentRef.current) {\n      return;\n    }\n\n    const handleUpdate = ({ state }: { state: Partial<PopperJs.State> }) => {\n      // PopperJS performs computations that might update the computed placement: auto positioning, flipping the\n      // placement in case the popper box should be rendered at the edge of the viewport and does not fit\n      if (state.placement !== latestPlacement.current) {\n        latestPlacement.current = state.placement;\n        setComputedPlacement(state.placement);\n      }\n    };\n\n    const hasDocument = isBrowser();\n    const scrollParentElement: Node | null = hasDocument ? getScrollParent(contentRef.current) : null;\n\n    const hasScrollableElement = scrollParentElement\n      ? scrollParentElement !== scrollParentElement.ownerDocument.body\n      : false;\n    const hasPointer = !!(pointerTargetRef && pointerTargetRef.current);\n\n    const modifiers: PopperModifiers = [\n      { name: 'flip', options: { flipVariations: true } },\n\n      /**\n       * unstable_pinned disables the flip modifier by setting flip.enabled to false; this\n       * disables automatic repositioning of the popper box; it will always be placed according to\n       * the values of `align` and `position` props, regardless of the size of the component, the\n       * reference element or the viewport.\n       */\n      unstable_pinned && { name: 'flip', enabled: false },\n\n      /**\n       * When the popper box is placed in the context of a scrollable element, we need to set\n       * preventOverflow.escapeWithReference to true and flip.boundariesElement to 'scrollParent'\n       * (default is 'viewport') so that the popper box will stick with the targetRef when we\n       * scroll targetRef out of the viewport.\n       */\n      hasScrollableElement && { name: 'flip', options: { boundary: 'clippingParents' } },\n      hasScrollableElement && { name: 'preventOverflow', options: { boundary: 'clippingParents' } },\n    ];\n\n    const options: PopperJs.Options = {\n      placement: proposedPlacement,\n      strategy: positionFixed ? 'fixed' : 'absolute',\n      modifiers: [\n        ...(modifiers as PopperJs.Options['modifiers']),\n\n        ...computedModifiers,\n\n        /**\n         * This modifier is necessary in order to render the pointer. Refs are resolved in effects, so it can't be\n         * placed under computed modifiers. Deep merge is not required as this modifier has only these properties.\n         */\n        {\n          name: 'arrow',\n          enabled: hasPointer,\n          options: {\n            element: pointerTargetRef && pointerTargetRef.current,\n          },\n        },\n\n        flipBoundary && {\n          name: 'flip',\n          options: {\n            altBoundary: true,\n            boundary: getBoundary(contentRef.current, flipBoundary),\n          },\n        },\n        overflowBoundary && {\n          name: 'preventOverflow',\n          options: {\n            altBoundary: true,\n            boundary: getBoundary(contentRef.current, overflowBoundary),\n          },\n        },\n\n        {\n          name: 'onUpdate',\n          enabled: true,\n          phase: 'afterWrite' as PopperJs.ModifierPhases,\n          fn: handleUpdate,\n        },\n      ].filter(Boolean),\n      onFirstUpdate: state => handleUpdate({ state }),\n    };\n\n    popperRef.current = PopperJs.createPopper(reference, contentRef.current, options);\n  }, [contentRef, computedModifiers, enabled, pointerTargetRef, positionFixed, proposedPlacement, targetRef]);\n\n  const destroyInstance = React.useCallback(() => {\n    if (popperRef.current) {\n      popperRef.current.destroy();\n      popperRef.current = null;\n    }\n  }, []);\n\n  const scheduleUpdate = React.useCallback(() => {\n    if (popperRef.current) {\n      popperRef.current.update();\n    }\n  }, []);\n\n  useIsomorphicLayoutEffect(() => {\n    createInstance();\n    return destroyInstance;\n  }, [createInstance]);\n\n  React.useEffect(scheduleUpdate, [...positioningDependencies, computedPlacement]);\n\n  const child =\n    typeof children === 'function'\n      ? children({ placement: computedPlacement, scheduleUpdate })\n      : (children as React.ReactElement);\n\n  return child ? <Ref innerRef={contentRef}>{React.Children.only(child)}</Ref> : null;\n};\n\nPopper.defaultProps = {\n  enabled: true,\n  modifiers: [],\n  positionFixed: false,\n  positioningDependencies: [],\n};\n\nexport default Popper;\n"]},"metadata":{},"sourceType":"module"}