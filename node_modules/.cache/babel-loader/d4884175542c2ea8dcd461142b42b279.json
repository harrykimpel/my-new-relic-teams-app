{"ast":null,"code":"import { __assign, __extends, __rest } from \"tslib\";\nimport * as React from 'react';\nimport { concatStyleSetsWithProps } from '@uifabric/merge-styles';\nimport { Customizations } from './customizations/Customizations';\nimport { CustomizerContext } from './customizations/CustomizerContext';\nvar DefaultFields = ['theme', 'styles'];\n/**\n * The styled HOC wrapper allows you to create a functional wrapper around a given component which will resolve\n * getStyles functional props, and mix customized props passed in using concatStyleSets.\n *\n * @example\n * ```tsx\n * export const Toggle = styled(\n *   ToggleBase,\n *   props => ({ root: { background: 'red' }})\n * );\n * ```\n * @param Component - The unstyled base component to render, which receives styles.\n * @param baseStyles - The styles which should be curried with the component.\n * @param getProps - A helper which provides default props.\n * @param customizable - An object which defines which props can be customized using the Customizer.\n * @param pure - A boolean indicating if the component should avoid re-rendering when props haven't changed.\n * Note that pure should not be used on components which allow children, or take in complex objects or\n * arrays as props which could mutate on every render.\n */\n\nexport function styled(Component, baseStyles, getProps, customizable, pure) {\n  customizable = customizable || {\n    scope: '',\n    fields: undefined\n  };\n  var scope = customizable.scope,\n      _a = customizable.fields,\n      fields = _a === void 0 ? DefaultFields : _a;\n  var ParentComponent = pure ? React.PureComponent : React.Component;\n\n  var Wrapped =\n  /** @class */\n  function (_super) {\n    __extends(Wrapped, _super);\n\n    function Wrapped() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n\n      _this._inCustomizerContext = false;\n\n      _this._renderContent = function (context) {\n        _this._inCustomizerContext = !!context.customizations.inCustomizerContext;\n        var settings = Customizations.getSettings(fields, scope, context.customizations);\n\n        var customizedStyles = settings.styles,\n            dir = settings.dir,\n            rest = __rest(settings, [\"styles\", \"dir\"]);\n\n        var additionalProps = getProps ? getProps(_this.props) : undefined;\n\n        _this._updateStyles(customizedStyles);\n\n        return React.createElement(Component, __assign({}, rest, additionalProps, _this.props, {\n          styles: _this._styles\n        }));\n      };\n\n      _this._onSettingsChanged = function () {\n        return _this.forceUpdate();\n      };\n\n      return _this;\n    }\n\n    Wrapped.prototype.render = function () {\n      return React.createElement(CustomizerContext.Consumer, null, this._renderContent);\n    };\n\n    Wrapped.prototype.componentDidMount = function () {\n      if (!this._inCustomizerContext) {\n        Customizations.observe(this._onSettingsChanged);\n      }\n    };\n\n    Wrapped.prototype.componentWillUnmount = function () {\n      if (!this._inCustomizerContext) {\n        Customizations.unobserve(this._onSettingsChanged);\n      }\n    };\n\n    Wrapped.prototype._updateStyles = function (customizedStyles) {\n      var _this = this; // tslint:disable-next-line:no-any\n\n\n      var cache = this._styles && this._styles.__cachedInputs__ || [];\n\n      if (!this._styles || customizedStyles !== cache[1] || this.props.styles !== cache[2]) {\n        // Cache the customized styles.\n        // this._customizedStyles = customizedStyles;\n        // Using styled components as the Component arg will result in nested styling arrays.\n        var concatenatedStyles = function concatenatedStyles(styleProps) {\n          return concatStyleSetsWithProps(styleProps, baseStyles, customizedStyles, _this.props.styles);\n        }; // The __cachedInputs__ array is attached to the function and consumed by the\n        // classNamesFunction as a list of keys to include for memoizing classnames.\n\n\n        concatenatedStyles.__cachedInputs__ = [baseStyles, customizedStyles, this.props.styles];\n        concatenatedStyles.__noStyleOverride__ = !customizedStyles && !this.props.styles;\n        this._styles = concatenatedStyles;\n      }\n    }; // Function.prototype.name is an ES6 feature, so the cast to any is required until we're\n    // able to drop IE 11 support and compile with ES6 libs\n    // tslint:disable-next-line:no-any\n\n\n    Wrapped.displayName = \"Styled\" + (Component.displayName || Component.name);\n    return Wrapped;\n  }(ParentComponent); // This preserves backwards compatibility.\n  // tslint:disable-next-line:no-any\n\n\n  return Wrapped;\n}","map":{"version":3,"sources":["styled.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { IStyleSet, IStyleFunctionOrObject, concatStyleSetsWithProps } from '@uifabric/merge-styles';\nimport { Customizations } from './customizations/Customizations';\nimport { CustomizerContext, ICustomizerContext } from './customizations/CustomizerContext';\n\nexport interface IPropsWithStyles<TStyleProps, TStyleSet extends IStyleSet<TStyleSet>> {\n  styles?: IStyleFunctionOrObject<TStyleProps, TStyleSet>;\n}\n\nexport interface ICustomizableProps {\n  /**\n   * Name of scope, which can be targeted using the Customizer.\n   */\n  scope: string;\n\n  /**\n   * List of fields which can be customized.\n   * @defaultvalue [ 'theme', 'styles' ]\n   */\n  fields?: string[];\n}\n\nconst DefaultFields = ['theme', 'styles'];\n\nexport type StyleFunction<TStyleProps, TStyleSet> = IStyleFunctionOrObject<TStyleProps, TStyleSet> & {\n  /** Cache for all style functions. */\n  __cachedInputs__: (IStyleFunctionOrObject<TStyleProps, TStyleSet> | undefined)[];\n\n  /** True if no styles prop or styles from Customizer is passed to wrapped component. */\n  __noStyleOverride__: boolean;\n};\n\n/**\n * The styled HOC wrapper allows you to create a functional wrapper around a given component which will resolve\n * getStyles functional props, and mix customized props passed in using concatStyleSets.\n *\n * @example\n * ```tsx\n * export const Toggle = styled(\n *   ToggleBase,\n *   props => ({ root: { background: 'red' }})\n * );\n * ```\n * @param Component - The unstyled base component to render, which receives styles.\n * @param baseStyles - The styles which should be curried with the component.\n * @param getProps - A helper which provides default props.\n * @param customizable - An object which defines which props can be customized using the Customizer.\n * @param pure - A boolean indicating if the component should avoid re-rendering when props haven't changed.\n * Note that pure should not be used on components which allow children, or take in complex objects or\n * arrays as props which could mutate on every render.\n */\nexport function styled<\n  TComponentProps extends IPropsWithStyles<TStyleProps, TStyleSet>,\n  TStyleProps,\n  TStyleSet extends IStyleSet<TStyleSet>\n>(\n  Component: React.ComponentClass<TComponentProps> | React.FunctionComponent<TComponentProps>,\n  baseStyles: IStyleFunctionOrObject<TStyleProps, TStyleSet>,\n  getProps?: (props: TComponentProps) => Partial<TComponentProps>,\n  customizable?: ICustomizableProps,\n  pure?: boolean,\n): React.FunctionComponent<TComponentProps> {\n  customizable = customizable || { scope: '', fields: undefined };\n\n  const { scope, fields = DefaultFields } = customizable;\n  const ParentComponent = pure ? React.PureComponent : React.Component;\n\n  class Wrapped extends ParentComponent<TComponentProps, {}> {\n    // Function.prototype.name is an ES6 feature, so the cast to any is required until we're\n    // able to drop IE 11 support and compile with ES6 libs\n    // tslint:disable-next-line:no-any\n    public static displayName = `Styled${Component.displayName || (Component as any).name}`;\n\n    private _inCustomizerContext = false;\n    private _styles: StyleFunction<TStyleProps, TStyleSet>;\n\n    public render(): JSX.Element {\n      return <CustomizerContext.Consumer>{this._renderContent}</CustomizerContext.Consumer>;\n    }\n\n    public componentDidMount(): void {\n      if (!this._inCustomizerContext) {\n        Customizations.observe(this._onSettingsChanged);\n      }\n    }\n\n    public componentWillUnmount(): void {\n      if (!this._inCustomizerContext) {\n        Customizations.unobserve(this._onSettingsChanged);\n      }\n    }\n\n    private _renderContent = (context: ICustomizerContext): JSX.Element => {\n      this._inCustomizerContext = !!context.customizations.inCustomizerContext;\n\n      const settings = Customizations.getSettings(fields, scope, context.customizations);\n      const { styles: customizedStyles, dir, ...rest } = settings;\n      const additionalProps = getProps ? getProps(this.props) : undefined;\n\n      this._updateStyles(customizedStyles);\n\n      return <Component {...rest} {...additionalProps} {...this.props} styles={this._styles} />;\n    };\n\n    private _updateStyles(customizedStyles: IStyleFunctionOrObject<TStyleProps, TStyleSet>): void {\n      // tslint:disable-next-line:no-any\n      const cache = (this._styles && (this._styles as any).__cachedInputs__) || [];\n      if (!this._styles || customizedStyles !== cache[1] || this.props.styles !== cache[2]) {\n        // Cache the customized styles.\n        // this._customizedStyles = customizedStyles;\n\n        // Using styled components as the Component arg will result in nested styling arrays.\n        const concatenatedStyles: IStyleFunctionOrObject<TStyleProps, TStyleSet> = (styleProps: TStyleProps) =>\n          concatStyleSetsWithProps(styleProps, baseStyles, customizedStyles, this.props.styles);\n\n        // The __cachedInputs__ array is attached to the function and consumed by the\n        // classNamesFunction as a list of keys to include for memoizing classnames.\n        (concatenatedStyles as StyleFunction<TStyleProps, TStyleSet>).__cachedInputs__ = [\n          baseStyles,\n          customizedStyles,\n          this.props.styles,\n        ];\n\n        (concatenatedStyles as StyleFunction<TStyleProps, TStyleSet>).__noStyleOverride__ =\n          !customizedStyles && !this.props.styles;\n\n        this._styles = concatenatedStyles as StyleFunction<TStyleProps, TStyleSet>;\n      }\n    }\n\n    private _onSettingsChanged = (): void => this.forceUpdate();\n  }\n\n  // This preserves backwards compatibility.\n  // tslint:disable-next-line:no-any\n  return Wrapped as any;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}