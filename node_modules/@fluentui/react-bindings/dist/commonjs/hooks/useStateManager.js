"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var React = _interopRequireWildcard(require("react"));

var getDefinedProps = function getDefinedProps(props) {
  var definedProps = {};
  Object.keys(props).forEach(function (propName) {
    if (props[propName] !== undefined) {
      definedProps[propName] = props[propName];
    }
  });
  return definedProps;
};

var useStateManager = function useStateManager(managerFactory) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _options$mapPropsToIn = options.mapPropsToInitialState,
      mapPropsToInitialState = _options$mapPropsToIn === void 0 ? function () {
    return {};
  } : _options$mapPropsToIn,
      _options$mapPropsToSt = options.mapPropsToState,
      mapPropsToState = _options$mapPropsToSt === void 0 ? function () {
    return {};
  } : _options$mapPropsToSt,
      _options$sideEffects = options.sideEffects,
      sideEffects = _options$sideEffects === void 0 ? [] : _options$sideEffects;
  var latestActions = React.useMemo(function () {
    return {};
  }, [managerFactory]);
  var latestManager = React.useRef(null); // Heads up! forceUpdate() is used only for triggering rerenders, stateManager is SSOT

  var _ref = React.useReducer(function (c) {
    return c + 1;
  }, 0),
      _ref2 = (0, _slicedToArray2.default)(_ref, 2),
      forceUpdate = _ref2[1]; // If manager exists, the current state will be used


  var initialState = latestManager.current ? latestManager.current.state : getDefinedProps(mapPropsToInitialState());
  latestManager.current = managerFactory({
    // Factory has already configured actions
    actions: {},
    state: Object.assign({}, initialState, {}, getDefinedProps(mapPropsToState())),
    sideEffects: [].concat((0, _toConsumableArray2.default)(sideEffects), [// `sideEffect` is called with two arguments, but hooks don't support the second callback
    // argument
    function () {
      return forceUpdate();
    }])
  }); // We need to keep the same reference to an object with actions to allow usage them as
  // a dependency in useCallback() hook

  Object.assign(latestActions, latestManager.current.actions); // For development environments we disallow ability to extend object with other properties to
  // avoid misusage

  if (process.env.NODE_ENV !== 'production') {
    if (Object.isExtensible(latestActions)) Object.preventExtensions(latestActions);
  } // We need to pass exactly `manager.state` to provide the same state object during the same render
  // frame.
  // It keeps behavior consistency between React state tools and our managers
  // https://github.com/facebook/react/issues/11527#issuecomment-360199710
  // Object.freeze() is used only in dev-mode to avoid usage mistakes


  return {
    state: process.env.NODE_ENV === 'production' ? latestManager.current.state : Object.freeze(latestManager.current.state),
    actions: latestActions
  };
};

var _default = useStateManager;
exports.default = _default;
//# sourceMappingURL=useStateManager.js.map
