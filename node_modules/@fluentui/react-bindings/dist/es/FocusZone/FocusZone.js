import _extends from "@babel/runtime/helpers/esm/extends";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _invoke from "lodash/invoke";
import _keys from "lodash/keys";
import _uniqueId from "lodash/uniqueId";
import { FocusZoneDirection, FocusZoneTabbableElements, IS_FOCUSABLE_ATTRIBUTE } from '@fluentui/accessibility';
import * as React from 'react';
import cx from 'classnames';
// @ts-ignore
import * as keyboardKey from 'keyboard-key';
import * as ReactDOM from 'react-dom';
import * as PropTypes from 'prop-types';
import { elementContains, findScrollableParent, getDocument as _getDocument, getParent, getWindow, shouldWrapFocus as _shouldWrapFocus } from '@uifabric/utilities';
import getElementType from '../utils/getElementType';
import getUnhandledProps from '../utils/getUnhandledProps';
import { getNextElement, getPreviousElement, isElementFocusZone, isElementFocusSubZone, isElementTabbable, getElementIndexPath, getFocusableByIndexPath, FOCUSZONE_ID_ATTRIBUTE } from './focusUtilities';
var TABINDEX = 'tabindex';
var NO_VERTICAL_WRAP = 'data-no-vertical-wrap';
var NO_HORIZONTAL_WRAP = 'data-no-horizontal-wrap';
var LARGE_DISTANCE_FROM_CENTER = 999999999;
var LARGE_NEGATIVE_DISTANCE_FROM_CENTER = -999999999;
var _allInstances = {};

var _outerZones = new Set();

var ALLOWED_INPUT_TYPES = ['text', 'number', 'password', 'email', 'tel', 'url', 'search'];
var ALLOW_VIRTUAL_ELEMENTS = false;

var FocusZone =
/*#__PURE__*/
function (_React$Component) {
  _inherits(FocusZone, _React$Component);

  _createClass(FocusZone, null, [{
    key: "getOuterZones",

    /** Used for testing purposes only. */
    value: function getOuterZones() {
      return _outerZones.size;
    }
  }]);

  function FocusZone(props) {
    var _this;

    _classCallCheck(this, FocusZone);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(FocusZone).call(this, props));

    _defineProperty(_assertThisInitialized(_this), "_root", {
      current: null
    });

    _defineProperty(_assertThisInitialized(_this), "_id", void 0);

    _defineProperty(_assertThisInitialized(_this), "_activeElement", void 0);

    _defineProperty(_assertThisInitialized(_this), "_lastIndexPath", void 0);

    _defineProperty(_assertThisInitialized(_this), "_isParked", false);

    _defineProperty(_assertThisInitialized(_this), "_parkedTabIndex", void 0);

    _defineProperty(_assertThisInitialized(_this), "_defaultFocusElement", void 0);

    _defineProperty(_assertThisInitialized(_this), "_focusAlignment", void 0);

    _defineProperty(_assertThisInitialized(_this), "_isInnerZone", void 0);

    _defineProperty(_assertThisInitialized(_this), "_processingTabKey", void 0);

    _defineProperty(_assertThisInitialized(_this), "windowElement", void 0);

    _defineProperty(_assertThisInitialized(_this), "setRef", function (elem) {
      // findDOMNode needed to get correct DOM ref with react-hot-loader, see https://github.com/gaearon/react-hot-loader/issues/964
      _this._root.current = ReactDOM.findDOMNode(elem);
    });

    _defineProperty(_assertThisInitialized(_this), "_onBlur", function () {
      _this.setParkedFocus(false);
    });

    _defineProperty(_assertThisInitialized(_this), "_onFocus", function (ev) {
      var _this$props = _this.props,
          onActiveElementChanged = _this$props.onActiveElementChanged,
          stopFocusPropagation = _this$props.stopFocusPropagation,
          shouldFocusInnerElementWhenReceivedFocus = _this$props.shouldFocusInnerElementWhenReceivedFocus,
          defaultTabbableElement = _this$props.defaultTabbableElement;
      var newActiveElement;

      var isImmediateDescendant = _this.isImmediateDescendantOfZone(ev.target);

      if (isImmediateDescendant) {
        newActiveElement = ev.target;
      } else {
        var parentElement = ev.target;

        while (parentElement && parentElement !== _this._root.current) {
          if (isElementTabbable(parentElement) && _this.isImmediateDescendantOfZone(parentElement)) {
            newActiveElement = parentElement;
            break;
          }

          parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
        }
      } // If an inner focusable element should be focused when FocusZone container receives focus


      if (shouldFocusInnerElementWhenReceivedFocus && ev.target === _this._root.current) {
        var maybeElementToFocus = defaultTabbableElement && typeof defaultTabbableElement === 'function' && defaultTabbableElement(_this._root.current); // try to focus defaultTabbable element

        if (maybeElementToFocus && isElementTabbable(maybeElementToFocus)) {
          newActiveElement = maybeElementToFocus;
          maybeElementToFocus.focus();
        } else {
          // force focus on first focusable element
          _this.focus(true);

          if (_this._activeElement) {
            // set to null as new active element was handled in method above
            newActiveElement = null;
          }
        }
      }

      if (newActiveElement && newActiveElement !== _this._activeElement) {
        _this._activeElement = newActiveElement;

        if (isImmediateDescendant) {
          _this.setFocusAlignment(_this._activeElement);

          _this.updateTabIndexes();
        }
      }

      if (onActiveElementChanged) {
        onActiveElementChanged(_this._activeElement, ev);
      }

      if (stopFocusPropagation) {
        ev.stopPropagation();
      }

      _invoke(_this.props, 'onFocus', ev);
    });

    _defineProperty(_assertThisInitialized(_this), "_onKeyDownCapture", function (ev) {
      if (keyboardKey.getCode(ev) === keyboardKey.Tab) {
        _outerZones.forEach(function (zone) {
          return zone.updateTabIndexes();
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_onMouseDown", function (ev) {
      var disabled = _this.props.disabled;

      if (disabled) {
        return;
      }

      var target = ev.target;
      var path = [];

      while (target && target !== _this._root.current) {
        path.push(target);
        target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);
      }

      while (path.length) {
        target = path.pop();

        if (target && isElementTabbable(target)) {
          _this.setActiveElement(target, true);
        }

        if (isElementFocusZone(target)) {
          // Stop here since the focus zone will take care of its own children.
          break;
        }
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_onKeyDown", function (ev) {
      var _this$props2 = _this.props,
          direction = _this$props2.direction,
          disabled = _this$props2.disabled,
          shouldEnterInnerZone = _this$props2.shouldEnterInnerZone,
          pagingSupportDisabled = _this$props2.pagingSupportDisabled;

      if (disabled) {
        return undefined;
      }

      var doc = _getDocument(_this._root.current);

      if (_this.props.onKeyDown) {
        _this.props.onKeyDown(ev);
      } // @ts-ignore


      if (doc.activeElement === _this._root.current && _this._isInnerZone) {
        // If this element has focus, it is being controlled by a parent.
        // Ignore the keystroke.
        return undefined;
      } // If the default has been prevented, do not process keyboard events.


      if (ev.isDefaultPrevented()) {
        return undefined;
      }

      if (shouldEnterInnerZone && shouldEnterInnerZone(ev) && _this.isImmediateDescendantOfZone(ev.target)) {
        // Try to focus
        var innerZone = _this.getFirstInnerZone();

        if (innerZone) {
          if (!innerZone.focus(true)) {
            return undefined;
          }
        } else if (isElementFocusSubZone(ev.target)) {
          if (!_this.focusElement(getNextElement(ev.target, ev.target.firstChild, true))) {
            return undefined;
          }
        } else {
          return undefined;
        }
      } else if (ev.altKey) {
        return undefined;
      } else {
        switch (keyboardKey.getCode(ev)) {
          case keyboardKey.Spacebar:
            // @ts-ignore
            if (_this.tryInvokeClickForFocusable(ev.target)) {
              break;
            }

            return undefined;

          case keyboardKey.ArrowLeft:
            if (direction !== FocusZoneDirection.vertical) {
              _this.preventDefaultWhenHandled(ev);

              if (_this.moveFocusLeft()) {
                break;
              }
            }

            return undefined;

          case keyboardKey.ArrowRight:
            if (direction !== FocusZoneDirection.vertical) {
              _this.preventDefaultWhenHandled(ev);

              if (_this.moveFocusRight()) {
                break;
              }
            }

            return undefined;

          case keyboardKey.ArrowUp:
            if (direction !== FocusZoneDirection.horizontal) {
              _this.preventDefaultWhenHandled(ev);

              if (_this.moveFocusUp()) {
                break;
              }
            }

            return undefined;

          case keyboardKey.ArrowDown:
            if (direction !== FocusZoneDirection.horizontal) {
              _this.preventDefaultWhenHandled(ev);

              if (_this.moveFocusDown()) {
                break;
              }
            }

            return undefined;

          case keyboardKey.PageDown:
            if (!pagingSupportDisabled && _this.moveFocusPaging(true)) {
              break;
            }

            return undefined;

          case keyboardKey.PageUp:
            if (!pagingSupportDisabled && _this.moveFocusPaging(false)) {
              break;
            }

            return undefined;

          case keyboardKey.Tab:
            if (_this.props.handleTabKey === FocusZoneTabbableElements.all || _this.props.handleTabKey === FocusZoneTabbableElements.inputOnly && _this.isElementInput(ev.target)) {
              var focusChanged = false;
              _this._processingTabKey = true;

              if (direction === FocusZoneDirection.vertical || !_this.shouldWrapFocus(_this._activeElement, NO_HORIZONTAL_WRAP)) {
                focusChanged = ev.shiftKey ? _this.moveFocusUp() : _this.moveFocusDown();
              } else {
                var tabWithDirection = _this.props.isRtl ? !ev.shiftKey : ev.shiftKey;
                focusChanged = tabWithDirection ? _this.moveFocusLeft() : _this.moveFocusRight();
              }

              _this._processingTabKey = false;

              if (focusChanged) {
                break;
              }
            } else if (_this.props.shouldResetActiveElementWhenTabFromZone) {
              _this._activeElement = null;
            }

            return undefined;

          case keyboardKey.Home:
            if (_this.isContentEditableElement(ev.target) || _this.isElementInput(ev.target) && !_this.shouldInputLoseFocus(ev.target, false)) {
              return false;
            }

            var firstChild = _this._root.current && _this._root.current.firstChild;

            if (_this._root.current && firstChild && _this.focusElement(getNextElement(_this._root.current, firstChild, true))) {
              break;
            }

            return undefined;

          case keyboardKey.End:
            if (_this.isContentEditableElement(ev.target) || _this.isElementInput(ev.target) && !_this.shouldInputLoseFocus(ev.target, false)) {
              return false;
            }

            var lastChild = _this._root.current && _this._root.current.lastChild;

            if (_this._root.current && _this.focusElement(getPreviousElement(_this._root.current, lastChild, true, true, true))) {
              break;
            }

            return undefined;

          case keyboardKey.Enter:
            // @ts-ignore
            if (_this.tryInvokeClickForFocusable(ev.target)) {
              break;
            }

            return undefined;

          default:
            return undefined;
        }
      }

      ev.preventDefault();
      ev.stopPropagation();
      return undefined;
    });

    _defineProperty(_assertThisInitialized(_this), "getHorizontalDistanceFromCenter", function (isForward, activeRect, targetRect) {
      var leftAlignment = _this._focusAlignment.left; // ClientRect values can be floats that differ by very small fractions of a decimal.
      // If the difference between top and bottom are within a pixel then we should treat
      // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,
      // but without Math.Floor they will be handled incorrectly.

      var targetRectTop = Math.floor(targetRect.top);
      var activeRectBottom = Math.floor(activeRect.bottom);
      var targetRectBottom = Math.floor(targetRect.bottom);
      var activeRectTop = Math.floor(activeRect.top);
      var isValidCandidateOnpagingDown = isForward && targetRectTop > activeRectBottom;
      var isValidCandidateOnpagingUp = !isForward && targetRectBottom < activeRectTop;

      if (isValidCandidateOnpagingDown || isValidCandidateOnpagingUp) {
        if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
          return 0;
        }

        return Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
      }

      if (!_this.shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
        return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
      }

      return LARGE_DISTANCE_FROM_CENTER;
    });

    _this._id = _uniqueId('FocusZone');
    _this._focusAlignment = {
      left: 0,
      top: 0
    };
    _this._processingTabKey = false;
    return _this;
  }

  _createClass(FocusZone, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      _allInstances[this._id] = this;
      this.setRef(this); // called here to support functional components, we only need HTMLElement ref anyway

      if (!this._root.current) {
        return;
      } // @ts-ignore


      this.windowElement = getWindow(this._root.current);
      var parentElement = getParent(this._root.current, ALLOW_VIRTUAL_ELEMENTS);

      var doc = _getDocument(this._root.current); // @ts-ignore


      while (parentElement && parentElement !== doc.body && parentElement.nodeType === 1) {
        if (isElementFocusZone(parentElement)) {
          this._isInnerZone = true;
          break;
        }

        parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
      }

      if (!this._isInnerZone) {
        _outerZones.add(this);

        if (this.windowElement && _outerZones.size === 1) {
          this.windowElement.addEventListener('keydown', this._onKeyDownCapture, true);
        }
      }

      this._root.current.addEventListener('blur', this._onBlur, true); // Assign initial tab indexes so that we can set initial focus as appropriate.


      this.updateTabIndexes();

      if (this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === 'string') {
        this._activeElement = this.getDocument().querySelector(this.props.defaultTabbableElement);
      }

      if (this.props.shouldFocusOnMount) {
        this.focus();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      if (!this._root.current) {
        return;
      }

      var doc = _getDocument(this._root.current);

      if (doc && this._lastIndexPath && (doc.activeElement === doc.body || doc.activeElement === null || !this.props.preventFocusRestoration && doc.activeElement === this._root.current)) {
        // The element has been removed after the render, attempt to restore focus.
        var elementToFocus = getFocusableByIndexPath(this._root.current, this._lastIndexPath);

        if (elementToFocus) {
          this.setActiveElement(elementToFocus, true);
          elementToFocus.focus();
          this.setParkedFocus(false);
        } else {
          // We had a focus path to restore, but now that path is unresolvable. Park focus
          // on the container until we can try again.
          this.setParkedFocus(true);
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      delete _allInstances[this._id];

      if (!this._isInnerZone) {
        _outerZones.delete(this);

        if (this.windowElement && _outerZones.size === 0) {
          this.windowElement.removeEventListener('keydown', this._onKeyDownCapture, true);
        }
      }

      if (this._root.current) {
        this._root.current.removeEventListener('blur', this._onBlur, true);
      }

      this._activeElement = null;
      this._defaultFocusElement = null;
    }
  }, {
    key: "render",
    value: function render() {
      var className = this.props.className;
      var ElementType = getElementType(this.props);
      var unhandledProps = getUnhandledProps(_keys(FocusZone.propTypes), this.props); // Note, right before rendering/reconciling proceeds, we need to record if focus
      // was in the zone before the update. This helper will track this and, if focus
      // was actually in the zone, what the index path to the element is at this time.
      // Then, later in componentDidUpdate, we can evaluate if we need to restore it in
      // the case the element was removed.

      this.evaluateFocusBeforeRender();
      return React.createElement(ElementType, _extends({}, unhandledProps, {
        className: cx(FocusZone.className, className),
        "data-focuszone-id": this._id,
        onKeyDown: this._onKeyDown,
        onFocus: this._onFocus,
        onMouseDownCapture: this._onMouseDown
      }), this.props.children);
    }
    /**
     * Sets focus to the first tabbable item in the zone.
     * @param forceIntoFirstElement - If true, focus will be forced into the first element, even if focus is already in the focus zone.
     * @returns True if focus could be set to an active element, false if no operation was taken.
     */

  }, {
    key: "focus",
    value: function focus() {
      var forceIntoFirstElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this._root.current) {
        if (!forceIntoFirstElement && this._root.current.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' && this._isInnerZone) {
          var ownerZoneElement = this.getOwnerZone(this._root.current);

          if (ownerZoneElement !== this._root.current) {
            var ownerZone = _allInstances[ownerZoneElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];

            return !!ownerZone && ownerZone.focusElement(this._root.current);
          }

          return false;
        }

        if (!forceIntoFirstElement && this._activeElement && elementContains(this._root.current, this._activeElement, ALLOW_VIRTUAL_ELEMENTS) && isElementTabbable(this._activeElement)) {
          this._activeElement.focus();

          return true;
        }

        var firstChild = this._root.current.firstChild;
        return this.focusElement(getNextElement(this._root.current, firstChild, true));
      }

      return false;
    }
    /**
     * Sets focus to the last tabbable item in the zone.
     * @returns True if focus could be set to an active element, false if no operation was taken.
     */

  }, {
    key: "focusLast",
    value: function focusLast() {
      if (this._root.current) {
        var lastChild = this._root.current && this._root.current.lastChild;
        return this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true));
      }

      return false;
    }
    /**
     * Sets focus to a specific child element within the zone. This can be used in conjunction with
     * shouldReceiveFocus to create delayed focus scenarios (like animate the scroll position to the correct
     * location and then focus.)
     * @param element - The child element within the zone to focus.
     * @returns True if focus could be set to an active element, false if no operation was taken.
     */

  }, {
    key: "focusElement",
    value: function focusElement(element) {
      var shouldReceiveFocus = this.props.shouldReceiveFocus;

      if (shouldReceiveFocus && !shouldReceiveFocus(element)) {
        return false;
      }

      if (element) {
        this.setActiveElement(element);

        if (this._activeElement) {
          this._activeElement.focus();
        }

        return true;
      }

      return false;
    }
  }, {
    key: "evaluateFocusBeforeRender",
    // Record if focus was in the zone, what the index path to the element is at this time.
    value: function evaluateFocusBeforeRender() {
      if (!this._root.current) {
        return;
      }

      var doc = _getDocument(this._root.current);

      if (!doc) {
        return;
      }

      var focusedElement = doc.activeElement; // Only update the index path if we are not parked on the root.

      if (focusedElement !== this._root.current) {
        var shouldRestoreFocus = elementContains(this._root.current, focusedElement, ALLOW_VIRTUAL_ELEMENTS);
        this._lastIndexPath = shouldRestoreFocus ? getElementIndexPath(this._root.current, doc.activeElement) : undefined;
      }
    }
    /**
     * When focus is in the zone at render time but then all focusable elements are removed,
     * we "park" focus temporarily on the root. Once we update with focusable children, we restore
     * focus to the closest path from previous. If the user tabs away from the parked container,
     * we restore focusability to the pre-parked state.
     */

  }, {
    key: "setParkedFocus",
    value: function setParkedFocus(isParked) {
      if (this._root.current && this._isParked !== isParked) {
        this._isParked = isParked;

        if (isParked) {
          if (!this.props.allowFocusRoot) {
            this._parkedTabIndex = this._root.current.getAttribute('tabindex');

            this._root.current.setAttribute('tabindex', '-1');
          }

          this._root.current.focus();
        } else if (!this.props.allowFocusRoot) {
          if (this._parkedTabIndex) {
            this._root.current.setAttribute('tabindex', this._parkedTabIndex);

            this._parkedTabIndex = undefined;
          } else {
            this._root.current.removeAttribute('tabindex');
          }
        }
      }
    }
  }, {
    key: "setActiveElement",
    value: function setActiveElement(element, forceAlignemnt) {
      var previousActiveElement = this._activeElement;
      this._activeElement = element;

      if (previousActiveElement) {
        if (isElementFocusZone(previousActiveElement)) {
          this.updateTabIndexes(previousActiveElement);
        }

        previousActiveElement.tabIndex = -1;
      }

      if (this._activeElement) {
        if (!this._focusAlignment || forceAlignemnt) {
          this.setFocusAlignment(element, true, true);
        }

        this._activeElement.tabIndex = 0;
      }
    }
  }, {
    key: "preventDefaultWhenHandled",
    value: function preventDefaultWhenHandled(ev) {
      this.props.preventDefaultWhenHandled && ev.preventDefault();
    }
    /**
     * Handle the keystrokes.
     */

  }, {
    key: "tryInvokeClickForFocusable",

    /**
     * Walk up the dom try to find a focusable element.
     * TODO
     */
    value: function tryInvokeClickForFocusable() {
      return false;
    }
    /**
     * Traverse to find first child zone.
     */

  }, {
    key: "getFirstInnerZone",
    value: function getFirstInnerZone(forRootElement) {
      var rootElement = forRootElement || this._activeElement || this._root.current;

      if (!rootElement) {
        return null;
      }

      if (isElementFocusZone(rootElement)) {
        return _allInstances[rootElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
      }

      var child = rootElement.firstElementChild;

      while (child) {
        if (isElementFocusZone(child)) {
          return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
        }

        var match = this.getFirstInnerZone(child);

        if (match) {
          return match;
        }

        child = child.nextElementSibling;
      }

      return null;
    }
  }, {
    key: "moveFocus",
    value: function moveFocus(isForward, getDistanceFromCenter, // @ts-ignore
    ev) {
      var useDefaultWrap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var element = this._activeElement;
      var candidateDistance = -1;
      var candidateElement = undefined;
      var changedFocus = false;
      var isBidirectional = this.props.direction === FocusZoneDirection.bidirectional;

      if (!element || !this._root.current) {
        return false;
      }

      if (this.isElementInput(element)) {
        if (!this.shouldInputLoseFocus(element, isForward)) {
          return false;
        }
      }

      var activeRect = isBidirectional ? element.getBoundingClientRect() : null;

      do {
        element = isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element);

        if (isBidirectional) {
          if (element) {
            var _targetRect = element.getBoundingClientRect();

            var elementDistance = getDistanceFromCenter(activeRect, _targetRect);

            if (elementDistance === -1 && candidateDistance === -1) {
              candidateElement = element;
              break;
            }

            if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {
              candidateDistance = elementDistance;
              candidateElement = element;
            }

            if (candidateDistance >= 0 && elementDistance < 0) {
              break;
            }
          }
        } else {
          candidateElement = element;
          break;
        }
      } while (element); // Focus the closest candidate


      if (candidateElement && candidateElement !== this._activeElement) {
        changedFocus = true;
        this.focusElement(candidateElement);
      } else if (this.props.isCircularNavigation && useDefaultWrap) {
        if (isForward) {
          return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));
        }

        return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));
      }

      return changedFocus;
    }
  }, {
    key: "moveFocusDown",
    value: function moveFocusDown() {
      var _this2 = this;

      var targetTop = -1;
      var leftAlignment = this._focusAlignment.left;

      if (this.moveFocus(true, function (activeRect, targetRect) {
        var distance = -1; // ClientRect values can be floats that differ by very small fractions of a decimal.
        // If the difference between top and bottom are within a pixel then we should treat
        // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,
        // but without Math.Floor they will be handled incorrectly.

        var targetRectTop = Math.floor(targetRect.top);
        var activeRectBottom = Math.floor(activeRect.bottom);

        if (targetRectTop < activeRectBottom) {
          if (!_this2.shouldWrapFocus(_this2._activeElement, NO_VERTICAL_WRAP)) {
            return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
          }

          return LARGE_DISTANCE_FROM_CENTER;
        }

        if (targetTop === -1 && targetRectTop >= activeRectBottom || targetRectTop === targetTop) {
          targetTop = targetRectTop;

          if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
            distance = 0;
          } else {
            distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
          }
        }

        return distance;
      })) {
        this.setFocusAlignment(this._activeElement, true, true);
        return true;
      }

      return false;
    }
  }, {
    key: "moveFocusUp",
    value: function moveFocusUp() {
      var _this3 = this;

      var targetTop = -1;
      var leftAlignment = this._focusAlignment.left;

      if (this.moveFocus(false, function (activeRect, targetRect) {
        var distance = -1; // ClientRect values can be floats that differ by very small fractions of a decimal.
        // If the difference between top and bottom are within a pixel then we should treat
        // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,
        // but without Math.Floor they will be handled incorrectly.

        var targetRectBottom = Math.floor(targetRect.bottom);
        var targetRectTop = Math.floor(targetRect.top);
        var activeRectTop = Math.floor(activeRect.top);

        if (targetRectBottom > activeRectTop) {
          if (!_this3.shouldWrapFocus(_this3._activeElement, NO_VERTICAL_WRAP)) {
            return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
          }

          return LARGE_DISTANCE_FROM_CENTER;
        }

        if (targetTop === -1 && targetRectBottom <= activeRectTop || targetRectTop === targetTop) {
          targetTop = targetRectTop;

          if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
            distance = 0;
          } else {
            distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
          }
        }

        return distance;
      })) {
        this.setFocusAlignment(this._activeElement, true, true);
        return true;
      }

      return false;
    }
  }, {
    key: "moveFocusLeft",
    value: function moveFocusLeft() {
      var _this4 = this;

      var shouldWrap = this.shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);

      if (this.moveFocus( // @ts-ignore
      this.props.isRtl, function (activeRect, targetRect) {
        var distance = -1;
        var topBottomComparison;

        if (_this4.props.isRtl) {
          // When in RTL, this comparison should be the same as the one in moveFocusRight for LTR.
          // Going left at a leftmost rectangle will go down a line instead of up a line like in LTR.
          // This is important, because we want to be comparing the top of the target rect
          // with the bottom of the active rect.
          topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));
        } else {
          topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));
        }

        if (topBottomComparison && targetRect.right <= activeRect.right && _this4.props.direction !== FocusZoneDirection.vertical) {
          distance = activeRect.right - targetRect.right;
        } else if (!shouldWrap) {
          distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
        }

        return distance;
      }, undefined
      /* ev */
      , shouldWrap)) {
        this.setFocusAlignment(this._activeElement, true, false);
        return true;
      }

      return false;
    }
  }, {
    key: "moveFocusRight",
    value: function moveFocusRight() {
      var _this5 = this;

      var shouldWrap = this.shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);

      if (this.moveFocus(!this.props.isRtl, function (activeRect, targetRect) {
        var distance = -1;
        var topBottomComparison;

        if (_this5.props.isRtl) {
          // When in RTL, this comparison should be the same as the one in moveFocusLeft for LTR.
          // Going right at a rightmost rectangle will go up a line instead of down a line like in LTR.
          // This is important, because we want to be comparing the bottom of the target rect
          // with the top of the active rect.
          topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));
        } else {
          topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));
        }

        if (topBottomComparison && targetRect.left >= activeRect.left && _this5.props.direction !== FocusZoneDirection.vertical) {
          distance = targetRect.left - activeRect.left;
        } else if (!shouldWrap) {
          distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
        }

        return distance;
      }, undefined
      /* ev */
      , shouldWrap)) {
        this.setFocusAlignment(this._activeElement, true, false);
        return true;
      }

      return false;
    }
  }, {
    key: "moveFocusPaging",
    value: function moveFocusPaging(isForward) {
      var useDefaultWrap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var element = this._activeElement;

      if (!element || !this._root.current) {
        return false;
      }

      if (this.isElementInput(element)) {
        if (!this.shouldInputLoseFocus(element, isForward)) {
          return false;
        }
      }

      var scrollableParent = findScrollableParent(element);

      if (!scrollableParent) {
        return false;
      }

      var candidateDistance = -1;
      var candidateElement = undefined;
      var targetTop = -1;
      var targetBottom = -1;
      var pagesize = scrollableParent.clientHeight;
      var activeRect = element.getBoundingClientRect();

      do {
        element = isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element);

        if (element) {
          var _targetRect2 = element.getBoundingClientRect();

          var targetRectTop = Math.floor(_targetRect2.top);
          var activeRectBottom = Math.floor(activeRect.bottom);
          var targetRectBottom = Math.floor(_targetRect2.bottom);
          var activeRectTop = Math.floor(activeRect.top);
          var elementDistance = this.getHorizontalDistanceFromCenter(isForward, activeRect, _targetRect2);
          var isElementPassedPageSizeOnPagingDown = isForward && targetRectTop > activeRectBottom + pagesize;
          var isElementPassedPageSizeOnPagingUp = !isForward && targetRectBottom < activeRectTop - pagesize;

          if (isElementPassedPageSizeOnPagingDown || isElementPassedPageSizeOnPagingUp) {
            break;
          }

          if (elementDistance > -1) {
            // for paging down
            if (isForward && targetRectTop > targetTop) {
              targetTop = targetRectTop;
              candidateDistance = elementDistance;
              candidateElement = element;
            } else if (!isForward && targetRectBottom < targetBottom) {
              // for paging up
              targetBottom = targetRectBottom;
              candidateDistance = elementDistance;
              candidateElement = element;
            } else if (candidateDistance === -1 || elementDistance <= candidateDistance) {
              candidateDistance = elementDistance;
              candidateElement = element;
            }
          }
        }
      } while (element);

      var changedFocus = false; // Focus the closest candidate

      if (candidateElement && candidateElement !== this._activeElement) {
        changedFocus = true;
        this.focusElement(candidateElement);
        this.setFocusAlignment(candidateElement, false, true);
      } else if (this.props.isCircularNavigation && useDefaultWrap) {
        if (isForward) {
          return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));
        }

        return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));
      }

      return changedFocus;
    }
  }, {
    key: "setFocusAlignment",
    value: function setFocusAlignment(element, isHorizontal, isVertical) {
      if (this.props.direction === FocusZoneDirection.bidirectional && (!this._focusAlignment || isHorizontal || isVertical)) {
        var rect = element.getBoundingClientRect();
        var left = rect.left + rect.width / 2;
        var top = rect.top + rect.height / 2;

        if (!this._focusAlignment) {
          this._focusAlignment = {
            left: left,
            top: top
          };
        }

        if (isHorizontal) {
          this._focusAlignment.left = left;
        }

        if (isVertical) {
          this._focusAlignment.top = top;
        }
      }
    }
  }, {
    key: "isImmediateDescendantOfZone",
    value: function isImmediateDescendantOfZone(element) {
      return this.getOwnerZone(element) === this._root.current;
    }
  }, {
    key: "getOwnerZone",
    value: function getOwnerZone(element) {
      var doc = _getDocument(this._root.current);

      var parentElement = getParent(element, ALLOW_VIRTUAL_ELEMENTS); // @ts-ignore

      while (parentElement && parentElement !== this._root.current && parentElement !== doc.body) {
        if (isElementFocusZone(parentElement)) {
          return parentElement;
        }

        parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
      }

      return this._root.current;
    }
  }, {
    key: "updateTabIndexes",
    value: function updateTabIndexes(onElement) {
      var element = onElement;

      if (!this._activeElement && this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === 'function') {
        this._activeElement = this.props.defaultTabbableElement(this._root.current);
      }

      if (!element && this._root.current) {
        this._defaultFocusElement = null;
        element = this._root.current;

        if (this._activeElement && !elementContains(element, this._activeElement, ALLOW_VIRTUAL_ELEMENTS)) {
          this._activeElement = null;
        }
      } // If active element changes state to disabled, set it to null.
      // Otherwise, we lose keyboard accessibility to other elements in focus zone.


      if (this._activeElement && !isElementTabbable(this._activeElement)) {
        this._activeElement = null;
      }

      var childNodes = element && element.children;

      for (var childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {
        var child = childNodes[childIndex];

        if (!isElementFocusZone(child)) {
          // If the item is explicitly set to not be focusable then TABINDEX needs to be set to -1.
          if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'false') {
            child.setAttribute(TABINDEX, '-1');
          }

          if (isElementTabbable(child)) {
            if (this.props.disabled) {
              child.setAttribute(TABINDEX, '-1');
            } else if (!this._isInnerZone && (!this._activeElement && !this._defaultFocusElement || this._activeElement === child)) {
              this._defaultFocusElement = child;

              if (child.getAttribute(TABINDEX) !== '0') {
                child.setAttribute(TABINDEX, '0');
              }
            } else if (child.getAttribute(TABINDEX) !== '-1') {
              child.setAttribute(TABINDEX, '-1');
            }
          } else if (child.tagName === 'svg' && child.getAttribute('focusable') !== 'false') {
            // Disgusting IE hack. Sad face.
            child.setAttribute('focusable', 'false');
          }
        } else if (child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true') {
          if (!this._isInnerZone && (!this._activeElement && !this._defaultFocusElement || this._activeElement === child)) {
            this._defaultFocusElement = child;

            if (child.getAttribute(TABINDEX) !== '0') {
              child.setAttribute(TABINDEX, '0');
            }
          } else if (child.getAttribute(TABINDEX) !== '-1') {
            child.setAttribute(TABINDEX, '-1');
          }
        }

        this.updateTabIndexes(child);
      }
    }
  }, {
    key: "isContentEditableElement",
    value: function isContentEditableElement(element) {
      return element && element.getAttribute('contenteditable') === 'true';
    }
  }, {
    key: "isElementInput",
    value: function isElementInput(element) {
      if (element && element.tagName && (element.tagName.toLowerCase() === 'input' || element.tagName.toLowerCase() === 'textarea')) {
        return true;
      }

      return false;
    }
  }, {
    key: "shouldInputLoseFocus",
    value: function shouldInputLoseFocus(element, isForward) {
      // If a tab was used, we want to focus on the next element.
      if (!this._processingTabKey && element && element.type && ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1) {
        var selectionStart = element.selectionStart;
        var selectionEnd = element.selectionEnd;
        var isRangeSelected = selectionStart !== selectionEnd;
        var inputValue = element.value;
        var isReadonly = element.readOnly; // We shouldn't lose focus in the following cases:
        // 1. There is range selected.
        // 2. When selection start is larger than 0 and it is backward and not readOnly.
        // 3. when selection start is not the end of length and it is forward and not readOnly.
        // 4. We press any of the arrow keys when our handleTabKey isn't none or undefined (only losing focus if we hit tab)
        // and if shouldInputLoseFocusOnArrowKey is defined, if scenario prefers to not loose the focus which is determined by calling the
        // callback shouldInputLoseFocusOnArrowKey

        if (isRangeSelected || selectionStart > 0 && !isForward && !isReadonly || selectionStart !== inputValue.length && isForward && !isReadonly || !!this.props.handleTabKey && !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(element))) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "shouldWrapFocus",
    value: function shouldWrapFocus(element, noWrapDataAttribute) {
      return !!this.props.checkForNoWrap ? _shouldWrapFocus(element, noWrapDataAttribute) : true;
    }
  }, {
    key: "getDocument",
    value: function getDocument() {
      return _getDocument(this._root.current);
    }
  }]);

  return FocusZone;
}(React.Component);

_defineProperty(FocusZone, "propTypes", {
  className: PropTypes.string,
  direction: PropTypes.number,
  defaultTabbableElement: PropTypes.func,
  shouldFocusOnMount: PropTypes.bool,
  shouldResetActiveElementWhenTabFromZone: PropTypes.bool,
  shouldFocusInnerElementWhenReceivedFocus: PropTypes.bool,
  disabled: PropTypes.bool,
  as: PropTypes.elementType,
  isCircularNavigation: PropTypes.bool,
  shouldEnterInnerZone: PropTypes.func,
  onActiveElementChanged: PropTypes.func,
  shouldReceiveFocus: PropTypes.func,
  handleTabKey: PropTypes.number,
  shouldInputLoseFocusOnArrowKey: PropTypes.func,
  stopFocusPropagation: PropTypes.bool,
  onFocus: PropTypes.func,
  preventDefaultWhenHandled: PropTypes.bool,
  isRtl: PropTypes.bool,
  preventFocusRestoration: PropTypes.bool,
  pagingSupportDisabled: PropTypes.bool
});

_defineProperty(FocusZone, "defaultProps", {
  isCircularNavigation: false,
  direction: FocusZoneDirection.bidirectional,
  as: 'div',
  preventDefaultWhenHandled: true
});

_defineProperty(FocusZone, "displayName", 'FocusZone');

_defineProperty(FocusZone, "className", 'ms-FocusZone');

export { FocusZone as default };
//# sourceMappingURL=FocusZone.js.map
