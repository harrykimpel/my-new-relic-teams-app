import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _isPlainObject from "lodash/isPlainObject";
import cx from 'classnames';
import { isDebugEnabled, mergeComponentStyles, withDebugId } from '@fluentui/styles';
// this weak map is used as cache for the classes
var classesCache = new WeakMap(); // this weak map is used as cache for the styles

var stylesCache = new WeakMap();
/**
 * Both resolvedStyles and classes are objects of getters with lazy evaluation
 *
 * Additionally if the cacheEnabled option is provided, than the resolved styles
 * and classes are caching the results in WeakMaps. The key of the maps contains the following:
 * - theme
 * - displayName
 * - slot name
 * - styling props
 * - rtl mode
 * - disable animations mode
 */

var resolveStyles = function resolveStyles(options, resolvedVariables, renderStylesInput) {
  var componentClassName = options.className,
      theme = options.theme,
      displayNames = options.displayNames,
      props = options.props,
      rtl = options.rtl,
      disableAnimations = options.disableAnimations,
      renderer = options.renderer,
      performance = options.performance;

  var className = props.className,
      design = props.design,
      styles = props.styles,
      variables = props.variables,
      stylesProps = _objectWithoutProperties(props, ["className", "design", "styles", "variables"]);

  var noInlineStylesOverrides = !(design || styles);
  var noVariableOverrides = performance.enableBooleanVariablesCaching || !variables;
  /* istanbul ignore else */

  if (process.env.NODE_ENV !== 'production') {
    if (!performance.enableStylesCaching && performance.enableBooleanVariablesCaching) {
      throw new Error('@fluentui/react-northstar: Please check your "performance" settings on "Provider", to enable "enableBooleanVariablesCaching" you need to enable "enableStylesCaching"');
    }
  }

  if (performance.enableBooleanVariablesCaching) {
    if (_isPlainObject(variables)) {
      var hasOnlyBooleanVariables = Object.keys(variables).every(function (variableName) {
        return variables[variableName] === null || typeof variables[variableName] === 'undefined' || typeof variables[variableName] === 'boolean';
      });

      if (!hasOnlyBooleanVariables) {
        noVariableOverrides = false;
      }
    } else {
      noVariableOverrides = false;
    }
  }

  var cacheEnabled = performance.enableStylesCaching && noInlineStylesOverrides && noVariableOverrides; // Merge theme styles with inline overrides if any

  var mergedStyles;

  if (displayNames.length === 1) {
    mergedStyles = theme.componentStyles[displayNames[0]] || {
      root: function root() {
        return {};
      }
    };
  } else {
    var _styles = displayNames.map(function (displayName) {
      return theme.componentStyles[displayName];
    }).filter(Boolean);

    if (_styles.length > 0) {
      mergedStyles = mergeComponentStyles.apply(void 0, _toConsumableArray(_styles));
    } else {
      mergedStyles = {
        root: function root() {
          return {};
        }
      };
    }
  }

  if (!noInlineStylesOverrides) {
    mergedStyles = mergeComponentStyles(mergedStyles, props.design && withDebugId({
      root: props.design
    }, 'props.design'), props.styles && withDebugId({
      root: props.styles
    }, 'props.styles'));
  }

  var styleParam = {
    props: props,
    variables: resolvedVariables,
    theme: theme,
    rtl: rtl,
    disableAnimations: disableAnimations
  }; // Fela plugins rely on `direction` param in `theme` prop instead of RTL
  // Our API should be aligned with it
  // Heads Up! Keep in sync with Design.tsx render logic

  var direction = rtl ? 'rtl' : 'ltr';
  var felaParam = {
    theme: {
      direction: direction
    },
    disableAnimations: disableAnimations,
    displayName: displayNames.join(':'),
    // does not affect styles, only used by useEnhancedRenderer in docs
    sanitizeCss: performance.enableSanitizeCssPlugin
  };

  var renderStyles = renderStylesInput || function (style) {
    return renderer.renderRule(function () {
      return style;
    }, felaParam);
  };

  var resolvedStyles = {};
  var resolvedStylesDebug = {};
  var classes = {};

  if (cacheEnabled && theme) {
    if (!stylesCache.has(theme)) {
      stylesCache.set(theme, {});
    }

    if (!classesCache.has(theme)) {
      classesCache.set(theme, {});
    }
  }

  var propsCacheKey = cacheEnabled ? JSON.stringify(stylesProps) : '';
  var variablesCacheKey = cacheEnabled && performance.enableBooleanVariablesCaching ? JSON.stringify(variables) : '';
  var componentCacheKey = cacheEnabled ? "".concat(displayNames.join(':'), ":").concat(propsCacheKey, ":").concat(variablesCacheKey, ":").concat(styleParam.rtl).concat(styleParam.disableAnimations) : '';
  Object.keys(mergedStyles).forEach(function (slotName) {
    // resolve/render slot styles once and cache
    var lazyEvaluationKey = "".concat(slotName, "__return");
    var slotCacheKey = componentCacheKey + slotName;
    Object.defineProperty(resolvedStyles, slotName, {
      enumerable: false,
      configurable: false,
      set: function set(val) {
        // Add to the cache if it's enabled
        if (cacheEnabled && theme) {
          stylesCache.set(theme, Object.assign({}, stylesCache.get(theme), _defineProperty({}, slotCacheKey, val)));
        }

        resolvedStyles[lazyEvaluationKey] = val;
      },
      get: function get() {
        // If caching enabled and entry exists, get from cache, avoid lazy evaluation
        if (cacheEnabled && theme) {
          var stylesThemeCache = stylesCache.get(theme) || {};

          if (stylesThemeCache[slotCacheKey]) {
            return stylesThemeCache[slotCacheKey];
          }
        }

        if (resolvedStyles[lazyEvaluationKey]) {
          return resolvedStyles[lazyEvaluationKey];
        } // resolve/render slot styles once and cache


        resolvedStyles[lazyEvaluationKey] = mergedStyles[slotName](styleParam);

        if (cacheEnabled && theme) {
          stylesCache.set(theme, Object.assign({}, stylesCache.get(theme), _defineProperty({}, slotCacheKey, resolvedStyles[lazyEvaluationKey])));
        }

        if (process.env.NODE_ENV !== 'production' && isDebugEnabled) {
          resolvedStylesDebug[slotName] = resolvedStyles[slotName]['_debug'];
          delete resolvedStyles[slotName]['_debug'];
        }

        return resolvedStyles[lazyEvaluationKey];
      }
    });
    Object.defineProperty(classes, slotName, {
      enumerable: false,
      configurable: false,
      set: function set(val) {
        if (cacheEnabled && theme) {
          classesCache.set(theme, Object.assign({}, classesCache.get(theme), _defineProperty({}, slotCacheKey, val)));
        }

        classes[lazyEvaluationKey] = val;
      },
      get: function get() {
        if (cacheEnabled && theme) {
          var classesThemeCache = classesCache.get(theme) || {};

          if (classesThemeCache[slotCacheKey] || classesThemeCache[slotCacheKey] === '') {
            return slotName === 'root' ? cx(componentClassName, classesThemeCache[slotCacheKey], className) : classesThemeCache[slotCacheKey];
          }
        }

        if (classes[lazyEvaluationKey]) {
          return slotName === 'root' ? cx(componentClassName, classes[lazyEvaluationKey], className) : classes[lazyEvaluationKey];
        } // this resolves the getter magic


        var styleObj = resolvedStyles[slotName];

        if (renderStyles && styleObj) {
          classes[lazyEvaluationKey] = renderStyles(styleObj);

          if (cacheEnabled && theme) {
            classesCache.set(theme, Object.assign({}, classesCache.get(theme), _defineProperty({}, slotCacheKey, classes[lazyEvaluationKey])));
          }
        }

        return slotName === 'root' ? cx(componentClassName, classes[lazyEvaluationKey], className) : classes[lazyEvaluationKey];
      }
    });
  });
  return {
    resolvedStyles: resolvedStyles,
    resolvedStylesDebug: resolvedStylesDebug,
    classes: classes
  };
};

export default resolveStyles;
//# sourceMappingURL=resolveStyles.js.map
