"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var classnames_1 = require("classnames");
var styles_1 = require("@fluentui/styles");
var _ = require("lodash");
// this weak map is used as cache for the classes
var classesCache = new WeakMap();
// this weak map is used as cache for the styles
var stylesCache = new WeakMap();
/**
 * Both resolvedStyles and classes are objects of getters with lazy evaluation
 *
 * Additionally if the cacheEnabled option is provided, than the resolved styles
 * and classes are caching the results in WeakMaps. The key of the maps contains the following:
 * - theme
 * - displayName
 * - slot name
 * - styling props
 * - rtl mode
 * - disable animations mode
 */
var resolveStyles = function (options, resolvedVariables, renderStylesInput) {
    var componentClassName = options.className, theme = options.theme, displayNames = options.displayNames, props = options.props, rtl = options.rtl, disableAnimations = options.disableAnimations, renderer = options.renderer, performance = options.performance;
    var className = props.className, design = props.design, styles = props.styles, variables = props.variables, stylesProps = tslib_1.__rest(props, ["className", "design", "styles", "variables"]);
    var noInlineStylesOverrides = !(design || styles);
    var noVariableOverrides = performance.enableBooleanVariablesCaching || !variables;
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
        if (!performance.enableStylesCaching && performance.enableBooleanVariablesCaching) {
            throw new Error('@fluentui/react-northstar: Please check your "performance" settings on "Provider", to enable "enableBooleanVariablesCaching" you need to enable "enableStylesCaching"');
        }
    }
    if (performance.enableBooleanVariablesCaching) {
        if (_.isPlainObject(variables)) {
            var hasOnlyBooleanVariables = Object.keys(variables).every(function (variableName) {
                return variables[variableName] === null ||
                    typeof variables[variableName] === 'undefined' ||
                    typeof variables[variableName] === 'boolean';
            });
            if (!hasOnlyBooleanVariables) {
                noVariableOverrides = false;
            }
        }
        else {
            noVariableOverrides = false;
        }
    }
    var cacheEnabled = performance.enableStylesCaching && noInlineStylesOverrides && noVariableOverrides;
    // Merge theme styles with inline overrides if any
    var mergedStyles;
    if (displayNames.length === 1) {
        mergedStyles = theme.componentStyles[displayNames[0]] || { root: function () { return ({}); } };
    }
    else {
        var styles_2 = displayNames.map(function (displayName) { return theme.componentStyles[displayName]; }).filter(Boolean);
        if (styles_2.length > 0) {
            mergedStyles = styles_1.mergeComponentStyles.apply(void 0, styles_2);
        }
        else {
            mergedStyles = { root: function () { return ({}); } };
        }
    }
    if (!noInlineStylesOverrides) {
        mergedStyles = styles_1.mergeComponentStyles(mergedStyles, props.design && styles_1.withDebugId({ root: props.design }, 'props.design'), props.styles && styles_1.withDebugId({ root: props.styles }, 'props.styles'));
    }
    var styleParam = {
        props: props,
        variables: resolvedVariables,
        theme: theme,
        rtl: rtl,
        disableAnimations: disableAnimations,
    };
    // Fela plugins rely on `direction` param in `theme` prop instead of RTL
    // Our API should be aligned with it
    // Heads Up! Keep in sync with Design.tsx render logic
    var direction = rtl ? 'rtl' : 'ltr';
    var felaParam = {
        theme: { direction: direction },
        disableAnimations: disableAnimations,
        displayName: displayNames.join(':'),
        sanitizeCss: performance.enableSanitizeCssPlugin,
    };
    var renderStyles = renderStylesInput || (function (style) { return renderer.renderRule(function () { return style; }, felaParam); });
    var resolvedStyles = {};
    var resolvedStylesDebug = {};
    var classes = {};
    if (cacheEnabled && theme) {
        if (!stylesCache.has(theme)) {
            stylesCache.set(theme, {});
        }
        if (!classesCache.has(theme)) {
            classesCache.set(theme, {});
        }
    }
    var propsCacheKey = cacheEnabled ? JSON.stringify(stylesProps) : '';
    var variablesCacheKey = cacheEnabled && performance.enableBooleanVariablesCaching ? JSON.stringify(variables) : '';
    var componentCacheKey = cacheEnabled
        ? displayNames.join(':') + ":" + propsCacheKey + ":" + variablesCacheKey + ":" + styleParam.rtl + styleParam.disableAnimations
        : '';
    Object.keys(mergedStyles).forEach(function (slotName) {
        // resolve/render slot styles once and cache
        var lazyEvaluationKey = slotName + "__return";
        var slotCacheKey = componentCacheKey + slotName;
        Object.defineProperty(resolvedStyles, slotName, {
            enumerable: false,
            configurable: false,
            set: function (val) {
                var _a;
                // Add to the cache if it's enabled
                if (cacheEnabled && theme) {
                    stylesCache.set(theme, tslib_1.__assign(tslib_1.__assign({}, stylesCache.get(theme)), (_a = {}, _a[slotCacheKey] = val, _a)));
                }
                resolvedStyles[lazyEvaluationKey] = val;
            },
            get: function () {
                var _a;
                // If caching enabled and entry exists, get from cache, avoid lazy evaluation
                if (cacheEnabled && theme) {
                    var stylesThemeCache = stylesCache.get(theme) || {};
                    if (stylesThemeCache[slotCacheKey]) {
                        return stylesThemeCache[slotCacheKey];
                    }
                }
                if (resolvedStyles[lazyEvaluationKey]) {
                    return resolvedStyles[lazyEvaluationKey];
                }
                // resolve/render slot styles once and cache
                resolvedStyles[lazyEvaluationKey] = mergedStyles[slotName](styleParam);
                if (cacheEnabled && theme) {
                    stylesCache.set(theme, tslib_1.__assign(tslib_1.__assign({}, stylesCache.get(theme)), (_a = {}, _a[slotCacheKey] = resolvedStyles[lazyEvaluationKey], _a)));
                }
                if (process.env.NODE_ENV !== 'production' && styles_1.isDebugEnabled) {
                    resolvedStylesDebug[slotName] = resolvedStyles[slotName]['_debug'];
                    delete resolvedStyles[slotName]['_debug'];
                }
                return resolvedStyles[lazyEvaluationKey];
            },
        });
        Object.defineProperty(classes, slotName, {
            enumerable: false,
            configurable: false,
            set: function (val) {
                var _a;
                if (cacheEnabled && theme) {
                    classesCache.set(theme, tslib_1.__assign(tslib_1.__assign({}, classesCache.get(theme)), (_a = {}, _a[slotCacheKey] = val, _a)));
                }
                classes[lazyEvaluationKey] = val;
            },
            get: function () {
                var _a;
                if (cacheEnabled && theme) {
                    var classesThemeCache = classesCache.get(theme) || {};
                    if (classesThemeCache[slotCacheKey] || classesThemeCache[slotCacheKey] === '') {
                        return slotName === 'root'
                            ? classnames_1.default(componentClassName, classesThemeCache[slotCacheKey], className)
                            : classesThemeCache[slotCacheKey];
                    }
                }
                if (classes[lazyEvaluationKey]) {
                    return slotName === 'root'
                        ? classnames_1.default(componentClassName, classes[lazyEvaluationKey], className)
                        : classes[lazyEvaluationKey];
                }
                // this resolves the getter magic
                var styleObj = resolvedStyles[slotName];
                if (renderStyles && styleObj) {
                    classes[lazyEvaluationKey] = renderStyles(styleObj);
                    if (cacheEnabled && theme) {
                        classesCache.set(theme, tslib_1.__assign(tslib_1.__assign({}, classesCache.get(theme)), (_a = {}, _a[slotCacheKey] = classes[lazyEvaluationKey], _a)));
                    }
                }
                return slotName === 'root'
                    ? classnames_1.default(componentClassName, classes[lazyEvaluationKey], className)
                    : classes[lazyEvaluationKey];
            },
        });
    });
    return {
        resolvedStyles: resolvedStyles,
        resolvedStylesDebug: resolvedStylesDebug,
        classes: classes,
    };
};
exports.default = resolveStyles;
