{"version":3,"sources":["utils/AutoControlledComponent.tsx"],"names":["UIComponent","getDefaultPropName","prop","toUpperCase","slice","getAutoControlledStateValue","propName","props","state","undefined","includeDefaults","propValue","defaultProp","initialState","multiple","AutoControlledComponent","ctx","constructor","autoControlledProps","getAutoControlledStateFromProps","process","env","NODE_ENV","defaultProps","name","propTypes","getDerivedStateFromProps","console","error","illegalDefaults","join","illegalAutoControlled","initialAutoControlledState","reduce","acc","defaultPropName","newStateFromProps","isNextDefined","computedState"],"mappings":";;;;;;;;;;;;;;;AA2BA,OAAOA,WAAP,MAAwB,eAAxB;;AAEA,IAAMC,kBAAkB,GAAG,SAArBA,kBAAqB,CAAAC,IAAI;AAAA,0BAAcA,IAAI,CAAC,CAAD,CAAJ,CAAQC,WAAR,KAAwBD,IAAI,CAACE,KAAL,CAAW,CAAX,CAAtC;AAAA,CAA/B;AAEA;;;;;;;;;;;;;;;;AAcA,OAAO,IAAMC,2BAA2B,GAAG,SAA9BA,2BAA8B,CACzCC,QADyC,EAEzCC,KAFyC,EAKtC;AAAA,MAFHC,KAEG,uEAFUC,SAEV;AAAA,MADHC,eACG,uEADwB,KACxB;AACH;AACA,MAAMC,SAAS,GAAGJ,KAAK,CAACD,QAAD,CAAvB;AACA,MAAIK,SAAS,KAAKF,SAAlB,EAA6B,OAAOE,SAAP;;AAE7B,MAAID,eAAJ,EAAqB;AACnB;AACA,QAAME,WAAW,GAAGL,KAAK,CAACN,kBAAkB,CAACK,QAAD,CAAnB,CAAzB;AACA,QAAIM,WAAW,KAAKH,SAApB,EAA+B,OAAOG,WAAP,CAHZ,CAKnB;;AACA,QAAIJ,KAAJ,EAAW;AACT,UAAMK,YAAY,GAAGL,KAAK,CAACF,QAAD,CAA1B;AACA,UAAIO,YAAY,KAAKJ,SAArB,EAAgC,OAAOI,YAAP;AACjC;AACF,GAfE,CAiBH;AACA;;;AACA,MAAIP,QAAQ,KAAK,SAAjB,EAA4B,OAAO,KAAP;AAC5B,MAAIA,QAAQ,KAAK,OAAjB,EAA0B,OAAOC,KAAK,CAACO,QAAN,GAAiB,EAAjB,GAAsB,EAA7B,CApBvB,CAsBH;AACD,CA5BM;;IA8BcC,uB;;;;;AACnB,mCAAYR,KAAZ,EAAsBS,GAAtB,EAAgC;AAAA;;AAAA;;AAC9B,iGAAMT,KAAN,EAAaS,GAAb;AAD8B,eAGmC,MAAKC,WAHxC;AAAA,QAGtBC,mBAHsB,QAGtBA,mBAHsB;AAAA,QAGDC,+BAHC,QAGDA,+BAHC;AAI9B,QAAMX,KAAK,GAAG,uCAAe,+BAAf,EAAgD,MAAKD,KAArD,KAA+D,EAA7E;;AAEA,QAAIa,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AAAA,kBAC2B,MAAKL,WADhC;AAAA,UACjCM,YADiC,SACjCA,YADiC;AAAA,UACnBC,IADmB,SACnBA,IADmB;AAAA,UACbC,SADa,SACbA,SADa;AAAA,UACFC,wBADE,SACFA,wBADE,EAGzC;;AACA,UAAIA,wBAAwB,KAAKX,uBAAuB,CAACW,wBAAzD,EAAmF;AACjF;AACAC,QAAAA,OAAO,CAACC,KAAR,2BACqBJ,IADrB;AAGD,OATwC,CAWzC;;;AACA,UAAI,CAACN,mBAAL,EAA0B;AACxB;AACAS,QAAAA,OAAO,CAACC,KAAR,2BAAiCJ,IAAjC;AACD,OAfwC,CAiBzC;;;AACA,YAAON,mBAAP,EAA4B,UAAAhB,IAAI,EAAI;AAClC,YAAMU,WAAW,GAAGX,kBAAkB,CAACC,IAAD,CAAtC,CADkC,CAElC;;AACA,YAAI,CAAC,KAAMuB,SAAN,EAAiBb,WAAjB,CAAL,EAAoC;AAClC;AACAe,UAAAA,OAAO,CAACC,KAAR,WAAiBJ,IAAjB,2BAAqCZ,WAArC,gEAAoGV,IAApG;AACD,SANiC,CAOlC;;;AACA,YAAI,CAAC,KAAMuB,SAAN,EAAiBvB,IAAjB,CAAL,EAA6B;AAC3B;AACAyB,UAAAA,OAAO,CAACC,KAAR,WAAiBJ,IAAjB,yEAAmFtB,IAAnF;AACD;AACF,OAZD,EAlByC,CAgCzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAM2B,eAAe,GAAG,cAAeX,mBAAf,EAAoC,MAAOK,YAAP,CAApC,CAAxB;;AACA,UAAI,CAAC,SAAUM,eAAV,CAAL,EAAiC;AAC/B;AACAF,QAAAA,OAAO,CAACC,KAAR,CACE,CACE,0EADF,EAEE,uEAFF,EAGE,8EAHF,gBAISJ,IAJT,uBAIyBK,eAJzB,UAKEC,IALF,CAKO,GALP,CADF;AAQD,OArDwC,CAuDzC;AACA;AACA;AACA;;;AACA,UAAMC,qBAAqB,GAAG,QAASb,mBAAT,EAA8B,UAAAhB,IAAI;AAAA,eAAI,YAAaA,IAAb,EAAmB,SAAnB,CAAJ;AAAA,OAAlC,CAA9B;;AACA,UAAI,CAAC,SAAU6B,qBAAV,CAAL,EAAuC;AACrC;AACAJ,QAAAA,OAAO,CAACC,KAAR,CACE,CACE,kDADF,EAEE,0CAFF,gBAGSJ,IAHT,qCAGuCO,qBAHvC,UAIED,IAJF,CAIO,GAJP,CADF;AAOD;AACF,KA5E6B,CA8E9B;AACA;AACA;AACA;;;AACA,QAAME,0BAA0B,GAAGd,mBAAmB,CAACe,MAApB,CAA2B,UAACC,GAAD,EAAMhC,IAAN,EAAe;AAC3EgC,MAAAA,GAAG,CAAChC,IAAD,CAAH,GAAYG,2BAA2B,CAACH,IAAD,EAAO,MAAKK,KAAZ,EAAmBC,KAAnB,EAA0B,IAA1B,CAAvC;;AAEA,UAAIY,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,YAAMa,eAAe,GAAGlC,kBAAkB,CAACC,IAAD,CAA1C;AADyC,YAEjCsB,KAFiC,GAExB,MAAKP,WAFmB,CAEjCO,IAFiC,EAGzC;;AACA,YAAI,CAAC,aAAc,MAAKjB,KAAL,CAAW4B,eAAX,CAAd,CAAD,IAA+C,CAAC,aAAc,MAAK5B,KAAL,CAAWL,IAAX,CAAd,CAApD,EAAqF;AACnF;AACAyB,UAAAA,OAAO,CAACC,KAAR,WACKJ,KADL,qBACmBtB,IADnB,mDAC+DiC,eAD/D,iBACqFjC,IADrF;AAGD;AACF;;AAED,aAAOgC,GAAP;AACD,KAhBkC,EAgBhC,EAhBgC,CAAnC;AAkBA,UAAK1B,KAAL,qBACKA,KADL,MAEKwB,0BAFL;AAGEd,MAAAA,mBAAmB,EAAnBA,mBAHF;AAIEC,MAAAA,+BAA+B,EAA/BA;AAJF;AApG8B;AA0G/B;;;EA3GkEnB,W,GAqHrE;;;gBArHqBe,uB;;gBAAAA,uB;;SAAAA,uB;;AAsHrBA,uBAAuB,CAACW,wBAAxB,GAAmD,UAASnB,KAAT,EAAgBC,KAAhB,EAAuB;AAAA,MAChEU,mBADgE,GACPV,KADO,CAChEU,mBADgE;AAAA,MAC3CC,+BAD2C,GACPX,KADO,CAC3CW,+BAD2C,EAGxE;;AACA,MAAMiB,iBAAiB,GAAGlB,mBAAmB,CAACe,MAApB,CAA2B,UAACC,GAAD,EAAMhC,IAAN,EAAe;AAClE,QAAMmC,aAAa,GAAG,CAAC,aAAc9B,KAAK,CAACL,IAAD,CAAnB,CAAvB,CADkE,CAGlE;;AACA,QAAImC,aAAJ,EAAmBH,GAAG,CAAChC,IAAD,CAAH,GAAYK,KAAK,CAACL,IAAD,CAAjB;AAEnB,WAAOgC,GAAP;AACD,GAPyB,EAOvB,EAPuB,CAA1B,CAJwE,CAaxE;AACA;;AACA,MAAIf,+BAAJ,EAAqC;AACnC,QAAMmB,aAAa,GAAGnB,+BAA+B,CAACZ,KAAD,oBAChDC,KADgD,MAEhD4B,iBAFgD,EAArD,CADmC,CAMnC;;AACA,6BAAYA,iBAAZ,MAAkCE,aAAlC;AACD;;AAED,SAAOF,iBAAP;AACD,CA1BD,C,CA4BA;;;AACArB,uBAAuB,CAACI,+BAAxB,GAA0D,UAASZ,KAAT,EAAgBC,KAAhB,EAAuB;AAC/E,SAAO,IAAP;AACD,CAFD","sourcesContent":["/**\n * Why choose inheritance over a HOC?  Multiple advantages for this particular use case.\n * In short, we need identical functionality to setState(), unless there is a prop defined\n * for the state key.  Also:\n *\n * 1. Single Renders\n *    Calling trySetState() in constructor(), componentWillMount(), or componentWillReceiveProps()\n *    does not cause two renders. Consumers and tests do not have to wait two renders to get state.\n *    See www.react.run/4kJFdKoxb/27 for an example of this issue.\n *\n * 2. Simple Testing\n *    Using a HOC means you must either test the undecorated component or test through the decorator.\n *    Testing the undecorated component means you must mock the decorator functionality.\n *    Testing through the HOC means you can not simply shallow render your component.\n *\n * 3. Statics\n *    HOC wrap instances, so statics are no longer accessible.  They can be hoisted, but this is more\n *    looping over properties and storing references.  We rely heavily on statics for testing and sub\n *    components.\n *\n * 4. Instance Methods\n *    Some instance methods may be exposed to users via refs.  Again, these are lost with HOC unless\n *    hoisted and exposed by the HOC.\n */\nimport * as _ from 'lodash';\nimport * as React from 'react';\n\nimport UIComponent from './UIComponent';\n\nconst getDefaultPropName = prop => `default${prop[0].toUpperCase() + prop.slice(1)}`;\n\n/**\n * Return the auto controlled state value for a give prop. The initial value is chosen in this order:\n *  - regular props\n *  - then, default props\n *  - then, initial state\n *  - then, `checked` defaults to false\n *  - then, `value` defaults to '' or [] if props.multiple\n *  - else, undefined\n *\n *  @param propName - A prop name\n *  @param props - A props object\n *  @param state - A state object\n *  @param includeDefaults - Whether or not to heed the default props or initial state\n */\nexport const getAutoControlledStateValue = (\n  propName: string,\n  props: any,\n  state: any = undefined,\n  includeDefaults: boolean = false,\n) => {\n  // regular props\n  const propValue = props[propName];\n  if (propValue !== undefined) return propValue;\n\n  if (includeDefaults) {\n    // defaultProps\n    const defaultProp = props[getDefaultPropName(propName)];\n    if (defaultProp !== undefined) return defaultProp;\n\n    // initial state - state may be null or undefined\n    if (state) {\n      const initialState = state[propName];\n      if (initialState !== undefined) return initialState;\n    }\n  }\n\n  // React doesn't allow changing from uncontrolled to controlled components,\n  // default checked/value if they were not present.\n  if (propName === 'checked') return false;\n  if (propName === 'value') return props.multiple ? [] : '';\n\n  // otherwise, undefined\n};\n\nexport default class AutoControlledComponent<P = {}, S = {}> extends UIComponent<P, S> {\n  constructor(props: P, ctx: any) {\n    super(props, ctx);\n\n    const { autoControlledProps, getAutoControlledStateFromProps } = this.constructor as any;\n    const state = _.invoke(this, 'getInitialAutoControlledState', this.props) || {};\n\n    if (process.env.NODE_ENV !== 'production') {\n      const { defaultProps, name, propTypes, getDerivedStateFromProps } = this.constructor as any;\n\n      // require usage of getAutoControlledStateFromProps()\n      if (getDerivedStateFromProps !== AutoControlledComponent.getDerivedStateFromProps) {\n        /* eslint-disable-next-line no-console */\n        console.error(\n          `Auto controlled ${name} must specify a static getAutoControlledStateFromProps() instead of getDerivedStateFromProps().`,\n        );\n      }\n\n      // require static autoControlledProps\n      if (!autoControlledProps) {\n        /* eslint-disable-next-line no-console */\n        console.error(`Auto controlled ${name} must specify a static autoControlledProps array.`);\n      }\n\n      // require propTypes\n      _.each(autoControlledProps, prop => {\n        const defaultProp = getDefaultPropName(prop);\n        // regular prop\n        if (!_.has(propTypes, defaultProp)) {\n          /* eslint-disable-next-line no-console */\n          console.error(`${name} is missing \"${defaultProp}\" propTypes validation for auto controlled prop \"${prop}\".`);\n        }\n        // its default prop\n        if (!_.has(propTypes, prop)) {\n          /* eslint-disable-next-line no-console */\n          console.error(`${name} is missing propTypes validation for auto controlled prop \"${prop}\".`);\n        }\n      });\n\n      // prevent autoControlledProps in defaultProps\n      //\n      // When setting state, auto controlled props values always win (so the parent can manage them).\n      // It is not reasonable to decipher the difference between props from the parent and defaultProps.\n      // Allowing defaultProps results in trySetState always deferring to the defaultProp value.\n      // Auto controlled props also listed in defaultProps can never be updated.\n      //\n      // To set defaults for an AutoControlled prop, you can set the initial state in the\n      // constructor or by using an ES7 property initializer:\n      // https://babeljs.io/blog/2015/06/07/react-on-es6-plus#property-initializers\n      const illegalDefaults = _.intersection(autoControlledProps, _.keys(defaultProps));\n      if (!_.isEmpty(illegalDefaults)) {\n        /* eslint-disable-next-line no-console */\n        console.error(\n          [\n            'Do not set defaultProps for autoControlledProps. You can set defaults by',\n            'setting state in the constructor or using an ES7 property initializer',\n            '(https://babeljs.io/blog/2015/06/07/react-on-es6-plus#property-initializers)',\n            `See ${name} props: \"${illegalDefaults}\".`,\n          ].join(' '),\n        );\n      }\n\n      // prevent listing defaultProps in autoControlledProps\n      //\n      // Default props are automatically handled.\n      // Listing defaults in autoControlledProps would result in allowing defaultDefaultValue props.\n      const illegalAutoControlled = _.filter(autoControlledProps, prop => _.startsWith(prop, 'default'));\n      if (!_.isEmpty(illegalAutoControlled)) {\n        /* eslint-disable-next-line no-console */\n        console.error(\n          [\n            'Do not add default props to autoControlledProps.',\n            'Default props are automatically handled.',\n            `See ${name} autoControlledProps: \"${illegalAutoControlled}\".`,\n          ].join(' '),\n        );\n      }\n    }\n\n    // Auto controlled props are copied to state.\n    // Set initial state by copying auto controlled props to state.\n    // Also look for the default prop for any auto controlled props (foo => defaultFoo)\n    // so we can set initial values from defaults.\n    const initialAutoControlledState = autoControlledProps.reduce((acc, prop) => {\n      acc[prop] = getAutoControlledStateValue(prop, this.props, state, true);\n\n      if (process.env.NODE_ENV !== 'production') {\n        const defaultPropName = getDefaultPropName(prop);\n        const { name } = this.constructor;\n        // prevent defaultFoo={} along side foo={}\n        if (!_.isUndefined(this.props[defaultPropName]) && !_.isUndefined(this.props[prop])) {\n          /* eslint-disable-next-line no-console */\n          console.error(\n            `${name} prop \"${prop}\" is auto controlled. Specify either ${defaultPropName} or ${prop}, but not both.`,\n          );\n        }\n      }\n\n      return acc;\n    }, {});\n\n    this.state = {\n      ...state,\n      ...initialAutoControlledState,\n      autoControlledProps,\n      getAutoControlledStateFromProps,\n    };\n  }\n\n  static getDerivedStateFromProps: React.GetDerivedStateFromProps<any, any>;\n\n  /**\n   * Override this method to use getDerivedStateFromProps() in child components.\n   */\n  static getAutoControlledStateFromProps: React.GetDerivedStateFromProps<any, any>;\n}\n\n// eslint-disable-next-line func-names\nAutoControlledComponent.getDerivedStateFromProps = function(props, state) {\n  const { autoControlledProps, getAutoControlledStateFromProps } = state;\n\n  // Solve the next state for autoControlledProps\n  const newStateFromProps = autoControlledProps.reduce((acc, prop) => {\n    const isNextDefined = !_.isUndefined(props[prop]);\n\n    // if next is defined then use its value\n    if (isNextDefined) acc[prop] = props[prop];\n\n    return acc;\n  }, {});\n\n  // Due to the inheritance of the AutoControlledComponent we should call its\n  // getAutoControlledStateFromProps() and merge it with the existing state\n  if (getAutoControlledStateFromProps) {\n    const computedState = getAutoControlledStateFromProps(props, {\n      ...state,\n      ...newStateFromProps,\n    });\n\n    // We should follow the idea of getDerivedStateFromProps() and return only modified state\n    return { ...newStateFromProps, ...computedState };\n  }\n\n  return newStateFromProps;\n};\n\n// eslint-disable-next-line func-names\nAutoControlledComponent.getAutoControlledStateFromProps = function(props, state) {\n  return null;\n};\n"],"file":"AutoControlledComponent.js"}