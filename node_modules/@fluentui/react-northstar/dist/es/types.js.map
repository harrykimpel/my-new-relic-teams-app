{"version":3,"sources":["types.ts"],"names":["withSafeTypeForAs","componentType","overloadedComponentType","Error","UNSAFE_typed","withProps"],"mappings":"AAKA;AAOA;AACA;AACA;AAQA;AACA;AACA;AAQA;AACA;AACA;AAqBA;AACA;AACA;AAIA;AAaA;AACA;AACA;;AAUA;;;;AAIA;AACA;AACA;AACA;;AAEA;;;;AAIyE;AAYzE,OAAO,IAAMA,iBAAiB,GAAG,SAApBA,iBAAoB,CAK/BC,aAL+B,EAM5B;AACH;;;;AAIA;AACA;AACA;AAGA,WAASC,uBAAT,GAA0C;AACxC,UAAM,IAAIC,KAAJ,CAAU,wCAAV,CAAN;AACD;;AAED,SAAQF,aAAR;AAED,CAtBM;AA2BP,OAAO,IAAMG,YAAY,GAAG,SAAfA,YAAe,CAAiBH,aAAjB,EAAmD;AAC7E,SAAO;AACLI,IAAAA,SAAS,EAAE;AAAA,aAAeJ,aAAf;AAAA;AADN,GAAP;AAGD,CAJM,C,CAMP;AACA;AACA","sourcesContent":["import { StylesContextInputValue, StylesContextValue, Telemetry } from '@fluentui/react-bindings';\nimport * as React from 'react';\n\nimport { ShorthandConfig, ShorthandFactory } from './utils/factories';\n\n// Temporary workaround for @lodash dependency\n\nexport type DebounceResultFn<T> = T & {\n  cancel: () => void;\n  flush: () => void;\n};\n\n// ========================================================\n// Utilities\n// ========================================================\n\nexport type ResultOf<T> = T extends (...arg: any[]) => infer TResult ? TResult : never;\n\nexport type ObjectOf<T> = { [key: string]: T };\n\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\n// ========================================================\n// Components\n// ========================================================\n\nexport type FluentComponentStaticProps<P = {}> = {\n  handledProps: (keyof P)[];\n  create: ShorthandFactory<P>;\n  shorthandConfig?: ShorthandConfig<P>;\n};\n\n// ========================================================\n// Props\n// ========================================================\n\nexport type Props<T = {}> = T & ObjectOf<any>;\nexport type ReactChildren = React.ReactNodeArray | React.ReactNode;\n\nexport type WithAsProp<T> = T & { as?: any };\n\nexport type ComponentEventHandler<TProps> = (event: React.SyntheticEvent<HTMLElement>, data?: TProps) => void;\n\nexport type ComponentKeyboardEventHandler<TProps> = (event: React.KeyboardEvent<any>, data?: TProps) => void;\n\nexport type InstanceOf<T> = T extends { new (...args: any[]): infer TInstance } ? TInstance : never;\n\nexport type PropsOf<T> = T extends React.Component<infer TProps>\n  ? TProps\n  : T extends React.FunctionComponent<infer TProps>\n  ? TProps\n  : T extends keyof JSX.IntrinsicElements\n  ? JSX.IntrinsicElements[T]\n  : never;\n\n// ========================================================\n// Shorthand Factories\n// ========================================================\n\nexport type ShorthandRenderFunction<P> = (Component: React.ElementType<P>, props: P) => React.ReactNode;\n\n// The ReactFragment here is replaced from the original typings with ReactNodeArray because of incorrect inheriting of the type when it is defined as {}\ntype ReactNode = React.ReactChild | React.ReactNodeArray | React.ReactPortal | boolean | null | undefined;\n\nexport type ShorthandValue<P extends Props> = ReactNode | ObjectShorthandValue<P>;\n\nexport type ShorthandCollection<P, K = never> = ShorthandValue<P & { kind?: K }>[];\n\nexport type ObjectShorthandValue<P extends Props> = Props<P> & {\n  children?: P['children'] | ShorthandRenderFunction<P>;\n};\n\nexport type ObjectShorthandCollection<P, K = never> = ObjectShorthandValue<P & { kind?: K }>[];\n\n// ========================================================\n// Types for As prop support\n// ========================================================\n\ntype ValueOf<TFirst, TSecond, TKey extends keyof (TFirst & TSecond)> = TKey extends keyof TFirst\n  ? TFirst[TKey]\n  : TKey extends keyof TSecond\n  ? TSecond[TKey]\n  : {};\n\ntype Extended<TFirst, TSecond> = { [K in keyof (TFirst & TSecond)]: ValueOf<TFirst, TSecond, K> };\n\n/**\n * TODO: introduce back this path once TS compiler issue that leads to\n * 'JS Heap Out Of Memory' exception will be fixed\n */\n// type AsHtmlElement<Tag extends keyof JSX.IntrinsicElements, TProps> = {\n//   as: Tag\n// } & JSX.IntrinsicElements[Tag] &\n//   TProps\n\n/**\n * TODO: restrict type further once TS compiler issue that leads to\n * 'JS Heap Out Of Memory' exception will be fixed\n */\ntype AsComponent<C, TProps> = { as: C } & TProps & { [K: string]: any }; // & PropsOf<InstanceOf<C>>\n\ntype HoistedStaticPropsOf<T> = Exclude<keyof T, keyof React.ComponentType | 'prototype'> | 'displayName';\n\ntype Intersect<First extends string | number | symbol, Second extends string | number | symbol> = {\n  [K in First]: K extends Second ? K : never;\n}[First];\n\ntype PickProps<T, Props extends string | number | symbol> = {\n  [K in Intersect<Props, keyof T>]: T[K];\n};\n\nexport const withSafeTypeForAs = <\n  TComponentType extends React.ComponentType,\n  TProps,\n  TAs extends keyof JSX.IntrinsicElements = 'div'\n>(\n  componentType: TComponentType,\n) => {\n  /**\n   * TODO: introduce overload once TS compiler issue that leads to\n   * 'JS Heap Out Of Memory' exception will be fixed\n   */\n  // function overloadedComponentType<Tag extends keyof JSX.IntrinsicElements>(\n  //   x: AsHtmlElement<Tag, TProps>,\n  // ): JSX.Element\n  function overloadedComponentType<Tag>(x: AsComponent<Tag, TProps>): JSX.Element;\n  function overloadedComponentType(x: Extended<TProps, JSX.IntrinsicElements[TAs]>): JSX.Element;\n  function overloadedComponentType(): never {\n    throw new Error('Defines unreachable execution scenario');\n  }\n\n  return (componentType as any) as typeof overloadedComponentType &\n    PickProps<TComponentType, HoistedStaticPropsOf<TComponentType>>;\n};\n\nexport type UNSAFE_TypedComponent<TComponentType, TProps> = React.FunctionComponent<TProps & { [K: string]: any }> &\n  PickProps<TComponentType, keyof TComponentType>;\n\nexport const UNSAFE_typed = <TComponentType>(componentType: TComponentType) => {\n  return {\n    withProps: <TProps>() => (componentType as any) as UNSAFE_TypedComponent<TComponentType, TProps>,\n  };\n};\n\n// ========================================================\n// Provider's context\n// ========================================================\n\nexport interface ProviderContextInput extends StylesContextInputValue {\n  target?: Document;\n  telemetry?: Telemetry;\n}\n\nexport interface ProviderContextPrepared extends StylesContextValue {\n  // `target` can be undefined for SSR\n  target: Document | undefined;\n  telemetry: Telemetry | undefined;\n}\n"],"file":"types.js"}