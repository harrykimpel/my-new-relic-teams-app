import _typeof from "@babel/runtime/helpers/esm/typeof";
import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _debounce from "lodash/debounce";
import _findIndex from "lodash/findIndex";
import _isNil from "lodash/isNil";
import _isEmpty from "lodash/isEmpty";
import _isNumber from "lodash/isNumber";
import _invoke from "lodash/invoke";
import _isFunction from "lodash/isFunction";
import _map from "lodash/map";
import _differenceBy from "lodash/differenceBy";
import _isArray from "lodash/isArray";
import _uniqueId from "lodash/uniqueId";
import { handleRef, Ref } from '@fluentui/react-component-ref';
import * as customPropTypes from '@fluentui/react-proptypes';
import { indicatorBehavior } from '@fluentui/accessibility';
import * as React from 'react';
import * as PropTypes from 'prop-types';
import cx from 'classnames';
import * as keyboardKey from 'keyboard-key';
import { withSafeTypeForAs } from '../../types';
import Downshift from 'downshift';
import { AutoControlledComponent, commonPropTypes, isFromKeyboard, createShorthand } from '../../utils';
import List from '../List/List';
import DropdownItem from './DropdownItem';
import DropdownSelectedItem from './DropdownSelectedItem';
import DropdownSearchInput from './DropdownSearchInput';
import Button from '../Button/Button';
import { screenReaderContainerStyles } from '../../utils/accessibility/Styles/accessibilityStyles';
import Box from '../Box/Box';
import Portal from '../Portal/Portal';
import { ALIGNMENTS, POSITIONS, Popper, getPopperPropsFromShorthand } from '../../utils/positioner';
export var dropdownClassName = 'ui-dropdown';
export var dropdownSlotClassNames = {
  clearIndicator: "".concat(dropdownClassName, "__clear-indicator"),
  container: "".concat(dropdownClassName, "__container"),
  toggleIndicator: "".concat(dropdownClassName, "__toggle-indicator"),
  item: "".concat(dropdownClassName, "__item"),
  itemsList: "".concat(dropdownClassName, "__items-list"),
  searchInput: "".concat(dropdownClassName, "__searchinput"),
  selectedItem: "".concat(dropdownClassName, "__selecteditem"),
  selectedItems: "".concat(dropdownClassName, "__selected-items"),
  triggerButton: "".concat(dropdownClassName, "__trigger-button")
};

var Dropdown =
/*#__PURE__*/
function (_AutoControlledCompon) {
  _inherits(Dropdown, _AutoControlledCompon);

  function Dropdown() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, Dropdown);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Dropdown)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "buttonRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "inputRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "listRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "selectedItemsRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "containerRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "defaultTriggerButtonId", _uniqueId('dropdown-trigger-button-'));

    _defineProperty(_assertThisInitialized(_this), "handleChange", function (e) {
      // Dropdown component doesn't present any `input` component in markup, however all of our
      // components should handle events transparently.
      _invoke(_this.props, 'onChange', e, Object.assign({}, _this.props, {
        value: _this.state.value
      }));
    });

    _defineProperty(_assertThisInitialized(_this), "downshiftStateReducer", function (state, changes) {
      var activeElement = _this.context.target.activeElement;

      switch (changes.type) {
        case Downshift.stateChangeTypes.blurButton:
          // Downshift closes the list by default on trigger blur. It does not support the case when dropdown is
          // single selection and focuses list on trigger click/up/down/space/enter. Treating that here.
          if (state.isOpen && activeElement === _this.listRef.current) {
            return {}; // won't change state in this case.
          }

        default:
          return changes;
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleStateChange", function (changes) {
      var _this$props = _this.props,
          search = _this$props.search,
          multiple = _this$props.multiple,
          highlightFirstItemOnOpen = _this$props.highlightFirstItemOnOpen,
          items = _this$props.items,
          getA11ySelectionMessage = _this$props.getA11ySelectionMessage;
      var _this$state = _this.state,
          value = _this$state.value,
          open = _this$state.open;
      var type = changes.type;
      var newState = {};

      switch (type) {
        case Downshift.stateChangeTypes.changeInput:
          {
            var shouldValueChange = changes.inputValue === '' && !multiple && value.length > 0;
            newState.searchQuery = changes.inputValue;
            newState.highlightedIndex = highlightFirstItemOnOpen ? 0 : null;

            if (shouldValueChange) {
              newState.value = [];
            }

            if (open) {
              // we clear value when in single selection user cleared the query.
              var shouldMenuClose = changes.inputValue === '' || changes.selectedItem !== undefined;

              if (shouldMenuClose) {
                newState.open = false;
              }
            } else {
              newState.open = true;
            }

            break;
          }

        case Downshift.stateChangeTypes.keyDownEnter:
        case Downshift.stateChangeTypes.clickItem:
          var shouldAddHighlightedIndex = !multiple && items && items.length > 0;
          var isSameItemSelected = changes.selectedItem === undefined;
          var newValue = isSameItemSelected ? value[0] : changes.selectedItem;
          newState.searchQuery = _this.getSelectedItemAsString(newValue);
          newState.open = false;
          newState.highlightedIndex = shouldAddHighlightedIndex ? items.indexOf(newValue) : null;

          if (!isSameItemSelected) {
            newState.value = multiple ? [].concat(_toConsumableArray(value), [changes.selectedItem]) : [changes.selectedItem];

            if (getA11ySelectionMessage && getA11ySelectionMessage.onAdd) {
              _this.setA11ySelectionMessage(getA11ySelectionMessage.onAdd(newValue));
            }
          }

          if (multiple) {
            setTimeout(function () {
              return _this.selectedItemsRef.current.scrollTop = _this.selectedItemsRef.current.scrollHeight;
            }, 0);
          }

          _this.tryFocusTriggerButton();

          break;

        case Downshift.stateChangeTypes.keyDownEscape:
          if (search) {
            newState.searchQuery = '';

            if (!multiple) {
              newState.value = [];
            }
          }

          newState.open = false;
          newState.highlightedIndex = highlightFirstItemOnOpen ? 0 : null;
          break;

        case Downshift.stateChangeTypes.keyDownArrowDown:
        case Downshift.stateChangeTypes.keyDownArrowUp:
          if (changes.isOpen !== undefined) {
            newState.open = changes.isOpen;
            newState.highlightedIndex = changes.highlightedIndex;

            if (changes.isOpen) {
              var highlightedIndexOnArrowKeyOpen = _this.getHighlightedIndexOnArrowKeyOpen(changes);

              if (_isNumber(highlightedIndexOnArrowKeyOpen)) {
                newState.highlightedIndex = highlightedIndexOnArrowKeyOpen;
              }

              if (!search) {
                _this.listRef.current.focus();
              }
            } else {
              newState.highlightedIndex = null;
            }
          }

        case Downshift.stateChangeTypes['keyDownHome']:
        case Downshift.stateChangeTypes['keyDownEnd']:
          if (open && _isNumber(changes.highlightedIndex)) {
            newState.highlightedIndex = changes.highlightedIndex;
            newState.itemIsFromKeyboard = true;
          }

          break;

        case Downshift.stateChangeTypes.mouseUp:
          if (open) {
            newState.open = false;
            newState.highlightedIndex = null;
          }

          break;

        case Downshift.stateChangeTypes.clickButton:
        case Downshift.stateChangeTypes.keyDownSpaceButton:
          newState.open = changes.isOpen;

          if (changes.isOpen) {
            var _highlightedIndexOnArrowKeyOpen = _this.getHighlightedIndexOnArrowKeyOpen(changes);

            if (_isNumber(_highlightedIndexOnArrowKeyOpen)) {
              newState.highlightedIndex = _highlightedIndexOnArrowKeyOpen;
            }

            if (!search) {
              _this.listRef.current.focus();
            }
          } else {
            newState.highlightedIndex = null;
          }

          break;

        case Downshift.stateChangeTypes.itemMouseEnter:
          newState.highlightedIndex = changes.highlightedIndex;
          newState.itemIsFromKeyboard = false;
          break;

        case Downshift.stateChangeTypes.unknown:
          if (changes.selectedItem) {
            newState.value = multiple ? [].concat(_toConsumableArray(value), [changes.selectedItem]) : [changes.selectedItem];
            newState.searchQuery = multiple ? '' : changes.inputValue;
            newState.open = false;
            newState.highlightedIndex = changes.highlightedIndex;

            _this.tryFocusTriggerButton();
          } else {
            newState.open = changes.isOpen;
          }

        default:
          break;
      }

      if (_isEmpty(newState)) {
        return;
      }

      var handlers = [newState.value !== undefined && 'onChange', newState.highlightedIndex !== undefined && 'onHighlightedIndexChange', newState.open !== undefined && 'onOpenChange', newState.searchQuery !== undefined && 'onSearchQueryChange'].filter(Boolean);

      _this.setStateAndInvokeHandler(handlers, null, newState);
    });

    _defineProperty(_assertThisInitialized(_this), "isSelectedItemActive", function (index) {
      return index === _this.state.activeSelectedIndex;
    });

    _defineProperty(_assertThisInitialized(_this), "handleItemOverrides", function (item, index, getItemProps, selected) {
      return function (predefinedProps) {
        return {
          accessibilityItemProps: Object.assign({}, getItemProps({
            item: item,
            index: index,
            disabled: item['disabled'],
            onClick: function onClick(e) {
              e.stopPropagation();
              e.nativeEvent.stopImmediatePropagation();

              _invoke(predefinedProps, 'onClick', e, predefinedProps);
            }
          }), {}, !_this.props.multiple && {
            'aria-selected': selected
          })
        };
      };
    });

    _defineProperty(_assertThisInitialized(_this), "handleSelectedItemOverrides", function (item, rtl) {
      return function (predefinedProps) {
        return {
          onRemove: function onRemove(e, dropdownSelectedItemProps) {
            _this.handleSelectedItemRemove(e, item, predefinedProps, dropdownSelectedItemProps);
          },
          onClick: function onClick(e, dropdownSelectedItemProps) {
            _this.setStateAndInvokeHandler(['onActiveSelectedIndexChange'], null, {
              activeSelectedIndex: _this.state.value.indexOf(item)
            });

            e.stopPropagation();

            _invoke(predefinedProps, 'onClick', e, dropdownSelectedItemProps);
          },
          onKeyDown: function onKeyDown(e, dropdownSelectedItemProps) {
            _this.handleSelectedItemKeyDown(e, item, predefinedProps, dropdownSelectedItemProps, rtl);
          }
        };
      };
    });

    _defineProperty(_assertThisInitialized(_this), "handleSearchInputOverrides", function (highlightedIndex, rtl, selectItemAtIndex, toggleMenu, accessibilityComboboxProps, getInputProps) {
      return function (predefinedProps) {
        var handleInputBlur = function handleInputBlur(e, searchInputProps) {
          if (!disabled) {
            _this.setState({
              focused: false,
              isFromKeyboard: isFromKeyboard()
            });

            e.nativeEvent['preventDownshiftDefault'] = true;
          }

          _invoke(predefinedProps, 'onInputBlur', e, searchInputProps);
        };

        var disabled = _this.props.disabled;

        var handleInputKeyDown = function handleInputKeyDown(e, searchInputProps) {
          if (!disabled) {
            switch (keyboardKey.getCode(e)) {
              case keyboardKey.Tab:
                _this.handleTabSelection(e, highlightedIndex, selectItemAtIndex, toggleMenu);

                break;

              case keyboardKey.ArrowLeft:
                if (!rtl) {
                  _this.trySetLastSelectedItemAsActive();
                }

                break;

              case keyboardKey.ArrowRight:
                if (rtl) {
                  _this.trySetLastSelectedItemAsActive();
                }

                break;

              case keyboardKey.Backspace:
                _this.tryRemoveItemFromValue();

                break;

              default:
                break;
            }
          }

          _invoke(predefinedProps, 'onInputKeyDown', e, Object.assign({}, searchInputProps, {
            highlightedIndex: highlightedIndex,
            selectItemAtIndex: selectItemAtIndex
          }));
        };

        return {
          // getInputProps adds Downshift handlers. We also add our own by passing them as params to that function.
          // user handlers were also added to our handlers previously, at the beginning of this function.
          accessibilityInputProps: Object.assign({}, getInputProps({
            disabled: disabled,
            onBlur: function onBlur(e) {
              handleInputBlur(e, predefinedProps);
            },
            onKeyDown: function onKeyDown(e) {
              handleInputKeyDown(e, predefinedProps);
            },
            onChange: function onChange(e) {
              // we prevent the onChange input event to bubble up to our Dropdown handler,
              // since in Dropdown it gets handled as onSearchQueryChange.
              e.stopPropagation();
            }
          })),
          // same story as above for getRootProps.
          accessibilityComboboxProps: accessibilityComboboxProps,
          onFocus: function onFocus(e, searchInputProps) {
            if (!disabled) {
              _this.setState({
                focused: true,
                isFromKeyboard: isFromKeyboard()
              });
            }

            _invoke(predefinedProps, 'onFocus', e, searchInputProps);
          },
          onInputBlur: function onInputBlur(e, searchInputProps) {
            handleInputBlur(e, searchInputProps);
          },
          onInputKeyDown: function onInputKeyDown(e, searchInputProps) {
            handleInputKeyDown(e, searchInputProps);
          }
        };
      };
    });

    _defineProperty(_assertThisInitialized(_this), "handleTabSelection", function (e, highlightedIndex, selectItemAtIndex, toggleMenu) {
      var _this$state2 = _this.state,
          open = _this$state2.open,
          filteredItems = _this$state2.filteredItems;
      var _this$props2 = _this.props,
          moveFocusOnTab = _this$props2.moveFocusOnTab,
          multiple = _this$props2.multiple,
          items = _this$props2.items;

      if (open) {
        if (!_isNil(highlightedIndex) && filteredItems.length && !items[highlightedIndex]['disabled']) {
          selectItemAtIndex(highlightedIndex);

          if (multiple && !moveFocusOnTab) {
            e.preventDefault();
          }
        } else {
          toggleMenu();
        }
      }
    });

    _defineProperty(_assertThisInitialized(_this), "trySetLastSelectedItemAsActive", function () {
      var multiple = _this.props.multiple;
      var value = _this.state.value;

      if (!multiple || _this.inputRef.current && _this.inputRef.current.selectionStart !== 0) {
        return;
      }

      if (value.length > 0) {
        // If last element was already active, perform a 'reset' of activeSelectedIndex.
        if (_this.state.activeSelectedIndex === value.length - 1) {
          _this.setState({
            activeSelectedIndex: null
          }, function () {
            _this.setStateAndInvokeHandler(['onActiveSelectedIndexChange'], null, {
              activeSelectedIndex: value.length - 1
            });
          });
        } else {
          _this.setStateAndInvokeHandler(['onActiveSelectedIndexChange'], null, {
            activeSelectedIndex: value.length - 1
          });
        }
      }
    });

    _defineProperty(_assertThisInitialized(_this), "tryRemoveItemFromValue", function () {
      var multiple = _this.props.multiple;
      var _this$state3 = _this.state,
          searchQuery = _this$state3.searchQuery,
          value = _this$state3.value;
      var inputElement = _this.inputRef.current;

      if (multiple && (searchQuery === '' || inputElement.selectionStart === 0 && inputElement.selectionEnd === 0) && value.length > 0) {
        _this.removeItemFromValue();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleClear", function (e) {
      var _this$getInitialAutoC = _this.getInitialAutoControlledState(_this.props),
          activeSelectedIndex = _this$getInitialAutoC.activeSelectedIndex,
          highlightedIndex = _this$getInitialAutoC.highlightedIndex,
          open = _this$getInitialAutoC.open,
          searchQuery = _this$getInitialAutoC.searchQuery,
          value = _this$getInitialAutoC.value;

      _this.setStateAndInvokeHandler(['onChange', 'onActiveSelectedIndexChange', 'onHighlightedIndexChange'], e, {
        activeSelectedIndex: activeSelectedIndex,
        highlightedIndex: highlightedIndex,
        open: open,
        searchQuery: searchQuery,
        value: value
      });

      _this.tryFocusSearchInput();

      _this.tryFocusTriggerButton();
    });

    _defineProperty(_assertThisInitialized(_this), "handleContainerClick", function () {
      _this.tryFocusSearchInput();
    });

    _defineProperty(_assertThisInitialized(_this), "handleTriggerButtonKeyDown", function (e, rtl) {
      switch (keyboardKey.getCode(e)) {
        case keyboardKey.ArrowLeft:
          if (!rtl) {
            _this.trySetLastSelectedItemAsActive();
          }

          return;

        case keyboardKey.ArrowRight:
          if (rtl) {
            _this.trySetLastSelectedItemAsActive();
          }

          return;

        default:
          return;
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleListKeyDown", function (e, highlightedIndex, accessibilityInputPropsKeyDown, toggleMenu, selectItemAtIndex) {
      var keyCode = keyboardKey.getCode(e);

      switch (keyCode) {
        case keyboardKey.Tab:
          _this.handleTabSelection(e, highlightedIndex, selectItemAtIndex, toggleMenu);

          return;

        case keyboardKey.Escape:
          accessibilityInputPropsKeyDown(e);

          _this.tryFocusTriggerButton();

          e.stopPropagation();
          return;

        default:
          var keyString = String.fromCharCode(keyCode);

          if (/[a-zA-Z0-9]/.test(keyString)) {
            _this.setHighlightedIndexOnCharKeyDown(keyString);
          }

          accessibilityInputPropsKeyDown(e);
          return;
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleTriggerButtonOrListFocus", function () {
      _this.setState({
        focused: true,
        isFromKeyboard: isFromKeyboard()
      });
    });

    _defineProperty(_assertThisInitialized(_this), "handleTriggerButtonBlur", function (e) {
      if (_this.listRef.current !== e.relatedTarget) {
        _this.setState({
          focused: false,
          isFromKeyboard: isFromKeyboard()
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleListBlur", function (e) {
      if (_this.buttonRef.current !== e.relatedTarget) {
        _this.setState({
          focused: false,
          isFromKeyboard: isFromKeyboard()
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "setHighlightedIndexOnCharKeyDown", function (keyString) {
      var _this$state4 = _this.state,
          highlightedIndex = _this$state4.highlightedIndex,
          filteredItemStrings = _this$state4.filteredItemStrings,
          startingString = _this$state4.startingString;
      var newStartingString = "".concat(startingString).concat(keyString.toLowerCase());
      var newHighlightedIndex = -1;

      _this.setStartingString(newStartingString);

      if (_isNumber(highlightedIndex)) {
        newHighlightedIndex = _findIndex(filteredItemStrings, function (item) {
          return item.startsWith(newStartingString);
        }, highlightedIndex + (startingString.length > 0 ? 0 : 1));
      }

      if (newHighlightedIndex < 0) {
        newHighlightedIndex = _findIndex(filteredItemStrings, function (item) {
          return item.startsWith(newStartingString);
        });
      }

      if (newHighlightedIndex >= 0) {
        _this.setStateAndInvokeHandler(['onHighlightedIndexChange'], null, {
          highlightedIndex: newHighlightedIndex
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "setStateAndInvokeHandler", function (handlerNames, event, newState) {
      var proposedValue = _isNil(newState.value) ? _this.state.value : newState.value; // `proposedValue` should be normalized for single/multiple variations, `null` condition is
      // required as first item can be undefined

      var newValue = _this.props.multiple ? proposedValue : proposedValue[0] || null;

      _this.setState(newState);

      handlerNames.forEach(function (handlerName) {
        _invoke(_this.props, handlerName, event, Object.assign({}, _this.props, {}, newState, {
          value: newValue
        }));
      });
    });

    _defineProperty(_assertThisInitialized(_this), "tryFocusTriggerButton", function () {
      if (!_this.props.search && _this.buttonRef.current) {
        _this.buttonRef.current.focus();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "tryFocusSearchInput", function () {
      if (_this.props.search && _this.inputRef.current) {
        _this.inputRef.current.focus();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "getSelectedItemAsString", function (value) {
      var _this$props3 = _this.props,
          itemToString = _this$props3.itemToString,
          multiple = _this$props3.multiple,
          placeholder = _this$props3.placeholder,
          search = _this$props3.search;

      if (!value) {
        return search ? '' : placeholder;
      }

      if (multiple) {
        return '';
      }

      return itemToString(value);
    });

    _defineProperty(_assertThisInitialized(_this), "getHighlightedIndexOnArrowKeyOpen", function (changes) {
      var _this$state5 = _this.state,
          filteredItems = _this$state5.filteredItems,
          highlightedIndex = _this$state5.highlightedIndex,
          value = _this$state5.value;
      var _this$props4 = _this.props,
          highlightFirstItemOnOpen = _this$props4.highlightFirstItemOnOpen,
          items = _this$props4.items,
          multiple = _this$props4.multiple,
          search = _this$props4.search;
      var isArrowUp = changes.type === Downshift.stateChangeTypes.keyDownArrowUp;
      var isArrowDown = changes.type === Downshift.stateChangeTypes.keyDownArrowDown;
      var itemsLength = filteredItems.length;

      if (highlightedIndex) {
        return highlightedIndex;
      }

      if (highlightFirstItemOnOpen) {
        // otherwise, if highlightFirstItemOnOpen prop is provied, highlight first item.
        return 0;
      }

      if (!multiple && !search && value.length > 0) {
        // in single selection, if there is a selected item, highlight it.
        var offset = isArrowUp ? -1 : isArrowDown ? 1 : 0;
        var newHighlightedIndex = items.indexOf(value[0]) + offset;

        if (newHighlightedIndex >= itemsLength) {
          return 0;
        }

        if (newHighlightedIndex < 0) {
          return itemsLength - 1;
        }

        return newHighlightedIndex;
      }

      if (isArrowDown) {
        return 0;
      }

      if (isArrowUp) {
        return itemsLength - 1;
      }

      return null;
    });

    _defineProperty(_assertThisInitialized(_this), "setA11ySelectionMessage", function (a11ySelectionStatus) {
      _this.setState({
        a11ySelectionStatus: a11ySelectionStatus
      });

      _this.clearA11ySelectionMessage();
    });

    _defineProperty(_assertThisInitialized(_this), "setStartingString", function (startingString) {
      _this.setState({
        startingString: startingString
      });

      _this.clearStartingString();
    });

    _defineProperty(_assertThisInitialized(_this), "clearA11ySelectionMessage", _debounce(function () {
      _this.setState({
        a11ySelectionStatus: ''
      });
    }, Dropdown.a11yStatusCleanupTime));

    _defineProperty(_assertThisInitialized(_this), "clearStartingString", _debounce(function () {
      _this.setState({
        startingString: ''
      });
    }, Dropdown.charKeyPressedCleanupTime));

    return _this;
  }

  _createClass(Dropdown, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.clearStartingString.cancel();
      this.clearA11ySelectionMessage.cancel();
    }
  }, {
    key: "getInitialAutoControlledState",
    value: function getInitialAutoControlledState(_ref) {
      var multiple = _ref.multiple,
          search = _ref.search;
      return {
        a11ySelectionStatus: '',
        activeSelectedIndex: multiple ? null : undefined,
        filteredItems: undefined,
        filteredItemStrings: undefined,
        focused: false,
        startingString: search ? undefined : '',
        open: false,
        highlightedIndex: this.props.highlightFirstItemOnOpen ? 0 : null,
        searchQuery: search ? '' : undefined,
        value: [],
        itemIsFromKeyboard: false,
        isFromKeyboard: false
      };
    }
  }, {
    key: "renderComponent",
    value: function renderComponent(_ref2) {
      var _this$context$target,
          _this2 = this;

      var ElementType = _ref2.ElementType,
          classes = _ref2.classes,
          styles = _ref2.styles,
          variables = _ref2.variables,
          unhandledProps = _ref2.unhandledProps,
          rtl = _ref2.rtl;
      var _this$props5 = this.props,
          clearable = _this$props5.clearable,
          clearIndicator = _this$props5.clearIndicator,
          disabled = _this$props5.disabled,
          search = _this$props5.search,
          multiple = _this$props5.multiple,
          getA11yStatusMessage = _this$props5.getA11yStatusMessage,
          itemToString = _this$props5.itemToString,
          toggleIndicator = _this$props5.toggleIndicator;
      var _this$state6 = this.state,
          highlightedIndex = _this$state6.highlightedIndex,
          open = _this$state6.open,
          searchQuery = _this$state6.searchQuery,
          value = _this$state6.value;
      return React.createElement(ElementType, _extends({
        className: classes.root,
        onChange: this.handleChange
      }, unhandledProps), React.createElement(Downshift, {
        isOpen: open,
        inputValue: search ? searchQuery : null,
        stateReducer: this.downshiftStateReducer,
        itemToString: itemToString // downshift does not work with arrays as selectedItem.
        ,
        selectedItem: multiple || !value.length ? null : value[0],
        getA11yStatusMessage: getA11yStatusMessage,
        highlightedIndex: highlightedIndex,
        onStateChange: this.handleStateChange,
        labelId: this.props['aria-labelledby'],
        environment: (_this$context$target = this.context.target) === null || _this$context$target === void 0 ? void 0 : _this$context$target.defaultView,
        inputId: this.props.searchInput && this.props.searchInput['id'] ? this.props.searchInput['id'] : undefined
      }, function (_ref3) {
        var getInputProps = _ref3.getInputProps,
            getItemProps = _ref3.getItemProps,
            getMenuProps = _ref3.getMenuProps,
            getRootProps = _ref3.getRootProps,
            getToggleButtonProps = _ref3.getToggleButtonProps,
            toggleMenu = _ref3.toggleMenu,
            highlightedIndex = _ref3.highlightedIndex,
            selectItemAtIndex = _ref3.selectItemAtIndex;

        var _getRootProps = getRootProps({
          refKey: 'innerRef'
        }, {
          suppressRefError: true
        }),
            innerRef = _getRootProps.innerRef,
            accessibilityRootPropsRest = _objectWithoutProperties(_getRootProps, ["innerRef"]);

        var showClearIndicator = clearable && value.length > 0;
        return React.createElement(Ref, {
          innerRef: innerRef
        }, React.createElement("div", {
          ref: _this2.containerRef,
          className: cx(dropdownSlotClassNames.container, classes.container),
          onClick: search && !open ? _this2.handleContainerClick : undefined
        }, React.createElement("div", {
          ref: _this2.selectedItemsRef,
          className: cx(dropdownSlotClassNames.selectedItems, classes.selectedItems)
        }, multiple && _this2.renderSelectedItems(variables, rtl), search ? _this2.renderSearchInput(accessibilityRootPropsRest, rtl, highlightedIndex, getInputProps, selectItemAtIndex, toggleMenu, variables) : _this2.renderTriggerButton(styles, rtl, getToggleButtonProps)), showClearIndicator ? Box.create(clearIndicator, {
          defaultProps: function defaultProps() {
            return Object.assign({
              className: dropdownSlotClassNames.clearIndicator,
              styles: styles.clearIndicator,
              accessibility: indicatorBehavior
            }, !search && {
              tabIndex: 0,
              role: 'button'
            });
          },
          overrideProps: function overrideProps(predefinedProps) {
            return {
              onClick: function onClick(e) {
                _invoke(predefinedProps, 'onClick', e);

                _this2.handleClear(e);
              }
            };
          }
        }) : Box.create(toggleIndicator, {
          defaultProps: function defaultProps() {
            return {
              className: dropdownSlotClassNames.toggleIndicator,
              styles: styles.toggleIndicator,
              accessibility: indicatorBehavior
            };
          },
          overrideProps: function overrideProps(predefinedProps) {
            return {
              onClick: function onClick(e) {
                if (!disabled) {
                  getToggleButtonProps({
                    disabled: disabled
                  }).onClick(e);
                }

                _invoke(predefinedProps, 'onClick', e);
              }
            };
          }
        }), _this2.renderItemsList(styles, variables, highlightedIndex, toggleMenu, selectItemAtIndex, getMenuProps, getItemProps, getInputProps, rtl)));
      }), React.createElement(Portal, {
        open: !!this.props.getA11ySelectionMessage
      }, React.createElement("div", {
        role: "status",
        "aria-live": "polite",
        "aria-relevant": "additions text",
        style: screenReaderContainerStyles
      }, this.state.a11ySelectionStatus)));
    }
  }, {
    key: "renderTriggerButton",
    value: function renderTriggerButton(styles, rtl, getToggleButtonProps) {
      var _this3 = this;

      var _this$props6 = this.props,
          triggerButton = _this$props6.triggerButton,
          disabled = _this$props6.disabled;
      var value = this.state.value;
      var content = this.getSelectedItemAsString(value[0]);
      var triggerButtonId = triggerButton['id'] || this.defaultTriggerButtonId;
      var triggerButtonProps = getToggleButtonProps({
        disabled: disabled,
        onFocus: this.handleTriggerButtonOrListFocus,
        onBlur: this.handleTriggerButtonBlur,
        onKeyDown: function onKeyDown(e) {
          _this3.handleTriggerButtonKeyDown(e, rtl);
        },
        'aria-label': undefined,
        'aria-labelledby': [this.props['aria-labelledby'], triggerButtonId].filter(function (l) {
          return !!l;
        }).join(' ')
      });

      var _onClick = triggerButtonProps.onClick,
          _onFocus = triggerButtonProps.onFocus,
          _onBlur = triggerButtonProps.onBlur,
          _onKeyDown = triggerButtonProps.onKeyDown,
          restTriggerButtonProps = _objectWithoutProperties(triggerButtonProps, ["onClick", "onFocus", "onBlur", "onKeyDown"]);

      return React.createElement(Ref, {
        innerRef: this.buttonRef
      }, createShorthand(Button, triggerButton, {
        defaultProps: function defaultProps() {
          return Object.assign({
            className: dropdownSlotClassNames.triggerButton,
            content: content,
            disabled: disabled,
            id: triggerButtonId,
            fluid: true,
            styles: styles.triggerButton
          }, restTriggerButtonProps);
        },
        overrideProps: function overrideProps(predefinedProps) {
          return {
            onClick: function onClick(e) {
              _onClick(e);

              _invoke(predefinedProps, 'onClick', e, predefinedProps);
            },
            onFocus: function onFocus(e) {
              _onFocus(e);

              _invoke(predefinedProps, 'onFocus', e, predefinedProps);
            },
            onBlur: function onBlur(e) {
              if (!disabled) {
                _onBlur(e);
              }

              _invoke(predefinedProps, 'onBlur', e, predefinedProps);
            },
            onKeyDown: function onKeyDown(e) {
              if (!disabled) {
                _onKeyDown(e);
              }

              _invoke(predefinedProps, 'onKeyDown', e, predefinedProps);
            }
          };
        }
      }));
    }
  }, {
    key: "renderSearchInput",
    value: function renderSearchInput(accessibilityComboboxProps, rtl, highlightedIndex, getInputProps, selectItemAtIndex, toggleMenu, variables) {
      var _this4 = this;

      var _this$props7 = this.props,
          inline = _this$props7.inline,
          searchInput = _this$props7.searchInput,
          multiple = _this$props7.multiple,
          placeholder = _this$props7.placeholder,
          disabled = _this$props7.disabled;
      var _this$state7 = this.state,
          searchQuery = _this$state7.searchQuery,
          value = _this$state7.value;
      var noPlaceholder = searchQuery.length > 0 || multiple && value.length > 0;
      return DropdownSearchInput.create(searchInput || {}, {
        defaultProps: function defaultProps() {
          return {
            className: dropdownSlotClassNames.searchInput,
            placeholder: noPlaceholder ? '' : placeholder,
            inline: inline,
            variables: variables,
            inputRef: _this4.inputRef,
            disabled: disabled
          };
        },
        overrideProps: this.handleSearchInputOverrides(highlightedIndex, rtl, selectItemAtIndex, toggleMenu, accessibilityComboboxProps, getInputProps)
      });
    }
  }, {
    key: "renderItemsList",
    value: function renderItemsList(styles, variables, highlightedIndex, toggleMenu, selectItemAtIndex, getMenuProps, getItemProps, getInputProps, rtl) {
      var _this5 = this;

      var _this$props8 = this.props,
          align = _this$props8.align,
          offset = _this$props8.offset,
          position = _this$props8.position,
          search = _this$props8.search,
          unstable_pinned = _this$props8.unstable_pinned,
          list = _this$props8.list;
      var open = this.state.open;
      var items = open ? this.renderItems(styles, variables, getItemProps, highlightedIndex) : [];

      var _getMenuProps = getMenuProps({
        refKey: 'innerRef'
      }, {
        suppressRefError: true
      }),
          _innerRef = _getMenuProps.innerRef,
          accessibilityMenuProps = _objectWithoutProperties(_getMenuProps, ["innerRef"]); // If it's just a selection, some attributes and listeners from Downshift input need to go on the menu list.


      if (!search) {
        var accessibilityInputProps = getInputProps();
        accessibilityMenuProps['aria-activedescendant'] = accessibilityInputProps['aria-activedescendant'];

        accessibilityMenuProps['onKeyDown'] = function (e) {
          _this5.handleListKeyDown(e, highlightedIndex, accessibilityInputProps['onKeyDown'], toggleMenu, selectItemAtIndex);
        };
      }

      return React.createElement(Ref, {
        innerRef: function innerRef(listElement) {
          handleRef(_this5.listRef, listElement);
          handleRef(_innerRef, listElement);
        }
      }, React.createElement(Popper, _extends({
        align: align,
        position: position,
        offset: offset,
        rtl: rtl,
        enabled: open,
        targetRef: this.containerRef,
        unstable_pinned: unstable_pinned,
        positioningDependencies: [items.length]
      }, getPopperPropsFromShorthand(list)), List.create(list, {
        defaultProps: function defaultProps() {
          return Object.assign({
            className: dropdownSlotClassNames.itemsList
          }, accessibilityMenuProps, {
            styles: styles.list,
            items: items,
            tabIndex: search ? undefined : -1,
            // needs to be focused when trigger button is activated.
            'aria-hidden': !open
          });
        },
        overrideProps: function overrideProps(predefinedProps) {
          return {
            onFocus: function onFocus(e, listProps) {
              _this5.handleTriggerButtonOrListFocus();

              _invoke(predefinedProps, 'onClick', e, listProps);
            },
            onBlur: function onBlur(e, listProps) {
              _this5.handleListBlur(e);

              _invoke(predefinedProps, 'onBlur', e, listProps);
            }
          };
        }
      })));
    }
  }, {
    key: "renderItems",
    value: function renderItems(styles, variables, getItemProps, highlightedIndex) {
      var _this6 = this;

      var _this$props9 = this.props,
          renderItem = _this$props9.renderItem,
          checkable = _this$props9.checkable,
          checkableIndicator = _this$props9.checkableIndicator;
      var _this$state8 = this.state,
          filteredItems = _this$state8.filteredItems,
          value = _this$state8.value;
      var footerItem = this.renderItemsListFooter(styles);
      var headerItem = this.renderItemsListHeader(styles);

      var items = _map(filteredItems, function (item, index) {
        return {
          children: function children() {
            var selected = value.indexOf(item) !== -1;
            return DropdownItem.create(item, {
              defaultProps: function defaultProps() {
                return Object.assign({
                  className: dropdownSlotClassNames.item,
                  active: highlightedIndex === index,
                  selected: selected,
                  checkable: checkable,
                  checkableIndicator: checkableIndicator,
                  isFromKeyboard: _this6.state.itemIsFromKeyboard,
                  variables: variables
                }, _typeof(item) === 'object' && !item.hasOwnProperty('key') && {
                  key: item.header
                });
              },
              overrideProps: _this6.handleItemOverrides(item, index, getItemProps, selected),
              render: renderItem
            });
          }
        };
      });

      if (footerItem) {
        items.push(footerItem);
      }

      return headerItem ? [headerItem].concat(_toConsumableArray(items)) : items;
    }
  }, {
    key: "renderItemsListHeader",
    value: function renderItemsListHeader(styles) {
      var headerMessage = this.props.headerMessage;

      if (headerMessage) {
        return {
          children: function children() {
            return DropdownItem.create(headerMessage, {
              defaultProps: function defaultProps() {
                return {
                  key: 'items-list-footer-message',
                  styles: styles.headerMessage
                };
              }
            });
          }
        };
      }

      return null;
    }
  }, {
    key: "renderItemsListFooter",
    value: function renderItemsListFooter(styles) {
      var _this$props10 = this.props,
          loading = _this$props10.loading,
          loadingMessage = _this$props10.loadingMessage,
          noResultsMessage = _this$props10.noResultsMessage,
          items = _this$props10.items;

      if (loading) {
        return {
          children: function children() {
            return DropdownItem.create(loadingMessage, {
              defaultProps: function defaultProps() {
                return {
                  key: 'loading-message',
                  styles: styles.loadingMessage
                };
              }
            });
          }
        };
      }

      if (items && items.length === 0) {
        return {
          children: function children() {
            return DropdownItem.create(noResultsMessage, {
              defaultProps: function defaultProps() {
                return {
                  key: 'no-results-message',
                  styles: styles.noResultsMessage
                };
              }
            });
          }
        };
      }

      return null;
    }
  }, {
    key: "renderSelectedItems",
    value: function renderSelectedItems(variables, rtl) {
      var _this7 = this;

      var renderSelectedItem = this.props.renderSelectedItem;
      var value = this.state.value;

      if (value.length === 0) {
        return null;
      }

      return value.map(function (item, index) {
        return (// (!) an item matches DropdownItemProps
          DropdownSelectedItem.create(item, {
            defaultProps: function defaultProps() {
              return Object.assign({
                className: dropdownSlotClassNames.selectedItem,
                active: _this7.isSelectedItemActive(index),
                variables: variables
              }, _typeof(item) === 'object' && !item.hasOwnProperty('key') && {
                key: item.header
              });
            },
            overrideProps: _this7.handleSelectedItemOverrides(item, rtl),
            render: renderSelectedItem
          })
        );
      });
    }
  }, {
    key: "handleSelectedItemKeyDown",
    value: function handleSelectedItemKeyDown(e, item, predefinedProps, dropdownSelectedItemProps, rtl) {
      var _this$state9 = this.state,
          activeSelectedIndex = _this$state9.activeSelectedIndex,
          value = _this$state9.value;
      var previousKey = rtl ? keyboardKey.ArrowRight : keyboardKey.ArrowLeft;
      var nextKey = rtl ? keyboardKey.ArrowLeft : keyboardKey.ArrowRight;

      switch (keyboardKey.getCode(e)) {
        case keyboardKey.Delete:
        case keyboardKey.Backspace:
          this.handleSelectedItemRemove(e, item, predefinedProps, dropdownSelectedItemProps);
          break;

        case previousKey:
          if (value.length > 0 && !_isNil(activeSelectedIndex) && activeSelectedIndex > 0) {
            this.setStateAndInvokeHandler(['onActiveSelectedIndexChange'], null, {
              activeSelectedIndex: activeSelectedIndex - 1
            });
          }

          break;

        case nextKey:
          if (value.length > 0 && !_isNil(activeSelectedIndex)) {
            if (activeSelectedIndex < value.length - 1) {
              this.setState({
                activeSelectedIndex: activeSelectedIndex + 1
              });
            } else {
              this.setState({
                activeSelectedIndex: null
              });

              if (this.props.search) {
                e.preventDefault(); // prevents caret to forward one position in input.

                this.inputRef.current.focus();
              } else {
                this.buttonRef.current.focus();
              }
            }
          }

          break;

        default:
          break;
      }

      _invoke(predefinedProps, 'onKeyDown', e, dropdownSelectedItemProps);
    }
  }, {
    key: "handleSelectedItemRemove",
    value: function handleSelectedItemRemove(e, item, predefinedProps, dropdownSelectedItemProps) {
      this.setStateAndInvokeHandler(['onActiveSelectedIndexChange'], null, {
        activeSelectedIndex: null
      });
      this.removeItemFromValue(item);
      this.tryFocusSearchInput();
      this.tryFocusTriggerButton();

      _invoke(predefinedProps, 'onRemove', e, dropdownSelectedItemProps);
    }
  }, {
    key: "removeItemFromValue",
    value: function removeItemFromValue(item) {
      var getA11ySelectionMessage = this.props.getA11ySelectionMessage;
      var value = this.state.value;
      var poppedItem = item;

      if (poppedItem) {
        value = value.filter(function (currentElement) {
          return currentElement !== item;
        });
      } else {
        poppedItem = value.pop();
      }

      if (getA11ySelectionMessage && getA11ySelectionMessage.onRemove) {
        this.setA11ySelectionMessage(getA11ySelectionMessage.onRemove(poppedItem));
      }

      this.setStateAndInvokeHandler(['onChange'], null, {
        value: value
      });
    }
    /**
     * Calls setState and invokes event handler exposed to user.
     * We don't have the event object for most events coming from Downshift se we send an empty event
     * because we want to keep the event handling interface
     */

  }], [{
    key: "getAutoControlledStateFromProps",

    /**
     * Used to compute the filtered items (by value and search query) and, if needed,
     * their string equivalents, in order to be used throughout the component.
     */
    value: function getAutoControlledStateFromProps(props, state) {
      var items = props.items,
          itemToString = props.itemToString,
          itemToValue = props.itemToValue,
          multiple = props.multiple,
          search = props.search;
      var searchQuery = state.searchQuery,
          rawValue = state.value; // `normalizedValue` should be normilized always as it can be received from props

      var normalizedValue = _isArray(rawValue) ? rawValue : [rawValue];
      var value = multiple ? normalizedValue : normalizedValue.slice(0, 1);
      var filteredItemsByValue = multiple ? _differenceBy(items, value, itemToValue) : items;

      var filteredItemStrings = _map(filteredItemsByValue, function (filteredItem) {
        return itemToString(filteredItem).toLowerCase();
      });

      var modifiedState = {
        filteredItems: filteredItemsByValue,
        filteredItemStrings: filteredItemStrings,
        value: value
      };

      if (search) {
        if (_isFunction(search)) {
          modifiedState.filteredItems = search(filteredItemsByValue, searchQuery);
        } else {
          modifiedState.filteredItems = filteredItemsByValue.filter(function (item) {
            return itemToString(item).toLowerCase().indexOf(searchQuery.toLowerCase()) !== -1;
          });
        }
      }

      return modifiedState;
    }
  }]);

  return Dropdown;
}(AutoControlledComponent);
/**
 * A Dropdown allows user to select one or more values from a list of options.
 * Can be created with search and multi-selection capabilities.
 *
 * @accessibility
 * Implements [ARIA Combo Box](https://www.w3.org/TR/wai-aria-practices-1.1/#combobox) design pattern, uses aria-live to announce state changes.
 * @accessibilityIssues
 * [Issue 991203: VoiceOver doesn't narrate properly elements in the input/combobox](https://bugs.chromium.org/p/chromium/issues/detail?id=991203)
 */


_defineProperty(Dropdown, "displayName", 'Dropdown');

_defineProperty(Dropdown, "deprecated_className", dropdownClassName);

_defineProperty(Dropdown, "a11yStatusCleanupTime", 500);

_defineProperty(Dropdown, "charKeyPressedCleanupTime", 500);

_defineProperty(Dropdown, "propTypes", Object.assign({}, commonPropTypes.createCommon({
  accessibility: false,
  children: false,
  content: false
}), {
  activeSelectedIndex: PropTypes.number,
  align: PropTypes.oneOf(ALIGNMENTS),
  checkable: PropTypes.bool,
  checkableIndicator: customPropTypes.shorthandAllowingChildren,
  clearable: PropTypes.bool,
  clearIndicator: customPropTypes.shorthandAllowingChildren,
  defaultActiveSelectedIndex: PropTypes.number,
  defaultOpen: PropTypes.bool,
  defaultHighlightedIndex: PropTypes.number,
  defaultSearchQuery: PropTypes.string,
  defaultValue: PropTypes.oneOfType([customPropTypes.itemShorthand, customPropTypes.collectionShorthand]),
  disabled: PropTypes.bool,
  fluid: PropTypes.bool,
  getA11ySelectionMessage: PropTypes.object,
  getA11yStatusMessage: PropTypes.func,
  highlightFirstItemOnOpen: PropTypes.bool,
  highlightedIndex: PropTypes.number,
  inline: PropTypes.bool,
  inverted: PropTypes.bool,
  items: customPropTypes.collectionShorthand,
  itemToString: PropTypes.func,
  itemToValue: PropTypes.func,
  headerMessage: customPropTypes.itemShorthand,
  list: customPropTypes.itemShorthand,
  loading: PropTypes.bool,
  loadingMessage: customPropTypes.itemShorthand,
  moveFocusOnTab: PropTypes.bool,
  multiple: PropTypes.bool,
  noResultsMessage: customPropTypes.itemShorthand,
  offset: PropTypes.oneOfType([PropTypes.func, PropTypes.arrayOf(PropTypes.number)]),
  onOpenChange: PropTypes.func,
  onSearchQueryChange: PropTypes.func,
  onChange: PropTypes.func,
  onActiveSelectedIndexChange: PropTypes.func,
  onHighlightedIndexChange: PropTypes.func,
  open: PropTypes.bool,
  placeholder: PropTypes.string,
  position: PropTypes.oneOf(POSITIONS),
  renderItem: PropTypes.func,
  renderSelectedItem: PropTypes.func,
  search: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),
  searchQuery: PropTypes.string,
  searchInput: customPropTypes.itemShorthand,
  toggleIndicator: customPropTypes.shorthandAllowingChildren,
  triggerButton: customPropTypes.itemShorthand,
  unstable_pinned: PropTypes.bool,
  value: PropTypes.oneOfType([customPropTypes.itemShorthand, customPropTypes.collectionShorthand])
}));

_defineProperty(Dropdown, "defaultProps", {
  align: 'start',
  as: 'div',
  clearIndicator: {},
  itemToString: function itemToString(item) {
    if (!item || React.isValidElement(item)) {
      return '';
    } // targets DropdownItem shorthand objects


    return item.header || String(item);
  },
  itemToValue: function itemToValue(item) {
    if (!item || React.isValidElement(item)) {
      return '';
    } // targets DropdownItem shorthand objects


    return item.header || String(item);
  },
  list: {},
  position: 'below',
  toggleIndicator: {},
  triggerButton: {}
});

_defineProperty(Dropdown, "autoControlledProps", ['activeSelectedIndex', 'highlightedIndex', 'open', 'searchQuery', 'value']);

_defineProperty(Dropdown, "Item", DropdownItem);

_defineProperty(Dropdown, "SearchInput", DropdownSearchInput);

_defineProperty(Dropdown, "SelectedItem", DropdownSelectedItem);

export default withSafeTypeForAs(Dropdown);
//# sourceMappingURL=Dropdown.js.map
