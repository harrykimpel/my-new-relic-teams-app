import _extends from "@babel/runtime/helpers/esm/extends";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _invoke from "lodash/invoke";
import _reduce from "lodash/reduce";
import _forEach from "lodash/forEach";
import { treeBehavior } from '@fluentui/accessibility';
import { getNextElement } from '@fluentui/react-bindings';
import * as customPropTypes from '@fluentui/react-proptypes';
import * as PropTypes from 'prop-types';
import * as React from 'react';
import { Ref } from '@fluentui/react-component-ref';
import TreeItem from './TreeItem';
import TreeTitle from './TreeTitle';
import { childrenExist, commonPropTypes, createShorthandFactory, rtlTextContainer, applyAccessibilityKeyHandlers, AutoControlledComponent } from '../../utils';
import { withSafeTypeForAs } from '../../types';
import { hasSubtree, removeItemAtIndex, getSiblings, TreeContext } from './utils';
export var treeClassName = 'ui-tree';

var Tree =
/*#__PURE__*/
function (_AutoControlledCompon) {
  _inherits(Tree, _AutoControlledCompon);

  function Tree() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, Tree);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Tree)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "treeRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "itemsRef", new Map());

    _defineProperty(_assertThisInitialized(_this), "onFocusParent", function (parent) {
      var parentRef = _this.itemsRef.get(parent);

      if (!parentRef || !parentRef.current) {
        return;
      }

      parentRef.current.focus();
    });

    _defineProperty(_assertThisInitialized(_this), "setSelectedItemIds", function (e, selectedItemIds) {
      _invoke(_this.props, 'onSelectedItemIdsChange', e, Object.assign({}, _this.props, {
        selectedItemIds: selectedItemIds
      }));

      _this.setState({
        selectedItemIds: selectedItemIds
      });
    });

    _defineProperty(_assertThisInitialized(_this), "processItemsForSelection", function (e, treeItemProps, executeSelection) {
      var selectedItemIds = _this.state.selectedItemIds;
      var id = treeItemProps.id,
          selectableParent = treeItemProps.selectableParent,
          items = treeItemProps.items,
          expanded = treeItemProps.expanded;
      var treeItemHasSubtree = hasSubtree(treeItemProps);
      var isExpandedSelectableParent = treeItemHasSubtree && selectableParent && expanded; // parent must be selectable and expanded in order to procced with selection, otherwise return

      if (treeItemHasSubtree && !(selectableParent && expanded)) {
        return;
      } // if the target is equal to currentTarget it means treeItem should be collapsed, not procced with selection


      if (treeItemHasSubtree && e.target === e.currentTarget && !executeSelection) {
        return;
      } // push all tree items under particular parent into selection array
      // not parent itself, therefore not procced with selection


      if (isExpandedSelectableParent) {
        if (_this.isAllGroupChecked(items)) {
          var selectedItems = _this.getAllSelectableChildrenId(items);

          selectedItemIds = selectedItemIds.filter(function (id) {
            return selectedItems.indexOf(id) === -1;
          });
        } else {
          var selectItems = function selectItems(items) {
            items.forEach(function (item) {
              var selectble = item.hasOwnProperty('selectable') ? item.selectable : treeItemProps.selectable;

              if (selectedItemIds.indexOf(item.id) === -1) {
                if (item.items) {
                  selectItems(item.items);
                } else if (selectble) {
                  selectedItemIds.push(item.id);
                }
              }
            });
          };

          selectItems(items);
        }

        _this.setSelectedItemIds(e, selectedItemIds);

        return;
      } // push/remove single tree item into selection array


      if (selectedItemIds.indexOf(id) === -1) {
        selectedItemIds.push(id);
      } else {
        selectedItemIds = selectedItemIds.filter(function (itemID) {
          return itemID !== id;
        });
      }

      _this.setSelectedItemIds(e, selectedItemIds);
    });

    _defineProperty(_assertThisInitialized(_this), "onTitleClick", function (e, treeItemProps) {
      var executeSelection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var treeItemHasSubtree = hasSubtree(treeItemProps);

      if (!treeItemProps) {
        return;
      }

      if (treeItemProps.selectable) {
        _this.processItemsForSelection(e, treeItemProps, executeSelection);
      }

      if (treeItemHasSubtree && !executeSelection && e.target === e.currentTarget) {
        _this.expandItems(e, treeItemProps);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "onFocusFirstChild", function (itemId) {
      var currentElement = _this.itemsRef.get(itemId);

      if (!currentElement || !currentElement.current) {
        return;
      }

      var elementToBeFocused = getNextElement(_this.treeRef.current, currentElement.current);

      if (!elementToBeFocused) {
        return;
      }

      elementToBeFocused.focus();
    });

    _defineProperty(_assertThisInitialized(_this), "onSiblingsExpand", function (e, treeItemProps) {
      var _this$props = _this.props,
          exclusive = _this$props.exclusive,
          items = _this$props.items;

      if (exclusive) {
        return;
      }

      var id = treeItemProps.id;
      var activeItemIds = _this.state.activeItemIds;
      var siblings = getSiblings(items, id);
      siblings.forEach(function (sibling) {
        if (hasSubtree(sibling) && !_this.isActiveItem(sibling['id'])) {
          activeItemIds.push(sibling['id']);
        }
      });

      if (hasSubtree(treeItemProps) && !_this.isActiveItem(id)) {
        activeItemIds.push(id);
      }

      _this.setActiveItemIds(e, activeItemIds);
    });

    _defineProperty(_assertThisInitialized(_this), "setActiveItemIds", function (e, activeItemIds) {
      _invoke(_this.props, 'onActiveItemIdsChange', e, Object.assign({}, _this.props, {
        activeItemIds: activeItemIds
      }));

      _this.setState({
        activeItemIds: activeItemIds
      });
    });

    _defineProperty(_assertThisInitialized(_this), "getAllSelectableChildrenId", function (items) {
      return items.reduce(function (acc, item) {
        if (item.items) {
          return [].concat(_toConsumableArray(acc), _toConsumableArray(_this.getAllSelectableChildrenId(item.items)));
        }

        return item.hasOwnProperty('selectable') && !item.selectable ? acc : [].concat(_toConsumableArray(acc), [item.id]);
      }, []);
    });

    _defineProperty(_assertThisInitialized(_this), "isIndeterminate", function (item) {
      if (!item.selectableParent || !item.items) {
        return false;
      }

      var items = item.items;

      var selectableItemIds = _this.getAllSelectableChildrenId(items);

      return !_this.isAllGroupChecked(items) && selectableItemIds.some(function (id) {
        return _this.state.selectedItemIds.indexOf(id) > -1;
      });
    });

    _defineProperty(_assertThisInitialized(_this), "isAllGroupChecked", function (items) {
      var selectableItemIds = _this.getAllSelectableChildrenId(items);

      return selectableItemIds.every(function (id) {
        return _this.state.selectedItemIds.indexOf(id) > -1;
      });
    });

    _defineProperty(_assertThisInitialized(_this), "contextValue", {
      onFocusParent: _this.onFocusParent,
      onSiblingsExpand: _this.onSiblingsExpand,
      onFocusFirstChild: _this.onFocusFirstChild,
      onTitleClick: _this.onTitleClick
    });

    _defineProperty(_assertThisInitialized(_this), "isActiveItem", function (id) {
      var activeItemIds = _this.state.activeItemIds;
      return activeItemIds.indexOf(id) > -1;
    });

    _defineProperty(_assertThisInitialized(_this), "isSelectedItem", function (item) {
      var selectedItemIds = _this.state.selectedItemIds;

      if (item.selectableParent && item.items) {
        return _this.isAllGroupChecked(item.items);
      }

      return selectedItemIds && selectedItemIds.indexOf(item.id) > -1;
    });

    return _this;
  }

  _createClass(Tree, [{
    key: "getInitialAutoControlledState",
    value: function getInitialAutoControlledState() {
      return {
        activeItemIds: [],
        selectedItemIds: []
      };
    }
  }, {
    key: "expandItems",
    value: function expandItems(e, treeItemProps) {
      var activeItemIds = this.state.activeItemIds;
      var id = treeItemProps.id;
      var _this$props2 = this.props,
          exclusive = _this$props2.exclusive,
          items = _this$props2.items;
      var siblings = getSiblings(items, id);
      var activeItemIdIndex = activeItemIds.indexOf(id);

      if (activeItemIdIndex > -1) {
        activeItemIds = removeItemAtIndex(activeItemIds, activeItemIdIndex);
      } else {
        if (exclusive) {
          siblings.some(function (sibling) {
            var activeSiblingIdIndex = activeItemIds.indexOf(sibling['id']);

            if (activeSiblingIdIndex > -1) {
              activeItemIds = removeItemAtIndex(activeItemIds, activeSiblingIdIndex);
              return true;
            }

            return false;
          });
        }

        activeItemIds = [].concat(_toConsumableArray(activeItemIds), [id]);
      }

      this.setActiveItemIds(e, activeItemIds);
    }
  }, {
    key: "renderContent",
    value: function renderContent(accessibility) {
      var _this2 = this;

      var _this$props3 = this.props,
          items = _this$props3.items,
          renderItemTitle = _this$props3.renderItemTitle,
          selectable = _this$props3.selectable;
      if (!items) return null;

      var renderItems = function renderItems(items) {
        var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        var parent = arguments.length > 2 ? arguments[2] : undefined;
        return items.reduce(function (renderedItems, item, index) {
          var id = item.id;
          var isSubtree = hasSubtree(item);

          var isSubtreeExpanded = isSubtree && _this2.isActiveItem(id);

          var isSelectedItem = _this2.isSelectedItem(item);

          var indeterminate = _this2.isIndeterminate(item);

          if (!_this2.itemsRef.has(id)) {
            _this2.itemsRef.set(id, React.createRef());
          }

          var renderedItem = TreeItem.create(item, {
            defaultProps: function defaultProps() {
              return {
                accessibility: accessibility.childBehaviors ? accessibility.childBehaviors.item : undefined,
                expanded: isSubtreeExpanded,
                selected: isSelectedItem,
                selectable: selectable,
                renderItemTitle: renderItemTitle,
                id: id,
                key: id,
                parent: parent,
                level: level,
                index: index + 1,
                // Used for aria-posinset and it's 1-based.
                contentRef: _this2.itemsRef.get(id),
                treeSize: items.length,
                indeterminate: indeterminate
              };
            }
          });
          return [].concat(_toConsumableArray(renderedItems), [renderedItem], _toConsumableArray(isSubtreeExpanded ? renderItems(item.items, level + 1, id) : []));
        }, []);
      };

      return renderItems(items);
    }
  }, {
    key: "renderComponent",
    value: function renderComponent(_ref) {
      var ElementType = _ref.ElementType,
          classes = _ref.classes,
          accessibility = _ref.accessibility,
          unhandledProps = _ref.unhandledProps;
      var _this$props4 = this.props,
          children = _this$props4.children,
          renderedItems = _this$props4.renderedItems;
      return React.createElement(TreeContext.Provider, {
        value: this.contextValue
      }, React.createElement(Ref, {
        innerRef: this.treeRef
      }, React.createElement(ElementType, _extends({
        className: classes.root
      }, accessibility.attributes.root, rtlTextContainer.getAttributes({
        forElements: [children]
      }), unhandledProps, applyAccessibilityKeyHandlers(accessibility.keyHandlers.root, unhandledProps)), childrenExist(children) ? children : renderedItems ? renderedItems(this.renderContent(accessibility)) : this.renderContent(accessibility))));
    }
  }], [{
    key: "getAutoControlledStateFromProps",
    value: function getAutoControlledStateFromProps(nextProps, prevState) {
      var items = nextProps.items,
          selectable = nextProps.selectable;
      var activeItemIds = nextProps.activeItemIds,
          selectedItemIds = nextProps.selectedItemIds;

      if (selectable && items && !selectedItemIds) {
        if (!selectedItemIds && items) {
          selectedItemIds = prevState.selectedItemIds;

          var iterateItems = function iterateItems(items) {
            var selectedItems = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : selectedItemIds;

            _forEach(items, function (item) {
              if (item['selected'] && selectedItemIds.indexOf(item['id']) === -1) {
                selectedItems.push(item['id']);
              }

              if (item['items']) {
                return iterateItems(item['items']);
              }
            });
          };

          iterateItems(items);
        }
      }

      if (!activeItemIds && items) {
        activeItemIds = prevState.activeItemIds;

        var expandedItemsGenerator = function expandedItemsGenerator(items) {
          var acc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : activeItemIds;
          return _reduce(items, function (acc, item) {
            if (item['expanded'] && acc.indexOf(item['id']) === -1) {
              acc.push(item['id']);
            }

            if (item['items']) {
              return expandedItemsGenerator(item['items'], acc);
            }

            return acc;
          }, acc);
        };

        expandedItemsGenerator(items);
      }

      return {
        activeItemIds: activeItemIds,
        selectedItemIds: selectedItemIds
      };
    }
  }]);

  return Tree;
}(AutoControlledComponent);

_defineProperty(Tree, "create", void 0);

_defineProperty(Tree, "displayName", 'Tree');

_defineProperty(Tree, "deprecated_className", treeClassName);

_defineProperty(Tree, "propTypes", Object.assign({}, commonPropTypes.createCommon({
  content: false
}), {
  activeItemIds: customPropTypes.collectionShorthand,
  selectedItemIds: customPropTypes.collectionShorthand,
  defaultActiveItemIds: customPropTypes.collectionShorthand,
  defaultSelectedItemIds: customPropTypes.collectionShorthand,
  exclusive: PropTypes.bool,
  selectable: PropTypes.bool,
  items: customPropTypes.collectionObjectShorthand,
  onActiveItemIdsChange: PropTypes.func,
  onSelectedItemIdsChange: PropTypes.func,
  renderItemTitle: PropTypes.func,
  renderedItems: PropTypes.func
}));

_defineProperty(Tree, "defaultProps", {
  as: 'div',
  accessibility: treeBehavior
});

_defineProperty(Tree, "autoControlledProps", ['activeItemIds', 'selectedItemIds']);

_defineProperty(Tree, "Item", TreeItem);

_defineProperty(Tree, "Title", TreeTitle);

Tree.create = createShorthandFactory({
  Component: Tree,
  mappedArrayProp: 'items'
});
/**
 * A Tree displays data organised in tree hierarchy.
 *
 * @accessibility
 * Implements [ARIA TreeView](https://www.w3.org/TR/wai-aria-practices-1.1/#TreeView) design pattern.
 * @accessibilityIssues
 * [Treeview - JAWS doesn't narrate position for each tree item](https://github.com/FreedomScientific/VFO-standards-support/issues/338)
 * [Aria compliant trees are read as empty tables](https://bugs.chromium.org/p/chromium/issues/detail?id=1048770)
 */

export default withSafeTypeForAs(Tree);
//# sourceMappingURL=Tree.js.map
