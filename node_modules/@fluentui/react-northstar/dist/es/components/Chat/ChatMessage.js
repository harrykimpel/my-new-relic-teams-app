import _extends from "@babel/runtime/helpers/esm/extends";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _invoke from "lodash/invoke";
import { IS_FOCUSABLE_ATTRIBUTE, chatMessageBehavior, menuAsToolbarBehavior } from '@fluentui/accessibility';
import { getElementType, useUnhandledProps, useAccessibility, useStyles, useTelemetry } from '@fluentui/react-bindings';
import { useContextSelector } from '@fluentui/react-context-selector';
import { Ref } from '@fluentui/react-component-ref';
import * as customPropTypes from '@fluentui/react-proptypes';
import cx from 'classnames';
import * as PropTypes from 'prop-types';
import * as React from 'react'; // @ts-ignore

import { ThemeContext } from 'react-fela';
import { getScrollParent, Popper, getPopperPropsFromShorthand } from '../../utils/positioner';
import { childrenExist, createShorthandFactory, commonPropTypes, rtlTextContainer } from '../../utils';
import { withSafeTypeForAs } from '../../types';
import Box from '../Box/Box';
import Label from '../Label/Label';
import Menu from '../Menu/Menu';
import Text from '../Text/Text';
import Reaction from '../Reaction/Reaction';
import { ChatItemContext } from './chatItemContext';
export var chatMessageClassName = 'ui-chat__message';
export var chatMessageSlotClassNames = {
  actionMenu: "".concat(chatMessageClassName, "__actions"),
  author: "".concat(chatMessageClassName, "__author"),
  timestamp: "".concat(chatMessageClassName, "__timestamp"),
  badge: "".concat(chatMessageClassName, "__badge"),
  content: "".concat(chatMessageClassName, "__content"),
  reactionGroup: "".concat(chatMessageClassName, "__reactions")
};

var ChatMessage = function ChatMessage(props) {
  var context = React.useContext(ThemeContext);

  var _useTelemetry = useTelemetry(ChatMessage.displayName, context.telemetry),
      setStart = _useTelemetry.setStart,
      setEnd = _useTelemetry.setEnd;

  setStart();
  var parentAttached = useContextSelector(ChatItemContext, function (v) {
    return v.attached;
  });
  var accessibility = props.accessibility,
      actionMenu = props.actionMenu,
      _props$attached = props.attached,
      attached = _props$attached === void 0 ? parentAttached : _props$attached,
      author = props.author,
      badge = props.badge,
      badgePosition = props.badgePosition,
      children = props.children,
      className = props.className,
      content = props.content,
      design = props.design,
      mine = props.mine,
      positionActionMenu = props.positionActionMenu,
      reactionGroup = props.reactionGroup,
      reactionGroupPosition = props.reactionGroupPosition,
      timestamp = props.timestamp,
      styles = props.styles,
      variables = props.variables,
      overflow = props.unstable_overflow;

  var _React$useState = React.useState(false),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      focused = _React$useState2[0],
      setFocused = _React$useState2[1];

  var _React$useState3 = React.useState(null),
      _React$useState4 = _slicedToArray(_React$useState3, 2),
      messageNode = _React$useState4[0],
      setMessageNode = _React$useState4[1];

  var updateActionsMenuPosition = React.useRef(null);
  var getA11Props = useAccessibility(accessibility, {
    actionHandlers: {
      // prevents default FocusZone behavior, e.g., in ChatMessageBehavior, it prevents FocusZone from using arrow keys
      // as navigation (only Tab key should work)
      preventDefault: function preventDefault(event) {
        // preventDefault only if event coming from inside the message
        if (event.currentTarget !== event.target) {
          event.preventDefault();
        }
      },
      focus: function focus(event) {
        if (messageNode) {
          messageNode.focus();
          event.stopPropagation();
        }
      }
    }
  });

  var _useStyles = useStyles(ChatMessage.displayName, {
    className: chatMessageClassName,
    mapPropsToStyles: function mapPropsToStyles() {
      return {
        attached: attached,
        badgePosition: badgePosition,
        focused: focused,
        mine: mine,
        hasBadge: !!badge,
        hasReactionGroup: !!reactionGroup
      };
    },
    mapPropsToInlineStyles: function mapPropsToInlineStyles() {
      return {
        className: className,
        design: design,
        styles: styles,
        variables: variables
      };
    },
    rtl: context.rtl
  }),
      classes = _useStyles.classes,
      resolvedStyles = _useStyles.styles;

  var handleFocus = function handleFocus(e) {
    _invoke(updateActionsMenuPosition, 'current');

    setFocused(true);

    _invoke(props, 'onFocus', e, props);
  };

  var handleBlur = function handleBlur(e) {
    // `focused` controls is focused the whole `ChatMessage` or any of its children. When we're navigating
    // with keyboard the focused element will be changed and there is no way to use `:focus` selector
    var shouldPreserveFocusState = _invoke(e, 'currentTarget.contains', e.relatedTarget);

    setFocused(shouldPreserveFocusState);

    _invoke(props, 'onBlur', e, props);
  };

  var handleMouseEnter = function handleMouseEnter(e) {
    _invoke(updateActionsMenuPosition, 'current');

    _invoke(props, 'onMouseEnter', e, props);
  };

  var renderActionMenu = function renderActionMenu() {
    var actionMenuElement = Menu.create(actionMenu, {
      defaultProps: function defaultProps() {
        var _ref;

        return _ref = {}, _defineProperty(_ref, IS_FOCUSABLE_ATTRIBUTE, true), _defineProperty(_ref, "accessibility", menuAsToolbarBehavior), _defineProperty(_ref, "className", chatMessageSlotClassNames.actionMenu), _defineProperty(_ref, "styles", resolvedStyles.actionMenu), _ref;
      }
    });

    if (!actionMenuElement) {
      return actionMenuElement;
    }

    var modifiers = positionActionMenu && [// https://popper.js.org/docs/v2/modifiers/flip/
    // Forces to flip only in "top-*" positions
    {
      name: 'flip',
      options: {
        fallbackPlacements: ['top']
      }
    }, overflow && {
      name: 'preventOverflow',
      options: {
        boundary: getScrollParent(messageNode)
      }
    }];
    return React.createElement(Popper, _extends({
      enabled: positionActionMenu,
      align: "end",
      modifiers: modifiers,
      position: "above",
      positionFixed: overflow,
      targetRef: messageNode
    }, getPopperPropsFromShorthand(actionMenu)), function (_ref2) {
      var scheduleUpdate = _ref2.scheduleUpdate;
      updateActionsMenuPosition.current = scheduleUpdate;
      return actionMenuElement;
    });
  };

  var childrenPropExists = childrenExist(children);
  var rootClasses = childrenPropExists ? cx(classes.root, classes.content) : classes.root;
  var ElementType = getElementType(props);
  var unhandledProps = useUnhandledProps(ChatMessage.handledProps, props);
  var badgeElement = Label.create(badge, {
    defaultProps: function defaultProps() {
      return {
        className: chatMessageSlotClassNames.badge,
        styles: resolvedStyles.badge
      };
    }
  });
  var reactionGroupElement = Reaction.Group.create(reactionGroup, {
    defaultProps: function defaultProps() {
      return {
        className: chatMessageSlotClassNames.reactionGroup,
        styles: resolvedStyles.reactionGroup
      };
    }
  });
  var actionMenuElement = renderActionMenu();
  var authorElement = Text.create(author, {
    defaultProps: function defaultProps() {
      return {
        size: 'small',
        styles: resolvedStyles.author,
        className: chatMessageSlotClassNames.author
      };
    }
  });
  var timestampElement = Text.create(timestamp, {
    defaultProps: function defaultProps() {
      return {
        size: 'small',
        styles: resolvedStyles.timestamp,
        timestamp: true,
        className: chatMessageSlotClassNames.timestamp
      };
    }
  });
  var messageContent = Box.create(content, {
    defaultProps: function defaultProps() {
      return {
        className: chatMessageSlotClassNames.content,
        styles: resolvedStyles.content
      };
    }
  });
  var element = React.createElement(Ref, {
    innerRef: setMessageNode
  }, getA11Props.unstable_wrapWithFocusZone(React.createElement(ElementType, getA11Props('root', Object.assign({
    className: rootClasses,
    onBlur: handleBlur,
    onFocus: handleFocus,
    onMouseEnter: handleMouseEnter
  }, rtlTextContainer.getAttributes({
    forElements: [children]
  }), {}, unhandledProps)), childrenPropExists ? children : React.createElement(React.Fragment, null, actionMenuElement, badgePosition === 'start' && badgeElement, authorElement, timestampElement, reactionGroupPosition === 'start' && reactionGroupElement, messageContent, reactionGroupPosition === 'end' && reactionGroupElement, badgePosition === 'end' && badgeElement))));
  setEnd();
  return element;
};

ChatMessage.displayName = 'ChatMessage';
ChatMessage.defaultProps = {
  accessibility: chatMessageBehavior,
  badgePosition: 'end',
  positionActionMenu: true,
  reactionGroupPosition: 'start'
};
ChatMessage.propTypes = Object.assign({}, commonPropTypes.createCommon({
  content: 'shorthand'
}), {
  actionMenu: PropTypes.oneOfType([customPropTypes.itemShorthand, customPropTypes.collectionShorthand]),
  attached: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['top', 'bottom'])]),
  author: customPropTypes.itemShorthand,
  badge: customPropTypes.itemShorthand,
  badgePosition: PropTypes.oneOf(['start', 'end']),
  mine: PropTypes.bool,
  timestamp: customPropTypes.itemShorthand,
  onBlur: PropTypes.func,
  onFocus: PropTypes.func,
  onMouseEnter: PropTypes.func,
  positionActionMenu: PropTypes.bool,
  reactionGroup: PropTypes.oneOfType([customPropTypes.collectionShorthand, customPropTypes.itemShorthand]),
  reactionGroupPosition: PropTypes.oneOf(['start', 'end']),
  unstable_overflow: PropTypes.bool
});
ChatMessage.handledProps = Object.keys(ChatMessage.propTypes);
ChatMessage.create = createShorthandFactory({
  Component: ChatMessage,
  mappedProp: 'content'
});
/**
 * A ChatMessage represents a single message in chat.
 */

export default withSafeTypeForAs(ChatMessage);
//# sourceMappingURL=ChatMessage.js.map
