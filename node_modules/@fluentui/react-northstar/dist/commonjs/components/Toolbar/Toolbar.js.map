{"version":3,"sources":["components/Toolbar/Toolbar.tsx"],"names":["WAS_FOCUSABLE_ATTRIBUTE","toolbarClassName","Toolbar","props","context","React","useContext","ThemeContext","displayName","telemetry","setStart","setEnd","accessibility","className","children","design","getOverflowItems","items","overflow","overflowItem","overflowOpen","styles","variables","overflowContainerRef","useRef","overflowItemRef","offsetMeasureRef","containerRef","lastVisibleItemIndex","animationFrameId","getA11Props","debugName","rtl","mapPropsToInlineStyles","classes","ElementType","unhandledProps","handledProps","hide","el","style","visibility","target","activeElement","contains","current","firstFocusableItem","firstElementChild","focus","wasFocusable","getAttribute","IS_FOCUSABLE_ATTRIBUTE","setAttribute","show","removeAttribute","isItemOverflowing","itemBoundingRect","containerBoundingRect","right","left","wouldItemCollide","$item","overflowItemBoundingRect","actualWindow","defaultView","wouldCollide","itemLeftMargin","parseFloat","getComputedStyle","marginLeft","width","itemRightMargin","marginRight","setOverflowPosition","$overflowItem","$lastVisibleItem","lastVisibleItemRect","absolutePositioningOffset","lastVisibleItemMarginLeft","horizontal","lastVisibleItemRightMargin","hideOverflowItems","$overflowContainer","$offsetMeasure","scrollTo","Number","MAX_SAFE_INTEGER","$items","overflowContainerBoundingRect","getBoundingClientRect","offsetMeasureBoundingRect","vertical","top","isOverflowing","i","position","length","collectOverflowItems","slice","getVisibleItems","end","handleWindowResize","e","renderItems","item","kind","ToolbarDivider","create","ToolbarRadioGroup","ToolbarItem","defaultProps","toggleButtonBehavior","ToolbarCustomItem","renderOverflowItem","icon","overrideProps","menu","popper","positionFixed","menuOpen","onMenuOpenChange","useEffect","cancelAnimationFrame","requestAnimationFrame","undefined","element","unstable_wrapWithFocusZone","root","overflowContainer","offsetMeasure","propTypes","commonPropTypes","createCommon","customPropTypes","collectionShorthandWithKindProp","PropTypes","bool","shorthandAllowingChildren","onOverflow","func","onOverflowOpenChange","toolbarBehavior","Object","keys","CustomItem","Divider","Item","Menu","ToolbarMenu","MenuDivider","ToolbarMenuDivider","MenuItem","ToolbarMenuItem","MenuRadioGroup","ToolbarMenuRadioGroup","RadioGroup","Component","mappedProp"],"mappings":"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","sourcesContent":["import {\n  Accessibility,\n  toolbarBehavior,\n  ToolbarBehaviorProps,\n  toggleButtonBehavior,\n  IS_FOCUSABLE_ATTRIBUTE,\n} from '@fluentui/accessibility';\nimport {\n  getElementType,\n  getFirstFocusable,\n  useAccessibility,\n  useStyles,\n  useTelemetry,\n  useUnhandledProps,\n} from '@fluentui/react-bindings';\nimport { EventListener } from '@fluentui/react-component-event-listener';\nimport { Ref } from '@fluentui/react-component-ref';\nimport { MoreIcon } from '@fluentui/react-icons-northstar';\nimport * as customPropTypes from '@fluentui/react-proptypes';\nimport * as _ from 'lodash';\nimport * as PropTypes from 'prop-types';\nimport * as React from 'react';\n// @ts-ignore\nimport { ThemeContext } from 'react-fela';\n\nimport {\n  ComponentEventHandler,\n  FluentComponentStaticProps,\n  ProviderContextPrepared,\n  ShorthandCollection,\n  ShorthandValue,\n  WithAsProp,\n  withSafeTypeForAs,\n} from '../../types';\nimport {\n  childrenExist,\n  createShorthandFactory,\n  UIComponentProps,\n  ContentComponentProps,\n  ChildrenComponentProps,\n  commonPropTypes,\n  ColorComponentProps,\n} from '../../utils';\nimport ToolbarCustomItem from './ToolbarCustomItem';\nimport ToolbarDivider from './ToolbarDivider';\nimport ToolbarItem, { ToolbarItemProps } from './ToolbarItem';\nimport ToolbarMenu from './ToolbarMenu';\nimport ToolbarMenuDivider from './ToolbarMenuDivider';\nimport ToolbarMenuItem, { ToolbarMenuItemProps } from './ToolbarMenuItem';\nimport ToolbarMenuRadioGroup from './ToolbarMenuRadioGroup';\nimport ToolbarRadioGroup from './ToolbarRadioGroup';\nimport { ToolbarVariablesProvider } from './toolbarVariablesContext';\n\nexport type ToolbarItemShorthandKinds = 'divider' | 'item' | 'group' | 'toggle' | 'custom';\n\ntype PositionOffset = {\n  vertical: number;\n  horizontal: number;\n};\n\nconst WAS_FOCUSABLE_ATTRIBUTE = 'data-was-focusable';\n\nexport interface ToolbarProps\n  extends UIComponentProps,\n    ContentComponentProps,\n    ChildrenComponentProps,\n    ColorComponentProps {\n  /** Accessibility behavior if overridden by the user. */\n  accessibility?: Accessibility<ToolbarBehaviorProps>;\n\n  /** Shorthand array of props for Toolbar. */\n  items?: ShorthandCollection<ToolbarItemProps, ToolbarItemShorthandKinds>;\n\n  /**\n   *  Automatically move overflow items to overflow menu.\n   *  For automatic overflow to work correctly, toolbar items including overflowMenuItem\n   *  must NOT change their size! If you need to change item's size, rerender the Toolbar.\n   */\n  overflow?: boolean;\n\n  /** Indicates if the overflow menu is open. Only valid if `overflow` is enabled and regular items do not fit. */\n  overflowOpen?: boolean;\n\n  /**\n   * Shorthand for the overflow item which is displayed when `overflow` is enabled and regular toolbar items do not fit.\n   * Do not set any menu on this item, Toolbar overrides it.\n   */\n  overflowItem?: ShorthandValue<ToolbarItemProps>;\n\n  /**\n   * Called when overflow is recomputed (after render, update or window resize). Even if all items fit.\n   * @param itemsVisible - number of items visible\n   */\n  onOverflow?: (itemsVisible: number) => void;\n\n  /**\n   * Event for request to change 'overflowOpen' value.\n   * @param event - React's original SyntheticEvent.\n   * @param data - All props and proposed value.\n   */\n  onOverflowOpenChange?: ComponentEventHandler<ToolbarProps>;\n\n  /**\n   * Callback to get items to be rendered in overflow menu.\n   * Called when overflow menu is rendered opened.\n   * @param startIndex - Index of the first item to be displayed in the overflow menu (the first item which does not fit the toolbar).\n   */\n  getOverflowItems?: (startIndex: number) => ShorthandCollection<ToolbarMenuItemProps, ToolbarItemShorthandKinds>; // FIXME: use correct kind\n}\n\nexport type ToolbarStylesProps = never;\n\nexport const toolbarClassName = 'ui-toolbar';\n\nconst Toolbar: React.FC<WithAsProp<ToolbarProps>> &\n  FluentComponentStaticProps<ToolbarProps> & {\n    CustomItem: typeof ToolbarCustomItem;\n    Divider: typeof ToolbarDivider;\n    Item: typeof ToolbarItem;\n    Menu: typeof ToolbarMenu;\n    MenuDivider: typeof ToolbarMenuDivider;\n    MenuItem: typeof ToolbarMenuItem;\n    MenuRadioGroup: typeof ToolbarMenuRadioGroup;\n    RadioGroup: typeof ToolbarRadioGroup;\n  } = props => {\n  const context: ProviderContextPrepared = React.useContext(ThemeContext);\n  const { setStart, setEnd } = useTelemetry(Toolbar.displayName, context.telemetry);\n  setStart();\n\n  const {\n    accessibility,\n    className,\n    children,\n    design,\n    getOverflowItems,\n    items,\n    overflow,\n    overflowItem,\n    overflowOpen,\n    styles,\n    variables,\n  } = props;\n\n  const overflowContainerRef = React.useRef<HTMLDivElement>();\n  const overflowItemRef = React.useRef<HTMLElement>();\n  const offsetMeasureRef = React.useRef<HTMLDivElement>();\n  const containerRef = React.useRef<HTMLElement>();\n\n  // index of the last visible item in Toolbar, the rest goes to overflow menu\n  const lastVisibleItemIndex = React.useRef<number>();\n  const animationFrameId = React.useRef<number>();\n\n  const getA11Props = useAccessibility(accessibility, {\n    debugName: Toolbar.displayName,\n    rtl: context.rtl,\n  });\n  const { classes } = useStyles<ToolbarStylesProps>(Toolbar.displayName, {\n    className: toolbarClassName,\n    mapPropsToInlineStyles: () => ({\n      className,\n      design,\n      styles,\n      variables,\n    }),\n    rtl: context.rtl,\n  });\n\n  const ElementType = getElementType(props);\n  const unhandledProps = useUnhandledProps(Toolbar.handledProps, props);\n\n  const hide = (el: HTMLElement) => {\n    if (el.style.visibility === 'hidden') {\n      return;\n    }\n\n    if (context.target.activeElement === el || el.contains(context.target.activeElement)) {\n      if (containerRef.current) {\n        const firstFocusableItem = getFirstFocusable(\n          containerRef.current,\n          containerRef.current.firstElementChild as HTMLElement,\n        );\n\n        if (firstFocusableItem) {\n          firstFocusableItem.focus();\n        }\n      }\n    }\n\n    el.style.visibility = 'hidden';\n    const wasFocusable = el.getAttribute(IS_FOCUSABLE_ATTRIBUTE);\n    if (wasFocusable) {\n      el.setAttribute(WAS_FOCUSABLE_ATTRIBUTE, wasFocusable);\n    }\n    el.setAttribute(IS_FOCUSABLE_ATTRIBUTE, 'false');\n  };\n\n  const show = (el: HTMLElement) => {\n    if (el.style.visibility !== 'hidden') {\n      return false;\n    }\n\n    el.style.visibility = null;\n    const wasFocusable = el.getAttribute(WAS_FOCUSABLE_ATTRIBUTE);\n    if (wasFocusable) {\n      el.setAttribute(IS_FOCUSABLE_ATTRIBUTE, wasFocusable);\n      el.removeAttribute(WAS_FOCUSABLE_ATTRIBUTE);\n    } else {\n      el.removeAttribute(IS_FOCUSABLE_ATTRIBUTE);\n    }\n\n    return true;\n  };\n\n  /**\n   * Checks if `item` overflows a `container`.\n   * TODO: check and fix all margin combination\n   */\n  const isItemOverflowing = (itemBoundingRect: ClientRect, containerBoundingRect: ClientRect) => {\n    return itemBoundingRect.right > containerBoundingRect.right || itemBoundingRect.left < containerBoundingRect.left;\n  };\n\n  /**\n   * Checks if `item` would collide with eventual position of `overflowItem`.\n   */\n  const wouldItemCollide = (\n    $item: Element,\n    itemBoundingRect: ClientRect,\n    overflowItemBoundingRect: ClientRect,\n    containerBoundingRect: ClientRect,\n  ) => {\n    const actualWindow: Window = context.target.defaultView;\n    let wouldCollide;\n\n    if (context.rtl) {\n      const itemLeftMargin = parseFloat(actualWindow.getComputedStyle($item).marginLeft) || 0;\n      wouldCollide =\n        itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin < containerBoundingRect.left;\n\n      // console.log('Collision [RTL]', {\n      //   wouldCollide,\n      //   'itemBoundingRect.left': itemBoundingRect.left,\n      //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,\n      //   itemRightMargin: itemLeftMargin,\n      //   sum: itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin,\n      //   'overflowContainerBoundingRect.left': containerBoundingRect.left,\n      // })\n    } else {\n      const itemRightMargin = parseFloat(actualWindow.getComputedStyle($item).marginRight) || 0;\n      wouldCollide =\n        itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin > containerBoundingRect.right;\n\n      // console.log('Collision', {\n      //   wouldCollide,\n      //   'itemBoundingRect.right': itemBoundingRect.right,\n      //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,\n      //   itemRightMargin,\n      //   sum: itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin,\n      //   'overflowContainerBoundingRect.right': containerBoundingRect.right,\n      // })\n    }\n\n    return wouldCollide;\n  };\n\n  /**\n   * Positions overflowItem next to lastVisible item\n   * TODO: consider overflowItem margin\n   */\n  const setOverflowPosition = (\n    $overflowItem: HTMLElement,\n    $lastVisibleItem: HTMLElement | undefined,\n    lastVisibleItemRect: ClientRect | undefined,\n    containerBoundingRect: ClientRect,\n    absolutePositioningOffset: PositionOffset,\n  ) => {\n    const actualWindow: Window = context.target.defaultView;\n\n    if ($lastVisibleItem) {\n      if (context.rtl) {\n        const lastVisibleItemMarginLeft = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginLeft) || 0;\n\n        $overflowItem.style.right = `${containerBoundingRect.right -\n          lastVisibleItemRect.left +\n          lastVisibleItemMarginLeft +\n          absolutePositioningOffset.horizontal}px`;\n      } else {\n        const lastVisibleItemRightMargin = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginRight) || 0;\n\n        $overflowItem.style.left = `${lastVisibleItemRect.right -\n          containerBoundingRect.left +\n          lastVisibleItemRightMargin +\n          absolutePositioningOffset.horizontal}px`;\n      }\n    } else {\n      // there is no last visible item -> position the overflow as the first item\n      lastVisibleItemIndex.current = -1;\n      if (context.rtl) {\n        $overflowItem.style.right = `${absolutePositioningOffset.horizontal}px`;\n      } else {\n        $overflowItem.style.left = `${absolutePositioningOffset.horizontal}px`;\n      }\n    }\n  };\n\n  const hideOverflowItems = () => {\n    const $overflowContainer = overflowContainerRef.current;\n    const $overflowItem = overflowItemRef.current;\n    const $offsetMeasure = offsetMeasureRef.current;\n    if (!$overflowContainer || !$overflowItem || !$offsetMeasure) {\n      return;\n    }\n\n    // workaround: when resizing window with popup opened the container contents scroll for some reason\n    if (context.rtl) {\n      $overflowContainer.scrollTo(Number.MAX_SAFE_INTEGER, 0);\n    } else {\n      $overflowContainer.scrollTo(0, 0);\n    }\n\n    const $items = $overflowContainer.children;\n\n    const overflowContainerBoundingRect = $overflowContainer.getBoundingClientRect();\n    const overflowItemBoundingRect = $overflowItem.getBoundingClientRect();\n    const offsetMeasureBoundingRect = $offsetMeasure.getBoundingClientRect();\n\n    // Absolute positioning offset\n    // Overflow menu is absolutely positioned relative to root slot\n    // If there is padding set on the root slot boundingClientRect computations use inner content box,\n    // but absolute position is relative to root slot's PADDING box.\n    // We compute absolute positioning offset\n    // By measuring position of an offsetMeasure element absolutely positioned to 0,0.\n    // TODO: replace by getComputedStyle('padding')\n    const absolutePositioningOffset: PositionOffset = {\n      horizontal: context.rtl\n        ? offsetMeasureBoundingRect.right - overflowContainerBoundingRect.right\n        : overflowContainerBoundingRect.left - offsetMeasureBoundingRect.left,\n      vertical: overflowContainerBoundingRect.top - offsetMeasureBoundingRect.top,\n    };\n\n    let isOverflowing = false;\n    let $lastVisibleItem;\n    let lastVisibleItemRect;\n\n    // check all items from the last one back\n    _.forEachRight($items, ($item: HTMLElement, i: number) => {\n      if ($item === $overflowItem) {\n        return true;\n      }\n\n      const itemBoundingRect = $item.getBoundingClientRect();\n\n      // if the item is out of the crop rectangle, hide it\n      if (isItemOverflowing(itemBoundingRect, overflowContainerBoundingRect)) {\n        isOverflowing = true;\n        // console.log('Overflow', i, {\n        //   item: [itemBoundingRect.left, itemBoundingRect.right],\n        //   crop: [\n        //     overflowContainerBoundingRect.left,\n        //     overflowContainerBoundingRect.right,\n        //     overflowContainerBoundingRect.width,\n        //   ],\n        //   container: $overflowContainer,\n        // })\n        hide($item);\n        return true;\n      }\n\n      // if there is an overflow, check collision of remaining items with eventual overflow position\n      if (\n        isOverflowing &&\n        !$lastVisibleItem &&\n        wouldItemCollide($item, itemBoundingRect, overflowItemBoundingRect, overflowContainerBoundingRect)\n      ) {\n        hide($item);\n        return true;\n      }\n\n      // Remember the last visible item\n      if (!$lastVisibleItem) {\n        $lastVisibleItem = $item;\n        lastVisibleItemRect = itemBoundingRect;\n        lastVisibleItemIndex.current = i;\n      }\n\n      return show($item); // exit the loop when first visible item is found\n    });\n\n    // if there is an overflow,  position and show overflow item, otherwise hide it\n    if (isOverflowing || overflowOpen) {\n      $overflowItem.style.position = 'absolute';\n      setOverflowPosition(\n        $overflowItem,\n        $lastVisibleItem,\n        lastVisibleItemRect,\n        overflowContainerBoundingRect,\n        absolutePositioningOffset,\n      );\n      show($overflowItem);\n    } else {\n      lastVisibleItemIndex.current = items.length - 1;\n      hide($overflowItem);\n    }\n\n    _.invoke(props, 'onOverflow', lastVisibleItemIndex.current + 1);\n  };\n\n  const collectOverflowItems = () => {\n    // console.log('getOverflowItems()', items.slice(lastVisibleItemIndex.current + 1))\n    return getOverflowItems\n      ? getOverflowItems(lastVisibleItemIndex.current + 1)\n      : items.slice(lastVisibleItemIndex.current + 1);\n  };\n\n  const getVisibleItems = () => {\n    // console.log('allItems()', items)\n    const end = overflowOpen ? lastVisibleItemIndex.current + 1 : items.length;\n    // console.log('getVisibleItems()', items.slice(0, end))\n    return items.slice(0, end);\n  };\n\n  const handleWindowResize = _.debounce((e: UIEvent) => {\n    hideOverflowItems();\n\n    if (overflowOpen) {\n      _.invoke(props, 'onOverflowOpenChange', e, { ...props, overflowOpen: false });\n    }\n  }, 16);\n\n  const renderItems = (items: ShorthandCollection<ToolbarItemProps, ToolbarItemShorthandKinds>) =>\n    _.map(items, (item: ShorthandValue<ToolbarItemProps & { kind?: ToolbarItemShorthandKinds }>) => {\n      const kind = _.get(item, 'kind', 'item');\n\n      switch (kind) {\n        case 'divider':\n          return ToolbarDivider.create(item);\n        case 'group':\n          return ToolbarRadioGroup.create(item);\n        case 'toggle':\n          return ToolbarItem.create(item, {\n            defaultProps: () => ({ accessibility: toggleButtonBehavior }),\n          });\n        case 'custom':\n          return ToolbarCustomItem.create(item);\n        default:\n          return ToolbarItem.create(item);\n      }\n    });\n\n  const renderOverflowItem = overflowItem => {\n    return (\n      <Ref innerRef={overflowItemRef}>\n        {ToolbarItem.create(overflowItem, {\n          defaultProps: () => ({\n            icon: <MoreIcon outline />,\n          }),\n          overrideProps: {\n            menu: { items: overflowOpen ? collectOverflowItems() : [], popper: { positionFixed: true } },\n            menuOpen: overflowOpen,\n            onMenuOpenChange: (e, { menuOpen }) => {\n              _.invoke(props, 'onOverflowOpenChange', e, { ...props, overflowOpen: menuOpen });\n            },\n          },\n        })}\n      </Ref>\n    );\n  };\n\n  React.useEffect(() => {\n    const actualWindow: Window = context.target.defaultView;\n\n    actualWindow.cancelAnimationFrame(animationFrameId.current);\n    // Heads up! There are cases (like opening a portal and rendering the Toolbar there immediately) when rAF is necessary\n    animationFrameId.current = actualWindow.requestAnimationFrame(() => {\n      hideOverflowItems();\n    });\n\n    return () => {\n      if (animationFrameId.current !== undefined) {\n        context.target.defaultView.cancelAnimationFrame(animationFrameId.current);\n        animationFrameId.current = undefined;\n      }\n    };\n  });\n\n  const element = overflow ? (\n    <>\n      <Ref innerRef={containerRef}>\n        {getA11Props.unstable_wrapWithFocusZone(\n          <ElementType {...getA11Props('root', { className: classes.root, ...unhandledProps })}>\n            <div className={classes.overflowContainer} ref={overflowContainerRef}>\n              <ToolbarVariablesProvider value={variables}>\n                {childrenExist(children) ? children : renderItems(getVisibleItems())}\n                {renderOverflowItem(overflowItem)}\n              </ToolbarVariablesProvider>\n            </div>\n            <div className={classes.offsetMeasure} ref={offsetMeasureRef} />\n          </ElementType>,\n        )}\n      </Ref>\n      <EventListener listener={handleWindowResize} target={context.target.defaultView} type=\"resize\" />\n    </>\n  ) : (\n    <Ref innerRef={containerRef}>\n      {getA11Props.unstable_wrapWithFocusZone(\n        <ElementType {...getA11Props('root', { className: classes.root, ...unhandledProps })}>\n          <ToolbarVariablesProvider value={variables}>\n            {childrenExist(children) ? children : renderItems(items)}\n          </ToolbarVariablesProvider>\n        </ElementType>,\n      )}\n    </Ref>\n  );\n  setEnd();\n\n  return element;\n};\n\nToolbar.displayName = 'Toolbar';\n\nToolbar.propTypes = {\n  ...commonPropTypes.createCommon(),\n  items: customPropTypes.collectionShorthandWithKindProp(['divider', 'item', 'group', 'toggle', 'custom']),\n  overflow: PropTypes.bool,\n  overflowOpen: PropTypes.bool,\n  overflowItem: customPropTypes.shorthandAllowingChildren,\n  onOverflow: PropTypes.func,\n  onOverflowOpenChange: PropTypes.func,\n  getOverflowItems: PropTypes.func,\n};\nToolbar.defaultProps = {\n  accessibility: toolbarBehavior,\n  items: [],\n  overflowItem: {},\n};\nToolbar.handledProps = Object.keys(Toolbar.propTypes) as any;\n\nToolbar.CustomItem = ToolbarCustomItem;\nToolbar.Divider = ToolbarDivider;\nToolbar.Item = ToolbarItem;\nToolbar.Menu = ToolbarMenu;\nToolbar.MenuDivider = ToolbarMenuDivider;\nToolbar.MenuItem = ToolbarMenuItem;\nToolbar.MenuRadioGroup = ToolbarMenuRadioGroup;\nToolbar.RadioGroup = ToolbarRadioGroup;\n\nToolbar.create = createShorthandFactory({ Component: Toolbar, mappedProp: 'content' });\n\n/**\n * A Toolbar is a container for grouping a set of controls, often action controls (e.g. buttons) or input controls (e.g. checkboxes).\n *\n * @accessibility\n *  * Implements [ARIA Toolbar](https://www.w3.org/TR/wai-aria-practices-1.1/#toolbar) design pattern.\n * @accessibilityIssues\n * [Issue 988424: VoiceOver narrates selected for button in toolbar](https://bugs.chromium.org/p/chromium/issues/detail?id=988424)\n */\nexport default withSafeTypeForAs<typeof Toolbar, ToolbarProps>(Toolbar);\n"],"file":"Toolbar.js"}