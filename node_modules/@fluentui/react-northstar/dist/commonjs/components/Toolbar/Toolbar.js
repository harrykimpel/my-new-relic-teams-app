"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.toolbarClassName = void 0;

var _get2 = _interopRequireDefault(require("lodash/get"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _debounce2 = _interopRequireDefault(require("lodash/debounce"));

var _invoke2 = _interopRequireDefault(require("lodash/invoke"));

var _forEachRight2 = _interopRequireDefault(require("lodash/forEachRight"));

var _accessibility = require("@fluentui/accessibility");

var _reactBindings = require("@fluentui/react-bindings");

var _reactComponentEventListener = require("@fluentui/react-component-event-listener");

var _reactComponentRef = require("@fluentui/react-component-ref");

var _reactIconsNorthstar = require("@fluentui/react-icons-northstar");

var customPropTypes = _interopRequireWildcard(require("@fluentui/react-proptypes"));

var PropTypes = _interopRequireWildcard(require("prop-types"));

var React = _interopRequireWildcard(require("react"));

var _reactFela = require("react-fela");

var _types = require("../../types");

var _utils = require("../../utils");

var _ToolbarCustomItem = _interopRequireDefault(require("./ToolbarCustomItem"));

var _ToolbarDivider = _interopRequireDefault(require("./ToolbarDivider"));

var _ToolbarItem = _interopRequireDefault(require("./ToolbarItem"));

var _ToolbarMenu = _interopRequireDefault(require("./ToolbarMenu"));

var _ToolbarMenuDivider = _interopRequireDefault(require("./ToolbarMenuDivider"));

var _ToolbarMenuItem = _interopRequireDefault(require("./ToolbarMenuItem"));

var _ToolbarMenuRadioGroup = _interopRequireDefault(require("./ToolbarMenuRadioGroup"));

var _ToolbarRadioGroup = _interopRequireDefault(require("./ToolbarRadioGroup"));

var _toolbarVariablesContext = require("./toolbarVariablesContext");

// @ts-ignore
var WAS_FOCUSABLE_ATTRIBUTE = 'data-was-focusable';
var toolbarClassName = 'ui-toolbar';
exports.toolbarClassName = toolbarClassName;

var Toolbar = function Toolbar(props) {
  var context = React.useContext(_reactFela.ThemeContext);

  var _useTelemetry = (0, _reactBindings.useTelemetry)(Toolbar.displayName, context.telemetry),
      setStart = _useTelemetry.setStart,
      setEnd = _useTelemetry.setEnd;

  setStart();
  var accessibility = props.accessibility,
      className = props.className,
      children = props.children,
      design = props.design,
      getOverflowItems = props.getOverflowItems,
      items = props.items,
      overflow = props.overflow,
      overflowItem = props.overflowItem,
      overflowOpen = props.overflowOpen,
      styles = props.styles,
      variables = props.variables;
  var overflowContainerRef = React.useRef();
  var overflowItemRef = React.useRef();
  var offsetMeasureRef = React.useRef();
  var containerRef = React.useRef(); // index of the last visible item in Toolbar, the rest goes to overflow menu

  var lastVisibleItemIndex = React.useRef();
  var animationFrameId = React.useRef();
  var getA11Props = (0, _reactBindings.useAccessibility)(accessibility, {
    debugName: Toolbar.displayName,
    rtl: context.rtl
  });

  var _useStyles = (0, _reactBindings.useStyles)(Toolbar.displayName, {
    className: toolbarClassName,
    mapPropsToInlineStyles: function mapPropsToInlineStyles() {
      return {
        className: className,
        design: design,
        styles: styles,
        variables: variables
      };
    },
    rtl: context.rtl
  }),
      classes = _useStyles.classes;

  var ElementType = (0, _reactBindings.getElementType)(props);
  var unhandledProps = (0, _reactBindings.useUnhandledProps)(Toolbar.handledProps, props);

  var hide = function hide(el) {
    if (el.style.visibility === 'hidden') {
      return;
    }

    if (context.target.activeElement === el || el.contains(context.target.activeElement)) {
      if (containerRef.current) {
        var firstFocusableItem = (0, _reactBindings.getFirstFocusable)(containerRef.current, containerRef.current.firstElementChild);

        if (firstFocusableItem) {
          firstFocusableItem.focus();
        }
      }
    }

    el.style.visibility = 'hidden';
    var wasFocusable = el.getAttribute(_accessibility.IS_FOCUSABLE_ATTRIBUTE);

    if (wasFocusable) {
      el.setAttribute(WAS_FOCUSABLE_ATTRIBUTE, wasFocusable);
    }

    el.setAttribute(_accessibility.IS_FOCUSABLE_ATTRIBUTE, 'false');
  };

  var show = function show(el) {
    if (el.style.visibility !== 'hidden') {
      return false;
    }

    el.style.visibility = null;
    var wasFocusable = el.getAttribute(WAS_FOCUSABLE_ATTRIBUTE);

    if (wasFocusable) {
      el.setAttribute(_accessibility.IS_FOCUSABLE_ATTRIBUTE, wasFocusable);
      el.removeAttribute(WAS_FOCUSABLE_ATTRIBUTE);
    } else {
      el.removeAttribute(_accessibility.IS_FOCUSABLE_ATTRIBUTE);
    }

    return true;
  };
  /**
   * Checks if `item` overflows a `container`.
   * TODO: check and fix all margin combination
   */


  var isItemOverflowing = function isItemOverflowing(itemBoundingRect, containerBoundingRect) {
    return itemBoundingRect.right > containerBoundingRect.right || itemBoundingRect.left < containerBoundingRect.left;
  };
  /**
   * Checks if `item` would collide with eventual position of `overflowItem`.
   */


  var wouldItemCollide = function wouldItemCollide($item, itemBoundingRect, overflowItemBoundingRect, containerBoundingRect) {
    var actualWindow = context.target.defaultView;
    var wouldCollide;

    if (context.rtl) {
      var itemLeftMargin = parseFloat(actualWindow.getComputedStyle($item).marginLeft) || 0;
      wouldCollide = itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin < containerBoundingRect.left; // console.log('Collision [RTL]', {
      //   wouldCollide,
      //   'itemBoundingRect.left': itemBoundingRect.left,
      //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,
      //   itemRightMargin: itemLeftMargin,
      //   sum: itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin,
      //   'overflowContainerBoundingRect.left': containerBoundingRect.left,
      // })
    } else {
      var itemRightMargin = parseFloat(actualWindow.getComputedStyle($item).marginRight) || 0;
      wouldCollide = itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin > containerBoundingRect.right; // console.log('Collision', {
      //   wouldCollide,
      //   'itemBoundingRect.right': itemBoundingRect.right,
      //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,
      //   itemRightMargin,
      //   sum: itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin,
      //   'overflowContainerBoundingRect.right': containerBoundingRect.right,
      // })
    }

    return wouldCollide;
  };
  /**
   * Positions overflowItem next to lastVisible item
   * TODO: consider overflowItem margin
   */


  var setOverflowPosition = function setOverflowPosition($overflowItem, $lastVisibleItem, lastVisibleItemRect, containerBoundingRect, absolutePositioningOffset) {
    var actualWindow = context.target.defaultView;

    if ($lastVisibleItem) {
      if (context.rtl) {
        var lastVisibleItemMarginLeft = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginLeft) || 0;
        $overflowItem.style.right = "".concat(containerBoundingRect.right - lastVisibleItemRect.left + lastVisibleItemMarginLeft + absolutePositioningOffset.horizontal, "px");
      } else {
        var lastVisibleItemRightMargin = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginRight) || 0;
        $overflowItem.style.left = "".concat(lastVisibleItemRect.right - containerBoundingRect.left + lastVisibleItemRightMargin + absolutePositioningOffset.horizontal, "px");
      }
    } else {
      // there is no last visible item -> position the overflow as the first item
      lastVisibleItemIndex.current = -1;

      if (context.rtl) {
        $overflowItem.style.right = "".concat(absolutePositioningOffset.horizontal, "px");
      } else {
        $overflowItem.style.left = "".concat(absolutePositioningOffset.horizontal, "px");
      }
    }
  };

  var hideOverflowItems = function hideOverflowItems() {
    var $overflowContainer = overflowContainerRef.current;
    var $overflowItem = overflowItemRef.current;
    var $offsetMeasure = offsetMeasureRef.current;

    if (!$overflowContainer || !$overflowItem || !$offsetMeasure) {
      return;
    } // workaround: when resizing window with popup opened the container contents scroll for some reason


    if (context.rtl) {
      $overflowContainer.scrollTo(Number.MAX_SAFE_INTEGER, 0);
    } else {
      $overflowContainer.scrollTo(0, 0);
    }

    var $items = $overflowContainer.children;
    var overflowContainerBoundingRect = $overflowContainer.getBoundingClientRect();
    var overflowItemBoundingRect = $overflowItem.getBoundingClientRect();
    var offsetMeasureBoundingRect = $offsetMeasure.getBoundingClientRect(); // Absolute positioning offset
    // Overflow menu is absolutely positioned relative to root slot
    // If there is padding set on the root slot boundingClientRect computations use inner content box,
    // but absolute position is relative to root slot's PADDING box.
    // We compute absolute positioning offset
    // By measuring position of an offsetMeasure element absolutely positioned to 0,0.
    // TODO: replace by getComputedStyle('padding')

    var absolutePositioningOffset = {
      horizontal: context.rtl ? offsetMeasureBoundingRect.right - overflowContainerBoundingRect.right : overflowContainerBoundingRect.left - offsetMeasureBoundingRect.left,
      vertical: overflowContainerBoundingRect.top - offsetMeasureBoundingRect.top
    };
    var isOverflowing = false;
    var $lastVisibleItem;
    var lastVisibleItemRect; // check all items from the last one back

    (0, _forEachRight2.default)($items, function ($item, i) {
      if ($item === $overflowItem) {
        return true;
      }

      var itemBoundingRect = $item.getBoundingClientRect(); // if the item is out of the crop rectangle, hide it

      if (isItemOverflowing(itemBoundingRect, overflowContainerBoundingRect)) {
        isOverflowing = true; // console.log('Overflow', i, {
        //   item: [itemBoundingRect.left, itemBoundingRect.right],
        //   crop: [
        //     overflowContainerBoundingRect.left,
        //     overflowContainerBoundingRect.right,
        //     overflowContainerBoundingRect.width,
        //   ],
        //   container: $overflowContainer,
        // })

        hide($item);
        return true;
      } // if there is an overflow, check collision of remaining items with eventual overflow position


      if (isOverflowing && !$lastVisibleItem && wouldItemCollide($item, itemBoundingRect, overflowItemBoundingRect, overflowContainerBoundingRect)) {
        hide($item);
        return true;
      } // Remember the last visible item


      if (!$lastVisibleItem) {
        $lastVisibleItem = $item;
        lastVisibleItemRect = itemBoundingRect;
        lastVisibleItemIndex.current = i;
      }

      return show($item); // exit the loop when first visible item is found
    }); // if there is an overflow,  position and show overflow item, otherwise hide it

    if (isOverflowing || overflowOpen) {
      $overflowItem.style.position = 'absolute';
      setOverflowPosition($overflowItem, $lastVisibleItem, lastVisibleItemRect, overflowContainerBoundingRect, absolutePositioningOffset);
      show($overflowItem);
    } else {
      lastVisibleItemIndex.current = items.length - 1;
      hide($overflowItem);
    }

    (0, _invoke2.default)(props, 'onOverflow', lastVisibleItemIndex.current + 1);
  };

  var collectOverflowItems = function collectOverflowItems() {
    // console.log('getOverflowItems()', items.slice(lastVisibleItemIndex.current + 1))
    return getOverflowItems ? getOverflowItems(lastVisibleItemIndex.current + 1) : items.slice(lastVisibleItemIndex.current + 1);
  };

  var getVisibleItems = function getVisibleItems() {
    // console.log('allItems()', items)
    var end = overflowOpen ? lastVisibleItemIndex.current + 1 : items.length; // console.log('getVisibleItems()', items.slice(0, end))

    return items.slice(0, end);
  };

  var handleWindowResize = (0, _debounce2.default)(function (e) {
    hideOverflowItems();

    if (overflowOpen) {
      (0, _invoke2.default)(props, 'onOverflowOpenChange', e, Object.assign({}, props, {
        overflowOpen: false
      }));
    }
  }, 16);

  var renderItems = function renderItems(items) {
    return (0, _map2.default)(items, function (item) {
      var kind = (0, _get2.default)(item, 'kind', 'item');

      switch (kind) {
        case 'divider':
          return _ToolbarDivider.default.create(item);

        case 'group':
          return _ToolbarRadioGroup.default.create(item);

        case 'toggle':
          return _ToolbarItem.default.create(item, {
            defaultProps: function defaultProps() {
              return {
                accessibility: _accessibility.toggleButtonBehavior
              };
            }
          });

        case 'custom':
          return _ToolbarCustomItem.default.create(item);

        default:
          return _ToolbarItem.default.create(item);
      }
    });
  };

  var renderOverflowItem = function renderOverflowItem(overflowItem) {
    return React.createElement(_reactComponentRef.Ref, {
      innerRef: overflowItemRef
    }, _ToolbarItem.default.create(overflowItem, {
      defaultProps: function defaultProps() {
        return {
          icon: React.createElement(_reactIconsNorthstar.MoreIcon, {
            outline: true
          })
        };
      },
      overrideProps: {
        menu: {
          items: overflowOpen ? collectOverflowItems() : [],
          popper: {
            positionFixed: true
          }
        },
        menuOpen: overflowOpen,
        onMenuOpenChange: function onMenuOpenChange(e, _ref) {
          var menuOpen = _ref.menuOpen;
          (0, _invoke2.default)(props, 'onOverflowOpenChange', e, Object.assign({}, props, {
            overflowOpen: menuOpen
          }));
        }
      }
    }));
  };

  React.useEffect(function () {
    var actualWindow = context.target.defaultView;
    actualWindow.cancelAnimationFrame(animationFrameId.current); // Heads up! There are cases (like opening a portal and rendering the Toolbar there immediately) when rAF is necessary

    animationFrameId.current = actualWindow.requestAnimationFrame(function () {
      hideOverflowItems();
    });
    return function () {
      if (animationFrameId.current !== undefined) {
        context.target.defaultView.cancelAnimationFrame(animationFrameId.current);
        animationFrameId.current = undefined;
      }
    };
  });
  var element = overflow ? React.createElement(React.Fragment, null, React.createElement(_reactComponentRef.Ref, {
    innerRef: containerRef
  }, getA11Props.unstable_wrapWithFocusZone(React.createElement(ElementType, getA11Props('root', Object.assign({
    className: classes.root
  }, unhandledProps)), React.createElement("div", {
    className: classes.overflowContainer,
    ref: overflowContainerRef
  }, React.createElement(_toolbarVariablesContext.ToolbarVariablesProvider, {
    value: variables
  }, (0, _utils.childrenExist)(children) ? children : renderItems(getVisibleItems()), renderOverflowItem(overflowItem))), React.createElement("div", {
    className: classes.offsetMeasure,
    ref: offsetMeasureRef
  })))), React.createElement(_reactComponentEventListener.EventListener, {
    listener: handleWindowResize,
    target: context.target.defaultView,
    type: "resize"
  })) : React.createElement(_reactComponentRef.Ref, {
    innerRef: containerRef
  }, getA11Props.unstable_wrapWithFocusZone(React.createElement(ElementType, getA11Props('root', Object.assign({
    className: classes.root
  }, unhandledProps)), React.createElement(_toolbarVariablesContext.ToolbarVariablesProvider, {
    value: variables
  }, (0, _utils.childrenExist)(children) ? children : renderItems(items)))));
  setEnd();
  return element;
};

Toolbar.displayName = 'Toolbar';
Toolbar.propTypes = Object.assign({}, _utils.commonPropTypes.createCommon(), {
  items: customPropTypes.collectionShorthandWithKindProp(['divider', 'item', 'group', 'toggle', 'custom']),
  overflow: PropTypes.bool,
  overflowOpen: PropTypes.bool,
  overflowItem: customPropTypes.shorthandAllowingChildren,
  onOverflow: PropTypes.func,
  onOverflowOpenChange: PropTypes.func,
  getOverflowItems: PropTypes.func
});
Toolbar.defaultProps = {
  accessibility: _accessibility.toolbarBehavior,
  items: [],
  overflowItem: {}
};
Toolbar.handledProps = Object.keys(Toolbar.propTypes);
Toolbar.CustomItem = _ToolbarCustomItem.default;
Toolbar.Divider = _ToolbarDivider.default;
Toolbar.Item = _ToolbarItem.default;
Toolbar.Menu = _ToolbarMenu.default;
Toolbar.MenuDivider = _ToolbarMenuDivider.default;
Toolbar.MenuItem = _ToolbarMenuItem.default;
Toolbar.MenuRadioGroup = _ToolbarMenuRadioGroup.default;
Toolbar.RadioGroup = _ToolbarRadioGroup.default;
Toolbar.create = (0, _utils.createShorthandFactory)({
  Component: Toolbar,
  mappedProp: 'content'
});
/**
 * A Toolbar is a container for grouping a set of controls, often action controls (e.g. buttons) or input controls (e.g. checkboxes).
 *
 * @accessibility
 *  * Implements [ARIA Toolbar](https://www.w3.org/TR/wai-aria-practices-1.1/#toolbar) design pattern.
 * @accessibilityIssues
 * [Issue 988424: VoiceOver narrates selected for button in toolbar](https://bugs.chromium.org/p/chromium/issues/detail?id=988424)
 */

var _default = (0, _types.withSafeTypeForAs)(Toolbar);

exports.default = _default;
//# sourceMappingURL=Toolbar.js.map
