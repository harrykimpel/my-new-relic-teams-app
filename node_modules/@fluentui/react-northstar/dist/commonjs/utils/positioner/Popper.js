"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _reactBindings = require("@fluentui/react-bindings");

var _reactComponentRef = require("@fluentui/react-component-ref");

var PopperJs = _interopRequireWildcard(require("@popperjs/core"));

var React = _interopRequireWildcard(require("react"));

var _isBrowser = _interopRequireDefault(require("../isBrowser"));

var _getBoundary = _interopRequireDefault(require("./getBoundary"));

var _getScrollParent = _interopRequireDefault(require("./getScrollParent"));

var _positioningHelper = require("./positioningHelper");

/**
 * Memoize a result using deep equality. This hook has two advantages over
 * React.useMemo: it uses deep equality to compare memo keys, and it guarantees
 * that the memo function will only be called if the keys are unequal.
 * React.useMemo cannot be relied on to do this, since it is only a performance
 * optimization (see https://reactjs.org/docs/hooks-reference.html#usememo).
 *
 * Copied from https://github.com/apollographql/react-apollo/blob/master/packages/hooks/src/utils/useDeepMemo.ts.
 */
function useDeepMemo(memoFn, key) {
  var ref = React.useRef();

  if (!ref.current || !(0, _isEqual2.default)(key, ref.current.key)) {
    ref.current = {
      key: key,
      value: memoFn()
    };
  }

  return ref.current.value;
}
/**
 * Popper relies on the 3rd party library [Popper.js](https://github.com/FezVrasta/popper.js) for positioning.
 */


var Popper = function Popper(props) {
  var align = props.align,
      children = props.children,
      enabled = props.enabled,
      flipBoundary = props.flipBoundary,
      userModifiers = props.modifiers,
      offset = props.offset,
      overflowBoundary = props.overflowBoundary,
      pointerTargetRef = props.pointerTargetRef,
      position = props.position,
      positionFixed = props.positionFixed,
      _props$positioningDep = props.positioningDependencies,
      positioningDependencies = _props$positioningDep === void 0 ? [] : _props$positioningDep,
      rtl = props.rtl,
      targetRef = props.targetRef,
      unstable_pinned = props.unstable_pinned;
  var proposedPlacement = (0, _positioningHelper.getPlacement)({
    align: align,
    position: position,
    rtl: rtl
  });
  var popperRef = React.useRef();
  var contentRef = React.useRef(null);
  var latestPlacement = React.useRef(proposedPlacement);

  var _React$useState = React.useState(proposedPlacement),
      _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),
      computedPlacement = _React$useState2[0],
      setComputedPlacement = _React$useState2[1];

  var computedModifiers = useDeepMemo(function () {
    return [offset && {
      name: 'offset',
      options: {
        offset: rtl ? (0, _positioningHelper.applyRtlToOffset)(offset) : offset
      }
    }].concat((0, _toConsumableArray2.default)(userModifiers));
  }, [offset, flipBoundary, overflowBoundary, userModifiers]);
  var createInstance = React.useCallback(function () {
    var reference = targetRef && (0, _reactComponentRef.isRefObject)(targetRef) ? targetRef.current : targetRef;

    if (!enabled || !reference || !contentRef.current) {
      return;
    }

    var handleUpdate = function handleUpdate(_ref) {
      var state = _ref.state;

      // PopperJS performs computations that might update the computed placement: auto positioning, flipping the
      // placement in case the popper box should be rendered at the edge of the viewport and does not fit
      if (state.placement !== latestPlacement.current) {
        latestPlacement.current = state.placement;
        setComputedPlacement(state.placement);
      }
    };

    var hasDocument = (0, _isBrowser.default)();
    var scrollParentElement = hasDocument ? (0, _getScrollParent.default)(contentRef.current) : null;
    var hasScrollableElement = scrollParentElement ? scrollParentElement !== scrollParentElement.ownerDocument.body : false;
    var hasPointer = !!(pointerTargetRef && pointerTargetRef.current);
    var modifiers = [{
      name: 'flip',
      options: {
        flipVariations: true
      }
    },
    /**
     * unstable_pinned disables the flip modifier by setting flip.enabled to false; this
     * disables automatic repositioning of the popper box; it will always be placed according to
     * the values of `align` and `position` props, regardless of the size of the component, the
     * reference element or the viewport.
     */
    unstable_pinned && {
      name: 'flip',
      enabled: false
    },
    /**
     * When the popper box is placed in the context of a scrollable element, we need to set
     * preventOverflow.escapeWithReference to true and flip.boundariesElement to 'scrollParent'
     * (default is 'viewport') so that the popper box will stick with the targetRef when we
     * scroll targetRef out of the viewport.
     */
    hasScrollableElement && {
      name: 'flip',
      options: {
        boundary: 'clippingParents'
      }
    }, hasScrollableElement && {
      name: 'preventOverflow',
      options: {
        boundary: 'clippingParents'
      }
    }];
    var options = {
      placement: proposedPlacement,
      strategy: positionFixed ? 'fixed' : 'absolute',
      modifiers: [].concat((0, _toConsumableArray2.default)(modifiers), (0, _toConsumableArray2.default)(computedModifiers), [
      /**
       * This modifier is necessary in order to render the pointer. Refs are resolved in effects, so it can't be
       * placed under computed modifiers. Deep merge is not required as this modifier has only these properties.
       */
      {
        name: 'arrow',
        enabled: hasPointer,
        options: {
          element: pointerTargetRef && pointerTargetRef.current
        }
      }, flipBoundary && {
        name: 'flip',
        options: {
          altBoundary: true,
          boundary: (0, _getBoundary.default)(contentRef.current, flipBoundary)
        }
      }, overflowBoundary && {
        name: 'preventOverflow',
        options: {
          altBoundary: true,
          boundary: (0, _getBoundary.default)(contentRef.current, overflowBoundary)
        }
      }, {
        name: 'onUpdate',
        enabled: true,
        phase: 'afterWrite',
        fn: handleUpdate
      }]).filter(Boolean),
      onFirstUpdate: function onFirstUpdate(state) {
        return handleUpdate({
          state: state
        });
      }
    };
    popperRef.current = PopperJs.createPopper(reference, contentRef.current, options);
  }, [contentRef, computedModifiers, enabled, pointerTargetRef, positionFixed, proposedPlacement, targetRef]);
  var destroyInstance = React.useCallback(function () {
    if (popperRef.current) {
      popperRef.current.destroy();
      popperRef.current = null;
    }
  }, []);
  var scheduleUpdate = React.useCallback(function () {
    if (popperRef.current) {
      popperRef.current.update();
    }
  }, []);
  (0, _reactBindings.useIsomorphicLayoutEffect)(function () {
    createInstance();
    return destroyInstance;
  }, [createInstance]);
  React.useEffect(scheduleUpdate, [].concat((0, _toConsumableArray2.default)(positioningDependencies), [computedPlacement]));
  var child = typeof children === 'function' ? children({
    placement: computedPlacement,
    scheduleUpdate: scheduleUpdate
  }) : children;
  return child ? React.createElement(_reactComponentRef.Ref, {
    innerRef: contentRef
  }, React.Children.only(child)) : null;
};

Popper.defaultProps = {
  enabled: true,
  modifiers: [],
  positionFixed: false,
  positioningDependencies: []
};
var _default = Popper;
exports.default = _default;
//# sourceMappingURL=Popper.js.map
