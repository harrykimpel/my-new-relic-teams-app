"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var _ = require("lodash");
var React = require("react");
var enzyme_1 = require("enzyme");
var utils_1 = require("src/utils");
var utils_2 = require("test/utils");
var TestClass;
var createTestClass = function (options) {
    if (options === void 0) { options = {}; }
    var _a;
    return _a = /** @class */ (function (_super) {
            tslib_1.__extends(Test, _super);
            function Test() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Test.prototype.getInitialAutoControlledState = function () {
                return options.state;
            };
            Test.prototype.render = function () {
                return React.createElement("div", null);
            };
            return Test;
        }(utils_1.AutoControlledComponent)),
        _a.autoControlledProps = options.autoControlledProps,
        _a.defaultProps = options.defaultProps,
        _a;
};
var toDefaultName = function (prop) { return "default" + (prop.slice(0, 1).toUpperCase() + prop.slice(1)); };
var makeProps = function () { return ({
    computer: 'hardware',
    flux: 'capacitor',
    ion: 'belt',
}); };
var makeDefaultProps = function (props) {
    return _.transform(props, function (res, val, key) {
        res[toDefaultName(key)] = val;
    });
};
var getAutoControlledInstance = function (wrapper) {
    if (wrapper === void 0) { wrapper = enzyme_1.shallow(React.createElement(TestClass, null)); }
    return wrapper.instance();
};
describe('extending AutoControlledComponent', function () {
    beforeEach(function () {
        TestClass = createTestClass({ autoControlledProps: [], state: {} });
    });
    test('does not throw with a `null` state', function () {
        TestClass = createTestClass({ autoControlledProps: [], state: null });
        enzyme_1.shallow(React.createElement(TestClass, null));
    });
    test('getAutoControlledStateFromProps', function () {
        utils_2.consoleUtil.disableOnce();
        TestClass = createTestClass({
            autoControlledProps: ['open'],
            defaultProps: ['defaultOpen'],
            state: { open: false, value: 'initial' },
        });
        TestClass.getAutoControlledStateFromProps = function (props, state) {
            return {
                openProp: props.open,
                openState: state.open,
                modifiedValue: state.value + " + auto",
            };
        };
        var wrapper = enzyme_1.shallow(React.createElement(TestClass, { open: true }));
        expect(wrapper.state('open')).toBe(true);
        expect(wrapper.state('openProp')).toBe(true);
        // will be "true" because logic of ACC was executed before
        expect(wrapper.state('openState')).toBe(true);
        // "getAutoControlledStateFromProps" has access to whole state
        expect(wrapper.state('modifiedValue')).toBe('initial + auto');
        // original "value" will be kept
        expect(wrapper.state('value')).toBe('initial');
    });
    describe('trySetState', function () {
        test('sets state for autoControlledProps', function () {
            var _a;
            utils_2.consoleUtil.disableOnce();
            var autoControlledProps = _.keys(makeProps());
            var randomProp = _.sample(autoControlledProps);
            var randomValue = 'transmit';
            TestClass = createTestClass({ autoControlledProps: autoControlledProps });
            var wrapper = enzyme_1.shallow(React.createElement(TestClass, null));
            getAutoControlledInstance(wrapper).setState((_a = {}, _a[randomProp] = randomValue, _a));
            expect(wrapper.state()).toHaveProperty(randomProp, randomValue);
        });
        test('does not set state for props defined by the parent', function () {
            var _a;
            utils_2.consoleUtil.disableOnce();
            var props = makeProps();
            var autoControlledProps = _.keys(props);
            var randomProp = _.sample(autoControlledProps);
            var randomValue = "You can't calculate the alarm without synthesizing the auxiliary CSS port!";
            TestClass = createTestClass({ autoControlledProps: autoControlledProps, state: {} });
            var wrapper = enzyme_1.shallow(React.createElement(TestClass, tslib_1.__assign({}, props)));
            getAutoControlledInstance(wrapper).setState((_a = {}, _a[randomProp] = randomValue, _a));
            // not updated
            expect(wrapper.state()).not.toHaveProperty(randomProp, randomValue);
            // is original value
            expect(wrapper.state()).toHaveProperty(randomProp, props[randomProp]);
        });
        test('sets state for props passed as undefined by the parent', function () {
            var _a;
            utils_2.consoleUtil.disableOnce();
            var props = makeProps();
            var autoControlledProps = _.keys(props);
            var randomProp = _.sample(autoControlledProps);
            var randomValue = "hacking the system won't do anything, we need to back up the optical IB bandwidth!";
            props[randomProp] = undefined;
            TestClass = createTestClass({ autoControlledProps: autoControlledProps, state: {} });
            var wrapper = enzyme_1.shallow(React.createElement(TestClass, tslib_1.__assign({}, props)));
            getAutoControlledInstance(wrapper).setState((_a = {}, _a[randomProp] = randomValue, _a));
            expect(wrapper.state()).toHaveProperty(randomProp, randomValue);
        });
        test('does not set state for props passed as null by the parent', function () {
            var _a;
            utils_2.consoleUtil.disableOnce();
            var props = makeProps();
            var autoControlledProps = _.keys(props);
            var randomProp = _.sample(autoControlledProps);
            var randomValue = 'Try to synthesize the TCP bandwidth, maybe it will reboot the auxiliary panel!';
            props[randomProp] = null;
            TestClass = createTestClass({ autoControlledProps: autoControlledProps, state: {} });
            var wrapper = enzyme_1.shallow(React.createElement(TestClass, tslib_1.__assign({}, props)));
            getAutoControlledInstance(wrapper).setState((_a = {}, _a[randomProp] = randomValue, _a));
            // not updated
            expect(wrapper.state()).not.toHaveProperty(randomProp, randomValue);
            // is original value
            expect(wrapper.state()).toHaveProperty(randomProp, props[randomProp]);
        });
    });
    describe('initial state', function () {
        test('is derived from autoControlledProps in props', function () {
            utils_2.consoleUtil.disableOnce();
            var props = makeProps();
            var autoControlledProps = _.keys(props);
            TestClass = createTestClass({ autoControlledProps: autoControlledProps, state: {} });
            expect(enzyme_1.shallow(React.createElement(TestClass, tslib_1.__assign({}, props))).state()).toEqual(expect.objectContaining(tslib_1.__assign({ autoControlledProps: autoControlledProps }, props)));
        });
        test('does not include non autoControlledProps', function () {
            var props = makeProps();
            var wrapper = enzyme_1.shallow(React.createElement(TestClass, tslib_1.__assign({}, props)));
            _.each(props, function (val, key) {
                expect(wrapper.state()).not.toHaveProperty(key, val);
            });
        });
        test('includes non autoControlled state', function () {
            var props = makeProps();
            TestClass = createTestClass({ autoControlledProps: [], state: { foo: 'bar' } });
            expect(enzyme_1.shallow(React.createElement(TestClass, tslib_1.__assign({}, props))).state()).toHaveProperty('foo', 'bar');
        });
        test('uses the initial state if default and regular props are undefined', function () {
            utils_2.consoleUtil.disableOnce();
            var defaultProps = { defaultFoo: undefined };
            var autoControlledProps = ['foo'];
            TestClass = createTestClass({ autoControlledProps: autoControlledProps, defaultProps: defaultProps, state: { foo: 'bar' } });
            expect(enzyme_1.shallow(React.createElement(TestClass, { foo: undefined })).state()).toHaveProperty('foo', 'bar');
        });
        test('uses the default prop if the regular prop is undefined', function () {
            utils_2.consoleUtil.disableOnce();
            var defaultProps = { defaultFoo: 'default' };
            var autoControlledProps = ['foo'];
            TestClass = createTestClass({ autoControlledProps: autoControlledProps, defaultProps: defaultProps, state: {} });
            expect(enzyme_1.shallow(React.createElement(TestClass, { foo: undefined })).state()).toHaveProperty('foo', 'default');
        });
        test('uses the regular prop when a default is also defined', function () {
            utils_2.consoleUtil.disableOnce();
            var defaultProps = { defaultFoo: 'default' };
            var autoControlledProps = ['foo'];
            TestClass = createTestClass({ autoControlledProps: autoControlledProps, defaultProps: defaultProps, state: {} });
            expect(enzyme_1.shallow(React.createElement(TestClass, { foo: "initial" })).state()).toHaveProperty('foo', 'initial');
        });
        test('defaults "checked" to false if not present', function () {
            utils_2.consoleUtil.disableOnce();
            TestClass.autoControlledProps.push('checked');
            expect(enzyme_1.shallow(React.createElement(TestClass, null)).state()).toHaveProperty('checked', false);
        });
        test('defaults "value" to an empty string if not present', function () {
            utils_2.consoleUtil.disableOnce();
            TestClass.autoControlledProps.push('value');
            expect(enzyme_1.shallow(React.createElement(TestClass, null)).state()).toHaveProperty('value', '');
        });
        test('defaults "value" to an empty array if "multiple"', function () {
            utils_2.consoleUtil.disableOnce();
            TestClass.autoControlledProps.push('value');
            expect(enzyme_1.shallow(React.createElement(TestClass, { multiple: true })).state()).toHaveProperty('value', []);
        });
    });
    describe('default props', function () {
        test('are applied to state for props in autoControlledProps', function () {
            utils_2.consoleUtil.disableOnce();
            var props = makeProps();
            var autoControlledProps = _.keys(props);
            var defaultProps = makeDefaultProps(props);
            TestClass = createTestClass({ autoControlledProps: autoControlledProps, state: {} });
            expect(enzyme_1.shallow(React.createElement(TestClass, tslib_1.__assign({}, defaultProps))).state()).toEqual(expect.objectContaining(props));
        });
        test('are not applied to state for normal props', function () {
            var props = makeProps();
            var defaultProps = makeDefaultProps(props);
            var wrapper = enzyme_1.shallow(React.createElement(TestClass, tslib_1.__assign({}, defaultProps)));
            _.each(props, function (val, key) {
                expect(wrapper.state()).not.toHaveProperty(key, val);
            });
        });
        test('allows trySetState to work on non-default autoControlledProps', function () {
            var _a;
            utils_2.consoleUtil.disableOnce();
            var props = makeProps();
            var autoControlledProps = _.keys(props);
            var defaultProps = makeDefaultProps(props);
            var randomProp = _.sample(autoControlledProps);
            var randomValue = "You can't program the system without synthesizing the virtual AGP circuit!";
            TestClass = createTestClass({ autoControlledProps: autoControlledProps, state: {} });
            var wrapper = enzyme_1.shallow(React.createElement(TestClass, tslib_1.__assign({}, defaultProps)));
            getAutoControlledInstance(wrapper).setState((_a = {}, _a[randomProp] = randomValue, _a));
            expect(wrapper.state()).toHaveProperty(randomProp, randomValue);
        });
    });
    describe('changing props', function () {
        test('sets state for props in autoControlledProps', function () {
            var _a;
            utils_2.consoleUtil.disableOnce();
            var props = makeProps();
            var autoControlledProps = _.keys(props);
            var randomProp = _.sample(autoControlledProps);
            var randomValue = 'Try to synthesize the PNG protocol, maybe it will transmit the auxiliary firewall!';
            TestClass = createTestClass({ autoControlledProps: autoControlledProps, state: {} });
            var wrapper = enzyme_1.shallow(React.createElement(TestClass, tslib_1.__assign({}, props)));
            wrapper.setProps((_a = {}, _a[randomProp] = randomValue, _a));
            expect(wrapper.state()).toHaveProperty(randomProp, randomValue);
        });
        test('does not set state for props not in autoControlledProps', function () {
            var _a;
            utils_2.consoleUtil.disableOnce();
            var props = makeProps();
            var randomProp = _.sample(_.keys(props));
            var randomValue = 'We need to navigate the mobile GB bandwidth!';
            TestClass = createTestClass({ autoControlledProps: [], state: {} });
            var wrapper = enzyme_1.shallow(React.createElement(TestClass, tslib_1.__assign({}, props)));
            wrapper.setProps((_a = {}, _a[randomProp] = randomValue, _a));
            expect(wrapper.state()).not.toHaveProperty(randomProp, randomValue);
        });
        test('does not set state for default props when changed', function () {
            var _a;
            utils_2.consoleUtil.disableOnce();
            var props = makeProps();
            var autoControlledProps = _.keys(props);
            var defaultProps = makeDefaultProps(props);
            var randomDefaultProp = _.sample(defaultProps);
            var randomValue = 'We need to compress the solid state XML port!';
            TestClass = createTestClass({ autoControlledProps: autoControlledProps, state: {} });
            var wrapper = enzyme_1.shallow(React.createElement(TestClass, tslib_1.__assign({}, defaultProps)));
            wrapper.setProps((_a = {}, _a[randomDefaultProp] = randomValue, _a));
            expect(wrapper.state()).not.toHaveProperty(randomDefaultProp, randomValue);
        });
        test('keeps current state value when setting props undefined', function () {
            utils_2.consoleUtil.disableOnce();
            var autoControlledProps = ['foo'];
            var defaultProps = { defaultFoo: 'default' };
            TestClass = createTestClass({ autoControlledProps: autoControlledProps, defaultProps: defaultProps, state: {} });
            var wrapper = enzyme_1.shallow(React.createElement(TestClass, { foo: "initial" }));
            // default value
            expect(wrapper.state()).toHaveProperty('foo', 'initial');
            wrapper.setProps({ foo: undefined });
            expect(wrapper.state()).toHaveProperty('foo', 'initial');
        });
        test('does not set state for props passed as null by the parent', function () {
            var _a;
            utils_2.consoleUtil.disableOnce();
            var props = makeProps();
            var autoControlledProps = _.keys(props);
            var randomProp = _.sample(autoControlledProps);
            TestClass = createTestClass({ autoControlledProps: autoControlledProps, state: {} });
            var wrapper = enzyme_1.shallow(React.createElement(TestClass, tslib_1.__assign({}, props)));
            wrapper.setProps((_a = {}, _a[randomProp] = null, _a));
            expect(wrapper.state(randomProp)).toBe(null);
        });
    });
});
