"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var enzyme_1 = require("enzyme");
var faker = require("faker");
var React = require("react");
var Provider_1 = require("src/components/Provider/Provider");
var ProviderConsumer_1 = require("src/components/Provider/ProviderConsumer");
var felaRenderer_1 = require("src/utils/felaRenderer");
var PortalInner_1 = require("src/components/Portal/PortalInner");
var createDocumentMock = function () {
    var externalDocument = document.implementation.createDocument('http://www.w3.org/1999/xhtml', 'html', null);
    var externalWindow = {
        ontouchstart: function () { },
        addEventListener: function () { },
        removeEventListener: function () { },
    };
    externalDocument.documentElement.appendChild(externalDocument.createElement('body'));
    // `defaultView` is read-only by spec, getter is used as workaround
    // https://github.com/facebook/jest/issues/2227#issuecomment-430435133
    jest.spyOn(externalDocument, 'defaultView', 'get').mockReturnValue(externalWindow);
    return externalDocument;
};
describe('Provider', function () {
    test('is exported', function () {
        expect(require('src/index.ts').Provider).toEqual(Provider_1.default);
    });
    test('has a ProviderConsumer subcomponent', function () {
        expect(require('src/index.ts').Provider.Consumer).toEqual(ProviderConsumer_1.default);
    });
    describe('overwrite', function () {
        var outerTheme = { siteVariables: { brand: 'blue' } };
        var innerTheme = { siteVariables: { secondary: 'yellow' } };
        test('do not overwrite by default', function () {
            var wrapper = enzyme_1.mount(React.createElement(Provider_1.default, { theme: outerTheme },
                React.createElement(Provider_1.default, { theme: innerTheme },
                    React.createElement("span", null))));
            expect(wrapper
                .find('ThemeProvider')
                .at(1)
                .prop('theme')).toEqual(expect.objectContaining({
                theme: expect.objectContaining({
                    siteVariables: {
                        brand: 'blue',
                        secondary: 'yellow',
                        fontSizes: {},
                    },
                }),
            }));
        });
        test('does overwrite when is true', function () {
            var wrapper = enzyme_1.mount(React.createElement(Provider_1.default, { theme: outerTheme },
                React.createElement(Provider_1.default, { overwrite: true, theme: innerTheme },
                    React.createElement("span", null))));
            expect(wrapper
                .find('ThemeProvider')
                .at(1)
                .prop('theme')).toEqual(expect.objectContaining({
                theme: expect.objectContaining({
                    siteVariables: {
                        secondary: 'yellow',
                        fontSizes: {},
                    },
                }),
            }));
        });
    });
    describe('staticStyles', function () {
        test('are executed with the merged siteVariables', function () {
            var staticStyle = jest.fn();
            enzyme_1.mount(React.createElement(Provider_1.default, { theme: { siteVariables: { brand: 'blue', background: 'red' } } },
                React.createElement(Provider_1.default, { theme: {
                        siteVariables: { brand: 'yellow', gray: '#868686' },
                        staticStyles: [staticStyle],
                    } },
                    React.createElement("span", null))));
            expect(staticStyle).toHaveBeenCalledWith(expect.objectContaining({
                background: 'red',
                brand: 'yellow',
                gray: '#868686',
            }));
        });
        test('are executed only once', function () {
            var firstStaticStyle = jest.fn();
            var secondStaticStyle = jest.fn();
            var providerInstance = enzyme_1.mount(React.createElement(Provider_1.default, { theme: { staticStyles: [firstStaticStyle] } },
                React.createElement("span", null)));
            providerInstance.setProps({ theme: { staticStyles: [secondStaticStyle] } });
            expect(firstStaticStyle).toHaveBeenCalledTimes(1);
            expect(secondStaticStyle).not.toHaveBeenCalled();
        });
    });
    describe('RTL', function () {
        test('Sets dir="rtl" on the div for RTL theme', function () {
            var component = enzyme_1.mount(React.createElement(Provider_1.default, { id: "top-level-provider", rtl: true },
                React.createElement("span", null)));
            var providerDiv = component.find('div#top-level-provider');
            expect(providerDiv.exists()).toBe(true);
            expect(providerDiv.prop('dir')).toEqual('rtl');
        });
        test('Sets dir="ltr" on the div for LTR theme', function () {
            var component = enzyme_1.mount(React.createElement(Provider_1.default, { id: "top-level-provider" },
                React.createElement("span", null)));
            var providerDiv = component.find('div#top-level-provider');
            expect(providerDiv.exists()).toBe(true);
            expect(providerDiv.prop('dir')).toEqual('ltr');
        });
        var parentChildMatrix = [
            {
                parentIsRtl: true,
                childIsRtl: true,
                expectedChildDir: undefined,
            },
            {
                parentIsRtl: true,
                childIsRtl: undefined,
                expectedChildDir: undefined,
            },
            {
                parentIsRtl: true,
                childIsRtl: false,
                expectedChildDir: 'ltr',
            },
            {
                parentIsRtl: false,
                childIsRtl: false,
                expectedChildDir: undefined,
            },
            {
                parentIsRtl: false,
                childIsRtl: undefined,
                expectedChildDir: undefined,
            },
            {
                parentIsRtl: false,
                childIsRtl: true,
                expectedChildDir: 'rtl',
            },
        ];
        parentChildMatrix.forEach(function (_a) {
            var parentIsRtl = _a.parentIsRtl, childIsRtl = _a.childIsRtl, expectedChildDir = _a.expectedChildDir;
            test("Nested providers: parent is RTL: " + parentIsRtl + ", child is RTL: " + childIsRtl + ", expected child dir: " + expectedChildDir, function () {
                var component = enzyme_1.mount(React.createElement(Provider_1.default, { rtl: parentIsRtl },
                    React.createElement(Provider_1.default, { id: "nested-provider", rtl: childIsRtl },
                        React.createElement("span", null))));
                var nestedProviderDiv = component.find('div#nested-provider');
                expect(nestedProviderDiv.exists()).toBe(true);
                expect(nestedProviderDiv.prop('dir')).toEqual(expectedChildDir);
            });
        });
    });
    describe('calls provided renderer', function () {
        test('calls renderFont', function () {
            var theme = {
                fontFaces: [
                    {
                        name: 'Segoe UI',
                        paths: ['public/fonts/segoe-ui-regular.woff2'],
                        props: { fontWeight: 400 },
                    },
                ],
            };
            var renderer = felaRenderer_1.createRenderer();
            var renderFont = jest.spyOn(renderer, 'renderFont');
            enzyme_1.mount(React.createElement(Provider_1.default, { theme: theme, renderer: renderer },
                React.createElement("div", null)));
            expect(renderFont).toHaveBeenCalled();
        });
    });
    test('calls renderStatic', function () {
        var theme = {
            staticStyles: [
                {
                    a: {
                        textDecoration: 'none',
                    },
                },
            ],
        };
        var renderer = felaRenderer_1.createRenderer();
        var renderStatic = jest.spyOn(renderer, 'renderStatic');
        enzyme_1.mount(React.createElement(Provider_1.default, { theme: theme, renderer: renderer },
            React.createElement("div", null)));
        expect(renderStatic).toHaveBeenCalled();
    });
    describe('target', function () {
        test('performs whatinput init on first Provider mount', function () {
            var externalDocument = createDocumentMock();
            var addEventListener = jest.spyOn(externalDocument.defaultView, 'addEventListener');
            var setAttribute = jest.spyOn(externalDocument.documentElement, 'setAttribute');
            enzyme_1.mount(React.createElement(Provider_1.default, { id: "first-provider", target: externalDocument },
                React.createElement(Provider_1.default, { id: "second-provider", target: externalDocument },
                    React.createElement("div", null))));
            // mousedown + touchstart + touchend + keyup + keydown
            expect(addEventListener).toHaveBeenCalledTimes(5);
            expect(setAttribute).toHaveBeenCalledWith('data-whatinput', expect.any(String));
        });
        test('performs whatinput cleanup on last Provider unmount', function () {
            var externalDocument = createDocumentMock();
            var removeEventListener = jest.spyOn(externalDocument.defaultView, 'removeEventListener');
            var wrapper = enzyme_1.mount(React.createElement(Provider_1.default, { id: "first-provider", target: externalDocument },
                React.createElement(Provider_1.default, { id: "second-provider", target: externalDocument },
                    React.createElement("div", null))));
            wrapper.unmount();
            // mousedown + touchstart + touchend + keyup + keydown
            expect(removeEventListener).toHaveBeenCalledTimes(5);
        });
    });
    describe('document.body', function () {
        it('adds an element to document.body', function () {
            var className = faker.lorem.word();
            var wrapper = enzyme_1.mount(React.createElement(Provider_1.default, { className: className },
                React.createElement("div", null)));
            expect(document.querySelector("." + className)).toBeInTheDocument();
            // element should be removed on unmount
            wrapper.unmount();
            expect(document.querySelector("." + className)).not.toBeInTheDocument();
        });
        it('reacts on "className" update and keeps node in HTML tree', function () {
            var className = faker.lorem.word();
            var wrapper = enzyme_1.mount(React.createElement(Provider_1.default, { className: className },
                React.createElement(PortalInner_1.default, null,
                    React.createElement("div", { id: "sample" }))));
            expect(document.querySelector("." + className)).toBeInTheDocument();
            expect(document.querySelector("." + className + " #sample")).toBeInTheDocument();
            var newClassName = faker.lorem.word();
            wrapper.setProps({ className: newClassName });
            expect(document.querySelector("." + className)).not.toBeInTheDocument();
            expect(document.querySelector("." + newClassName)).toBeInTheDocument();
            expect(document.querySelector("." + newClassName + " #sample")).toBeInTheDocument();
        });
    });
});
