"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
// TODO:
// vertical - padding variable?
var accessibility_1 = require("@fluentui/accessibility");
var customPropTypes = require("@fluentui/react-proptypes");
var _ = require("lodash");
var PropTypes = require("prop-types");
var React = require("react");
var utils_1 = require("../../utils");
var RadioGroupItem_1 = require("./RadioGroupItem");
var types_1 = require("../../types");
exports.radioGroupClassName = 'ui-radiogroup';
var RadioGroup = /** @class */ (function (_super) {
    tslib_1.__extends(RadioGroup, _super);
    function RadioGroup() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.actionHandlers = {
            nextItem: function (event) { return _this.setCheckedItem(event, 1); },
            prevItem: function (event) { return _this.setCheckedItem(event, -1); },
        };
        _this.getItemProps = function (item) {
            return item.props || item;
        };
        _this.setCheckedItem = function (event, direction) {
            var nextItem = _this.findNextEnabledCheckedItem(direction);
            if (nextItem) {
                _this.setCheckedValue({
                    checkedValue: nextItem.value,
                    shouldFocus: true,
                    event: event,
                    props: nextItem,
                });
            }
            event.preventDefault();
        };
        _this.findNextEnabledCheckedItem = function (direction) {
            if (!_this.props.items || !_this.props.items.length) {
                return undefined;
            }
            var currentIndex = 
            // if none of the values selected, set current index to the first item
            _this.state.checkedValue !== undefined
                ? _.findIndex(_this.props.items, function (item) { return _this.getItemProps(item).value === _this.state.checkedValue; })
                : 0;
            for (var newIndex = currentIndex + direction; newIndex !== currentIndex; newIndex += direction) {
                if (newIndex < 0) {
                    newIndex = _this.props.items.length - 1;
                }
                else if (newIndex >= _this.props.items.length) {
                    newIndex = 0;
                }
                if (newIndex === currentIndex) {
                    return undefined;
                }
                var itemProps = _this.getItemProps(_this.props.items[newIndex]);
                if (!itemProps.disabled) {
                    return itemProps;
                }
            }
            return undefined;
        };
        _this.handleItemOverrides = function (predefinedProps) { return ({
            checked: typeof _this.state.checkedValue !== 'undefined' && _this.state.checkedValue === predefinedProps.value,
            onClick: function (event, itemProps) {
                var value = itemProps.value, disabled = itemProps.disabled;
                if (!disabled && value !== _this.state.checkedValue) {
                    _this.setCheckedValue({ checkedValue: value, shouldFocus: false, event: event, props: itemProps });
                }
                _.invoke(predefinedProps, 'onClick', event, itemProps);
            },
            shouldFocus: _this.state.shouldFocus,
        }); };
        _this.renderItems = function (vertical) {
            var items = _this.props.items;
            var isNoneValueSelected = _this.state.checkedValue === undefined;
            return _.map(items, function (item, index) {
                return RadioGroupItem_1.default.create(item, {
                    defaultProps: function () { return (tslib_1.__assign({ vertical: vertical }, (index === 0 && isNoneValueSelected && { tabIndex: 0 }))); },
                    overrideProps: _this.handleItemOverrides,
                });
            });
        };
        return _this;
    }
    RadioGroup.prototype.renderComponent = function (_a) {
        var ElementType = _a.ElementType, classes = _a.classes, accessibility = _a.accessibility, unhandledProps = _a.unhandledProps;
        var _b = this.props, children = _b.children, vertical = _b.vertical;
        return (React.createElement(ElementType, tslib_1.__assign({}, accessibility.attributes.root, utils_1.rtlTextContainer.getAttributes({ forElements: [children] }), unhandledProps, utils_1.applyAccessibilityKeyHandlers(accessibility.keyHandlers.root, unhandledProps), { className: classes.root }), utils_1.childrenExist(children) ? children : this.renderItems(vertical)));
    };
    RadioGroup.prototype.setCheckedValue = function (_a) {
        var checkedValue = _a.checkedValue, shouldFocus = _a.shouldFocus, event = _a.event, props = _a.props;
        this.setState({ checkedValue: checkedValue, shouldFocus: shouldFocus });
        _.invoke(this.props, 'onCheckedValueChange', event, props);
    };
    RadioGroup.displayName = 'RadioGroup';
    RadioGroup.deprecated_className = exports.radioGroupClassName;
    RadioGroup.propTypes = tslib_1.__assign(tslib_1.__assign({}, utils_1.commonPropTypes.createCommon({
        content: false,
    })), { checkedValue: PropTypes.oneOfType([PropTypes.number, PropTypes.string]), defaultCheckedValue: PropTypes.oneOfType([PropTypes.number, PropTypes.string]), items: customPropTypes.collectionShorthand, onCheckedValueChange: PropTypes.func, vertical: PropTypes.bool });
    RadioGroup.defaultProps = {
        as: 'div',
        accessibility: accessibility_1.radioGroupBehavior,
    };
    RadioGroup.autoControlledProps = ['checkedValue'];
    RadioGroup.Item = RadioGroupItem_1.default;
    return RadioGroup;
}(utils_1.AutoControlledComponent));
/**
 * A RadioGroup allows user to select a value from a small set of mutually exclusive options.
 *
 * @accessibility
 * Implements [ARIA Radio Group](https://www.w3.org/TR/wai-aria-practices-1.1/#radiobutton) design pattern.
 */
exports.default = types_1.withSafeTypeForAs(RadioGroup);
