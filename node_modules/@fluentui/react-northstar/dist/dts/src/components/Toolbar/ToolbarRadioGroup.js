"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var accessibility_1 = require("@fluentui/accessibility");
var react_bindings_1 = require("@fluentui/react-bindings");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var customPropTypes = require("@fluentui/react-proptypes");
var styles_1 = require("@fluentui/styles");
var _ = require("lodash");
var PropTypes = require("prop-types");
var React = require("react");
// @ts-ignore
var react_fela_1 = require("react-fela");
var utils_1 = require("../../utils");
var types_1 = require("../../types");
var ToolbarDivider_1 = require("./ToolbarDivider");
var ToolbarItem_1 = require("./ToolbarItem");
var toolbarVariablesContext_1 = require("./toolbarVariablesContext");
exports.toolbarRadioGroupClassName = 'ui-toolbars'; // FIXME: required by getComponentInfo/isConformant. But this is group inside a toolbar not a group of toolbars
var ToolbarRadioGroup = function (props) {
    var context = React.useContext(react_fela_1.ThemeContext);
    var _a = react_bindings_1.useTelemetry(ToolbarRadioGroup.displayName, context.telemetry), setStart = _a.setStart, setEnd = _a.setEnd;
    setStart();
    var accessibility = props.accessibility, activeIndex = props.activeIndex, children = props.children, className = props.className, design = props.design, items = props.items, variables = props.variables, styles = props.styles;
    var itemRefs = [];
    var parentVariables = React.useContext(toolbarVariablesContext_1.ToolbarVariablesContext);
    var mergedVariables = styles_1.mergeComponentVariables(parentVariables, variables);
    var getA11yProps = react_bindings_1.useAccessibility(accessibility, {
        debugName: ToolbarRadioGroup.displayName,
        actionHandlers: {
            nextItem: function (event) { return setFocusedItem(event, 1); },
            prevItem: function (event) { return setFocusedItem(event, -1); },
        },
        rtl: context.rtl,
    });
    var classes = react_bindings_1.useStyles(ToolbarRadioGroup.displayName, {
        className: exports.toolbarRadioGroupClassName,
        mapPropsToInlineStyles: function () { return ({ className: className, design: design, styles: styles, variables: mergedVariables }); },
        rtl: context.rtl,
    }).classes;
    var setFocusedItem = function (event, direction) {
        // filter items which are not disabled
        var filteredRadioItems = _.filter(itemRefs, function (item, index) {
            var currentItem = items[index];
            return currentItem && !currentItem.disabled;
        });
        // get the index of currently focused element (w/ tabindex = 0) or the first one as default
        var currentFocusedIndex = _.findIndex(filteredRadioItems, function (item) {
            return item.current.tabIndex === 0;
        }) || 0;
        var itemsLength = filteredRadioItems.length;
        var nextIndex = currentFocusedIndex + direction;
        if (nextIndex >= itemsLength) {
            nextIndex = 0;
        }
        if (nextIndex < 0) {
            nextIndex = itemsLength - 1;
        }
        var nextItemToFocus = filteredRadioItems[nextIndex].current;
        if (nextItemToFocus) {
            nextItemToFocus.focus();
        }
        if (context.target.activeElement === nextItemToFocus) {
            event.stopPropagation();
        }
        event.preventDefault();
    };
    var renderItems = function () {
        return _.map(items, function (item, index) {
            var kind = _.get(item, 'kind', 'item');
            var ref = React.createRef();
            itemRefs[index] = ref;
            if (kind === 'divider') {
                return ToolbarDivider_1.default.create(item);
            }
            var toolbarItem = ToolbarItem_1.default.create(item, {
                defaultProps: function () { return ({
                    accessibility: accessibility_1.toolbarRadioGroupItemBehavior,
                    active: activeIndex === index,
                }); },
            });
            return (React.createElement(react_component_ref_1.Ref, { innerRef: ref, key: toolbarItem.key }, toolbarItem));
        });
    };
    var ElementType = react_bindings_1.getElementType(props);
    var unhandledProps = react_bindings_1.useUnhandledProps(ToolbarRadioGroup.handledProps, props);
    var element = (React.createElement(ElementType, tslib_1.__assign({}, getA11yProps('root', tslib_1.__assign(tslib_1.__assign({}, unhandledProps), { className: classes.root }))),
        React.createElement(toolbarVariablesContext_1.ToolbarVariablesProvider, { value: mergedVariables }, utils_1.childrenExist(children) ? children : renderItems())));
    setEnd();
    return element;
};
ToolbarRadioGroup.displayName = 'ToolbarRadioGroup';
ToolbarRadioGroup.propTypes = tslib_1.__assign(tslib_1.__assign({}, utils_1.commonPropTypes.createCommon()), { activeIndex: PropTypes.number, items: customPropTypes.collectionShorthandWithKindProp(['divider', 'item']) });
ToolbarRadioGroup.handledProps = Object.keys(ToolbarRadioGroup.propTypes);
ToolbarRadioGroup.defaultProps = {
    accessibility: accessibility_1.toolbarRadioGroupBehavior,
};
ToolbarRadioGroup.create = utils_1.createShorthandFactory({
    Component: ToolbarRadioGroup,
    mappedProp: 'content',
});
/**
 * A ToolbarRadioGroup renders Toolbar item as a group of mutually exclusive options.
 * Component doesn't implement mutual exclusiveness, it just serves accessibility purposes.
 *
 * @accessibility
 * Implements [ARIA RadioGroup](https://www.w3.org/TR/wai-aria-practices/#radiobutton) design pattern.
 */
exports.default = types_1.withSafeTypeForAs(ToolbarRadioGroup);
