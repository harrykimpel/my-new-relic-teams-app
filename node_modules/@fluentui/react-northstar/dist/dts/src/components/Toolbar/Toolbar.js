"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var accessibility_1 = require("@fluentui/accessibility");
var react_bindings_1 = require("@fluentui/react-bindings");
var react_component_event_listener_1 = require("@fluentui/react-component-event-listener");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var react_icons_northstar_1 = require("@fluentui/react-icons-northstar");
var customPropTypes = require("@fluentui/react-proptypes");
var _ = require("lodash");
var PropTypes = require("prop-types");
var React = require("react");
// @ts-ignore
var react_fela_1 = require("react-fela");
var types_1 = require("../../types");
var utils_1 = require("../../utils");
var ToolbarCustomItem_1 = require("./ToolbarCustomItem");
var ToolbarDivider_1 = require("./ToolbarDivider");
var ToolbarItem_1 = require("./ToolbarItem");
var ToolbarMenu_1 = require("./ToolbarMenu");
var ToolbarMenuDivider_1 = require("./ToolbarMenuDivider");
var ToolbarMenuItem_1 = require("./ToolbarMenuItem");
var ToolbarMenuRadioGroup_1 = require("./ToolbarMenuRadioGroup");
var ToolbarRadioGroup_1 = require("./ToolbarRadioGroup");
var toolbarVariablesContext_1 = require("./toolbarVariablesContext");
var WAS_FOCUSABLE_ATTRIBUTE = 'data-was-focusable';
exports.toolbarClassName = 'ui-toolbar';
var Toolbar = function (props) {
    var context = React.useContext(react_fela_1.ThemeContext);
    var _a = react_bindings_1.useTelemetry(Toolbar.displayName, context.telemetry), setStart = _a.setStart, setEnd = _a.setEnd;
    setStart();
    var accessibility = props.accessibility, className = props.className, children = props.children, design = props.design, getOverflowItems = props.getOverflowItems, items = props.items, overflow = props.overflow, overflowItem = props.overflowItem, overflowOpen = props.overflowOpen, styles = props.styles, variables = props.variables;
    var overflowContainerRef = React.useRef();
    var overflowItemRef = React.useRef();
    var offsetMeasureRef = React.useRef();
    var containerRef = React.useRef();
    // index of the last visible item in Toolbar, the rest goes to overflow menu
    var lastVisibleItemIndex = React.useRef();
    var animationFrameId = React.useRef();
    var getA11Props = react_bindings_1.useAccessibility(accessibility, {
        debugName: Toolbar.displayName,
        rtl: context.rtl,
    });
    var classes = react_bindings_1.useStyles(Toolbar.displayName, {
        className: exports.toolbarClassName,
        mapPropsToInlineStyles: function () { return ({
            className: className,
            design: design,
            styles: styles,
            variables: variables,
        }); },
        rtl: context.rtl,
    }).classes;
    var ElementType = react_bindings_1.getElementType(props);
    var unhandledProps = react_bindings_1.useUnhandledProps(Toolbar.handledProps, props);
    var hide = function (el) {
        if (el.style.visibility === 'hidden') {
            return;
        }
        if (context.target.activeElement === el || el.contains(context.target.activeElement)) {
            if (containerRef.current) {
                var firstFocusableItem = react_bindings_1.getFirstFocusable(containerRef.current, containerRef.current.firstElementChild);
                if (firstFocusableItem) {
                    firstFocusableItem.focus();
                }
            }
        }
        el.style.visibility = 'hidden';
        var wasFocusable = el.getAttribute(accessibility_1.IS_FOCUSABLE_ATTRIBUTE);
        if (wasFocusable) {
            el.setAttribute(WAS_FOCUSABLE_ATTRIBUTE, wasFocusable);
        }
        el.setAttribute(accessibility_1.IS_FOCUSABLE_ATTRIBUTE, 'false');
    };
    var show = function (el) {
        if (el.style.visibility !== 'hidden') {
            return false;
        }
        el.style.visibility = null;
        var wasFocusable = el.getAttribute(WAS_FOCUSABLE_ATTRIBUTE);
        if (wasFocusable) {
            el.setAttribute(accessibility_1.IS_FOCUSABLE_ATTRIBUTE, wasFocusable);
            el.removeAttribute(WAS_FOCUSABLE_ATTRIBUTE);
        }
        else {
            el.removeAttribute(accessibility_1.IS_FOCUSABLE_ATTRIBUTE);
        }
        return true;
    };
    /**
     * Checks if `item` overflows a `container`.
     * TODO: check and fix all margin combination
     */
    var isItemOverflowing = function (itemBoundingRect, containerBoundingRect) {
        return itemBoundingRect.right > containerBoundingRect.right || itemBoundingRect.left < containerBoundingRect.left;
    };
    /**
     * Checks if `item` would collide with eventual position of `overflowItem`.
     */
    var wouldItemCollide = function ($item, itemBoundingRect, overflowItemBoundingRect, containerBoundingRect) {
        var actualWindow = context.target.defaultView;
        var wouldCollide;
        if (context.rtl) {
            var itemLeftMargin = parseFloat(actualWindow.getComputedStyle($item).marginLeft) || 0;
            wouldCollide =
                itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin < containerBoundingRect.left;
            // console.log('Collision [RTL]', {
            //   wouldCollide,
            //   'itemBoundingRect.left': itemBoundingRect.left,
            //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,
            //   itemRightMargin: itemLeftMargin,
            //   sum: itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin,
            //   'overflowContainerBoundingRect.left': containerBoundingRect.left,
            // })
        }
        else {
            var itemRightMargin = parseFloat(actualWindow.getComputedStyle($item).marginRight) || 0;
            wouldCollide =
                itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin > containerBoundingRect.right;
            // console.log('Collision', {
            //   wouldCollide,
            //   'itemBoundingRect.right': itemBoundingRect.right,
            //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,
            //   itemRightMargin,
            //   sum: itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin,
            //   'overflowContainerBoundingRect.right': containerBoundingRect.right,
            // })
        }
        return wouldCollide;
    };
    /**
     * Positions overflowItem next to lastVisible item
     * TODO: consider overflowItem margin
     */
    var setOverflowPosition = function ($overflowItem, $lastVisibleItem, lastVisibleItemRect, containerBoundingRect, absolutePositioningOffset) {
        var actualWindow = context.target.defaultView;
        if ($lastVisibleItem) {
            if (context.rtl) {
                var lastVisibleItemMarginLeft = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginLeft) || 0;
                $overflowItem.style.right = containerBoundingRect.right -
                    lastVisibleItemRect.left +
                    lastVisibleItemMarginLeft +
                    absolutePositioningOffset.horizontal + "px";
            }
            else {
                var lastVisibleItemRightMargin = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginRight) || 0;
                $overflowItem.style.left = lastVisibleItemRect.right -
                    containerBoundingRect.left +
                    lastVisibleItemRightMargin +
                    absolutePositioningOffset.horizontal + "px";
            }
        }
        else {
            // there is no last visible item -> position the overflow as the first item
            lastVisibleItemIndex.current = -1;
            if (context.rtl) {
                $overflowItem.style.right = absolutePositioningOffset.horizontal + "px";
            }
            else {
                $overflowItem.style.left = absolutePositioningOffset.horizontal + "px";
            }
        }
    };
    var hideOverflowItems = function () {
        var $overflowContainer = overflowContainerRef.current;
        var $overflowItem = overflowItemRef.current;
        var $offsetMeasure = offsetMeasureRef.current;
        if (!$overflowContainer || !$overflowItem || !$offsetMeasure) {
            return;
        }
        // workaround: when resizing window with popup opened the container contents scroll for some reason
        if (context.rtl) {
            $overflowContainer.scrollTo(Number.MAX_SAFE_INTEGER, 0);
        }
        else {
            $overflowContainer.scrollTo(0, 0);
        }
        var $items = $overflowContainer.children;
        var overflowContainerBoundingRect = $overflowContainer.getBoundingClientRect();
        var overflowItemBoundingRect = $overflowItem.getBoundingClientRect();
        var offsetMeasureBoundingRect = $offsetMeasure.getBoundingClientRect();
        // Absolute positioning offset
        // Overflow menu is absolutely positioned relative to root slot
        // If there is padding set on the root slot boundingClientRect computations use inner content box,
        // but absolute position is relative to root slot's PADDING box.
        // We compute absolute positioning offset
        // By measuring position of an offsetMeasure element absolutely positioned to 0,0.
        // TODO: replace by getComputedStyle('padding')
        var absolutePositioningOffset = {
            horizontal: context.rtl
                ? offsetMeasureBoundingRect.right - overflowContainerBoundingRect.right
                : overflowContainerBoundingRect.left - offsetMeasureBoundingRect.left,
            vertical: overflowContainerBoundingRect.top - offsetMeasureBoundingRect.top,
        };
        var isOverflowing = false;
        var $lastVisibleItem;
        var lastVisibleItemRect;
        // check all items from the last one back
        _.forEachRight($items, function ($item, i) {
            if ($item === $overflowItem) {
                return true;
            }
            var itemBoundingRect = $item.getBoundingClientRect();
            // if the item is out of the crop rectangle, hide it
            if (isItemOverflowing(itemBoundingRect, overflowContainerBoundingRect)) {
                isOverflowing = true;
                // console.log('Overflow', i, {
                //   item: [itemBoundingRect.left, itemBoundingRect.right],
                //   crop: [
                //     overflowContainerBoundingRect.left,
                //     overflowContainerBoundingRect.right,
                //     overflowContainerBoundingRect.width,
                //   ],
                //   container: $overflowContainer,
                // })
                hide($item);
                return true;
            }
            // if there is an overflow, check collision of remaining items with eventual overflow position
            if (isOverflowing &&
                !$lastVisibleItem &&
                wouldItemCollide($item, itemBoundingRect, overflowItemBoundingRect, overflowContainerBoundingRect)) {
                hide($item);
                return true;
            }
            // Remember the last visible item
            if (!$lastVisibleItem) {
                $lastVisibleItem = $item;
                lastVisibleItemRect = itemBoundingRect;
                lastVisibleItemIndex.current = i;
            }
            return show($item); // exit the loop when first visible item is found
        });
        // if there is an overflow,  position and show overflow item, otherwise hide it
        if (isOverflowing || overflowOpen) {
            $overflowItem.style.position = 'absolute';
            setOverflowPosition($overflowItem, $lastVisibleItem, lastVisibleItemRect, overflowContainerBoundingRect, absolutePositioningOffset);
            show($overflowItem);
        }
        else {
            lastVisibleItemIndex.current = items.length - 1;
            hide($overflowItem);
        }
        _.invoke(props, 'onOverflow', lastVisibleItemIndex.current + 1);
    };
    var collectOverflowItems = function () {
        // console.log('getOverflowItems()', items.slice(lastVisibleItemIndex.current + 1))
        return getOverflowItems
            ? getOverflowItems(lastVisibleItemIndex.current + 1)
            : items.slice(lastVisibleItemIndex.current + 1);
    };
    var getVisibleItems = function () {
        // console.log('allItems()', items)
        var end = overflowOpen ? lastVisibleItemIndex.current + 1 : items.length;
        // console.log('getVisibleItems()', items.slice(0, end))
        return items.slice(0, end);
    };
    var handleWindowResize = _.debounce(function (e) {
        hideOverflowItems();
        if (overflowOpen) {
            _.invoke(props, 'onOverflowOpenChange', e, tslib_1.__assign(tslib_1.__assign({}, props), { overflowOpen: false }));
        }
    }, 16);
    var renderItems = function (items) {
        return _.map(items, function (item) {
            var kind = _.get(item, 'kind', 'item');
            switch (kind) {
                case 'divider':
                    return ToolbarDivider_1.default.create(item);
                case 'group':
                    return ToolbarRadioGroup_1.default.create(item);
                case 'toggle':
                    return ToolbarItem_1.default.create(item, {
                        defaultProps: function () { return ({ accessibility: accessibility_1.toggleButtonBehavior }); },
                    });
                case 'custom':
                    return ToolbarCustomItem_1.default.create(item);
                default:
                    return ToolbarItem_1.default.create(item);
            }
        });
    };
    var renderOverflowItem = function (overflowItem) {
        return (React.createElement(react_component_ref_1.Ref, { innerRef: overflowItemRef }, ToolbarItem_1.default.create(overflowItem, {
            defaultProps: function () { return ({
                icon: React.createElement(react_icons_northstar_1.MoreIcon, { outline: true }),
            }); },
            overrideProps: {
                menu: { items: overflowOpen ? collectOverflowItems() : [], popper: { positionFixed: true } },
                menuOpen: overflowOpen,
                onMenuOpenChange: function (e, _a) {
                    var menuOpen = _a.menuOpen;
                    _.invoke(props, 'onOverflowOpenChange', e, tslib_1.__assign(tslib_1.__assign({}, props), { overflowOpen: menuOpen }));
                },
            },
        })));
    };
    React.useEffect(function () {
        var actualWindow = context.target.defaultView;
        actualWindow.cancelAnimationFrame(animationFrameId.current);
        // Heads up! There are cases (like opening a portal and rendering the Toolbar there immediately) when rAF is necessary
        animationFrameId.current = actualWindow.requestAnimationFrame(function () {
            hideOverflowItems();
        });
        return function () {
            if (animationFrameId.current !== undefined) {
                context.target.defaultView.cancelAnimationFrame(animationFrameId.current);
                animationFrameId.current = undefined;
            }
        };
    });
    var element = overflow ? (React.createElement(React.Fragment, null,
        React.createElement(react_component_ref_1.Ref, { innerRef: containerRef }, getA11Props.unstable_wrapWithFocusZone(React.createElement(ElementType, tslib_1.__assign({}, getA11Props('root', tslib_1.__assign({ className: classes.root }, unhandledProps))),
            React.createElement("div", { className: classes.overflowContainer, ref: overflowContainerRef },
                React.createElement(toolbarVariablesContext_1.ToolbarVariablesProvider, { value: variables },
                    utils_1.childrenExist(children) ? children : renderItems(getVisibleItems()),
                    renderOverflowItem(overflowItem))),
            React.createElement("div", { className: classes.offsetMeasure, ref: offsetMeasureRef })))),
        React.createElement(react_component_event_listener_1.EventListener, { listener: handleWindowResize, target: context.target.defaultView, type: "resize" }))) : (React.createElement(react_component_ref_1.Ref, { innerRef: containerRef }, getA11Props.unstable_wrapWithFocusZone(React.createElement(ElementType, tslib_1.__assign({}, getA11Props('root', tslib_1.__assign({ className: classes.root }, unhandledProps))),
        React.createElement(toolbarVariablesContext_1.ToolbarVariablesProvider, { value: variables }, utils_1.childrenExist(children) ? children : renderItems(items))))));
    setEnd();
    return element;
};
Toolbar.displayName = 'Toolbar';
Toolbar.propTypes = tslib_1.__assign(tslib_1.__assign({}, utils_1.commonPropTypes.createCommon()), { items: customPropTypes.collectionShorthandWithKindProp(['divider', 'item', 'group', 'toggle', 'custom']), overflow: PropTypes.bool, overflowOpen: PropTypes.bool, overflowItem: customPropTypes.shorthandAllowingChildren, onOverflow: PropTypes.func, onOverflowOpenChange: PropTypes.func, getOverflowItems: PropTypes.func });
Toolbar.defaultProps = {
    accessibility: accessibility_1.toolbarBehavior,
    items: [],
    overflowItem: {},
};
Toolbar.handledProps = Object.keys(Toolbar.propTypes);
Toolbar.CustomItem = ToolbarCustomItem_1.default;
Toolbar.Divider = ToolbarDivider_1.default;
Toolbar.Item = ToolbarItem_1.default;
Toolbar.Menu = ToolbarMenu_1.default;
Toolbar.MenuDivider = ToolbarMenuDivider_1.default;
Toolbar.MenuItem = ToolbarMenuItem_1.default;
Toolbar.MenuRadioGroup = ToolbarMenuRadioGroup_1.default;
Toolbar.RadioGroup = ToolbarRadioGroup_1.default;
Toolbar.create = utils_1.createShorthandFactory({ Component: Toolbar, mappedProp: 'content' });
/**
 * A Toolbar is a container for grouping a set of controls, often action controls (e.g. buttons) or input controls (e.g. checkboxes).
 *
 * @accessibility
 *  * Implements [ARIA Toolbar](https://www.w3.org/TR/wai-aria-practices-1.1/#toolbar) design pattern.
 * @accessibilityIssues
 * [Issue 988424: VoiceOver narrates selected for button in toolbar](https://bugs.chromium.org/p/chromium/issues/detail?id=988424)
 */
exports.default = types_1.withSafeTypeForAs(Toolbar);
