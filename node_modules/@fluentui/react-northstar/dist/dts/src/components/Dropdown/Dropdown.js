"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var customPropTypes = require("@fluentui/react-proptypes");
var accessibility_1 = require("@fluentui/accessibility");
var React = require("react");
var PropTypes = require("prop-types");
var _ = require("lodash");
var classnames_1 = require("classnames");
var keyboardKey = require("keyboard-key");
var types_1 = require("../../types");
var downshift_1 = require("downshift");
var utils_1 = require("../../utils");
var List_1 = require("../List/List");
var DropdownItem_1 = require("./DropdownItem");
var DropdownSelectedItem_1 = require("./DropdownSelectedItem");
var DropdownSearchInput_1 = require("./DropdownSearchInput");
var Button_1 = require("../Button/Button");
var accessibilityStyles_1 = require("../../utils/accessibility/Styles/accessibilityStyles");
var Box_1 = require("../Box/Box");
var Portal_1 = require("../Portal/Portal");
var positioner_1 = require("../../utils/positioner");
exports.dropdownClassName = 'ui-dropdown';
exports.dropdownSlotClassNames = {
    clearIndicator: exports.dropdownClassName + "__clear-indicator",
    container: exports.dropdownClassName + "__container",
    toggleIndicator: exports.dropdownClassName + "__toggle-indicator",
    item: exports.dropdownClassName + "__item",
    itemsList: exports.dropdownClassName + "__items-list",
    searchInput: exports.dropdownClassName + "__searchinput",
    selectedItem: exports.dropdownClassName + "__selecteditem",
    selectedItems: exports.dropdownClassName + "__selected-items",
    triggerButton: exports.dropdownClassName + "__trigger-button",
};
var Dropdown = /** @class */ (function (_super) {
    tslib_1.__extends(Dropdown, _super);
    function Dropdown() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.buttonRef = React.createRef();
        _this.inputRef = React.createRef();
        _this.listRef = React.createRef();
        _this.selectedItemsRef = React.createRef();
        _this.containerRef = React.createRef();
        _this.defaultTriggerButtonId = _.uniqueId('dropdown-trigger-button-');
        _this.handleChange = function (e) {
            // Dropdown component doesn't present any `input` component in markup, however all of our
            // components should handle events transparently.
            _.invoke(_this.props, 'onChange', e, tslib_1.__assign(tslib_1.__assign({}, _this.props), { value: _this.state.value }));
        };
        _this.downshiftStateReducer = function (state, changes) {
            var activeElement = _this.context.target.activeElement;
            switch (changes.type) {
                case downshift_1.default.stateChangeTypes.blurButton:
                    // Downshift closes the list by default on trigger blur. It does not support the case when dropdown is
                    // single selection and focuses list on trigger click/up/down/space/enter. Treating that here.
                    if (state.isOpen && activeElement === _this.listRef.current) {
                        return {}; // won't change state in this case.
                    }
                default:
                    return changes;
            }
        };
        _this.handleStateChange = function (changes) {
            var _a = _this.props, search = _a.search, multiple = _a.multiple, highlightFirstItemOnOpen = _a.highlightFirstItemOnOpen, items = _a.items, getA11ySelectionMessage = _a.getA11ySelectionMessage;
            var _b = _this.state, value = _b.value, open = _b.open;
            var type = changes.type;
            var newState = {};
            switch (type) {
                case downshift_1.default.stateChangeTypes.changeInput: {
                    var shouldValueChange = changes.inputValue === '' && !multiple && value.length > 0;
                    newState.searchQuery = changes.inputValue;
                    newState.highlightedIndex = highlightFirstItemOnOpen ? 0 : null;
                    if (shouldValueChange) {
                        newState.value = [];
                    }
                    if (open) {
                        // we clear value when in single selection user cleared the query.
                        var shouldMenuClose = changes.inputValue === '' || changes.selectedItem !== undefined;
                        if (shouldMenuClose) {
                            newState.open = false;
                        }
                    }
                    else {
                        newState.open = true;
                    }
                    break;
                }
                case downshift_1.default.stateChangeTypes.keyDownEnter:
                case downshift_1.default.stateChangeTypes.clickItem:
                    var shouldAddHighlightedIndex = !multiple && items && items.length > 0;
                    var isSameItemSelected = changes.selectedItem === undefined;
                    var newValue = isSameItemSelected ? value[0] : changes.selectedItem;
                    newState.searchQuery = _this.getSelectedItemAsString(newValue);
                    newState.open = false;
                    newState.highlightedIndex = shouldAddHighlightedIndex ? items.indexOf(newValue) : null;
                    if (!isSameItemSelected) {
                        newState.value = multiple ? tslib_1.__spreadArrays(value, [changes.selectedItem]) : [changes.selectedItem];
                        if (getA11ySelectionMessage && getA11ySelectionMessage.onAdd) {
                            _this.setA11ySelectionMessage(getA11ySelectionMessage.onAdd(newValue));
                        }
                    }
                    if (multiple) {
                        setTimeout(function () { return (_this.selectedItemsRef.current.scrollTop = _this.selectedItemsRef.current.scrollHeight); }, 0);
                    }
                    _this.tryFocusTriggerButton();
                    break;
                case downshift_1.default.stateChangeTypes.keyDownEscape:
                    if (search) {
                        newState.searchQuery = '';
                        if (!multiple) {
                            newState.value = [];
                        }
                    }
                    newState.open = false;
                    newState.highlightedIndex = highlightFirstItemOnOpen ? 0 : null;
                    break;
                case downshift_1.default.stateChangeTypes.keyDownArrowDown:
                case downshift_1.default.stateChangeTypes.keyDownArrowUp:
                    if (changes.isOpen !== undefined) {
                        newState.open = changes.isOpen;
                        newState.highlightedIndex = changes.highlightedIndex;
                        if (changes.isOpen) {
                            var highlightedIndexOnArrowKeyOpen = _this.getHighlightedIndexOnArrowKeyOpen(changes);
                            if (_.isNumber(highlightedIndexOnArrowKeyOpen)) {
                                newState.highlightedIndex = highlightedIndexOnArrowKeyOpen;
                            }
                            if (!search) {
                                _this.listRef.current.focus();
                            }
                        }
                        else {
                            newState.highlightedIndex = null;
                        }
                    }
                case downshift_1.default.stateChangeTypes['keyDownHome']:
                case downshift_1.default.stateChangeTypes['keyDownEnd']:
                    if (open && _.isNumber(changes.highlightedIndex)) {
                        newState.highlightedIndex = changes.highlightedIndex;
                        newState.itemIsFromKeyboard = true;
                    }
                    break;
                case downshift_1.default.stateChangeTypes.mouseUp:
                    if (open) {
                        newState.open = false;
                        newState.highlightedIndex = null;
                    }
                    break;
                case downshift_1.default.stateChangeTypes.clickButton:
                case downshift_1.default.stateChangeTypes.keyDownSpaceButton:
                    newState.open = changes.isOpen;
                    if (changes.isOpen) {
                        var highlightedIndexOnArrowKeyOpen = _this.getHighlightedIndexOnArrowKeyOpen(changes);
                        if (_.isNumber(highlightedIndexOnArrowKeyOpen)) {
                            newState.highlightedIndex = highlightedIndexOnArrowKeyOpen;
                        }
                        if (!search) {
                            _this.listRef.current.focus();
                        }
                    }
                    else {
                        newState.highlightedIndex = null;
                    }
                    break;
                case downshift_1.default.stateChangeTypes.itemMouseEnter:
                    newState.highlightedIndex = changes.highlightedIndex;
                    newState.itemIsFromKeyboard = false;
                    break;
                case downshift_1.default.stateChangeTypes.unknown:
                    if (changes.selectedItem) {
                        newState.value = multiple ? tslib_1.__spreadArrays(value, [changes.selectedItem]) : [changes.selectedItem];
                        newState.searchQuery = multiple ? '' : changes.inputValue;
                        newState.open = false;
                        newState.highlightedIndex = changes.highlightedIndex;
                        _this.tryFocusTriggerButton();
                    }
                    else {
                        newState.open = changes.isOpen;
                    }
                default:
                    break;
            }
            if (_.isEmpty(newState)) {
                return;
            }
            var handlers = [
                newState.value !== undefined && 'onChange',
                newState.highlightedIndex !== undefined && 'onHighlightedIndexChange',
                newState.open !== undefined && 'onOpenChange',
                newState.searchQuery !== undefined && 'onSearchQueryChange',
            ].filter(Boolean);
            _this.setStateAndInvokeHandler(handlers, null, newState);
        };
        _this.isSelectedItemActive = function (index) {
            return index === _this.state.activeSelectedIndex;
        };
        _this.handleItemOverrides = function (item, index, getItemProps, selected) { return function (predefinedProps) { return ({
            accessibilityItemProps: tslib_1.__assign(tslib_1.__assign({}, getItemProps({
                item: item,
                index: index,
                disabled: item['disabled'],
                onClick: function (e) {
                    e.stopPropagation();
                    e.nativeEvent.stopImmediatePropagation();
                    _.invoke(predefinedProps, 'onClick', e, predefinedProps);
                },
            })), (!_this.props.multiple && {
                'aria-selected': selected,
            })),
        }); }; };
        _this.handleSelectedItemOverrides = function (item, rtl) { return function (predefinedProps) { return ({
            onRemove: function (e, dropdownSelectedItemProps) {
                _this.handleSelectedItemRemove(e, item, predefinedProps, dropdownSelectedItemProps);
            },
            onClick: function (e, dropdownSelectedItemProps) {
                _this.setStateAndInvokeHandler(['onActiveSelectedIndexChange'], null, {
                    activeSelectedIndex: _this.state.value.indexOf(item),
                });
                e.stopPropagation();
                _.invoke(predefinedProps, 'onClick', e, dropdownSelectedItemProps);
            },
            onKeyDown: function (e, dropdownSelectedItemProps) {
                _this.handleSelectedItemKeyDown(e, item, predefinedProps, dropdownSelectedItemProps, rtl);
            },
        }); }; };
        _this.handleSearchInputOverrides = function (highlightedIndex, rtl, selectItemAtIndex, toggleMenu, accessibilityComboboxProps, getInputProps) { return function (predefinedProps) {
            var handleInputBlur = function (e, searchInputProps) {
                if (!disabled) {
                    _this.setState({ focused: false, isFromKeyboard: utils_1.isFromKeyboard() });
                    e.nativeEvent['preventDownshiftDefault'] = true;
                }
                _.invoke(predefinedProps, 'onInputBlur', e, searchInputProps);
            };
            var disabled = _this.props.disabled;
            var handleInputKeyDown = function (e, searchInputProps) {
                if (!disabled) {
                    switch (keyboardKey.getCode(e)) {
                        case keyboardKey.Tab:
                            _this.handleTabSelection(e, highlightedIndex, selectItemAtIndex, toggleMenu);
                            break;
                        case keyboardKey.ArrowLeft:
                            if (!rtl) {
                                _this.trySetLastSelectedItemAsActive();
                            }
                            break;
                        case keyboardKey.ArrowRight:
                            if (rtl) {
                                _this.trySetLastSelectedItemAsActive();
                            }
                            break;
                        case keyboardKey.Backspace:
                            _this.tryRemoveItemFromValue();
                            break;
                        default:
                            break;
                    }
                }
                _.invoke(predefinedProps, 'onInputKeyDown', e, tslib_1.__assign(tslib_1.__assign({}, searchInputProps), { highlightedIndex: highlightedIndex,
                    selectItemAtIndex: selectItemAtIndex }));
            };
            return {
                // getInputProps adds Downshift handlers. We also add our own by passing them as params to that function.
                // user handlers were also added to our handlers previously, at the beginning of this function.
                accessibilityInputProps: tslib_1.__assign({}, getInputProps({
                    disabled: disabled,
                    onBlur: function (e) {
                        handleInputBlur(e, predefinedProps);
                    },
                    onKeyDown: function (e) {
                        handleInputKeyDown(e, predefinedProps);
                    },
                    onChange: function (e) {
                        // we prevent the onChange input event to bubble up to our Dropdown handler,
                        // since in Dropdown it gets handled as onSearchQueryChange.
                        e.stopPropagation();
                    },
                })),
                // same story as above for getRootProps.
                accessibilityComboboxProps: accessibilityComboboxProps,
                onFocus: function (e, searchInputProps) {
                    if (!disabled) {
                        _this.setState({ focused: true, isFromKeyboard: utils_1.isFromKeyboard() });
                    }
                    _.invoke(predefinedProps, 'onFocus', e, searchInputProps);
                },
                onInputBlur: function (e, searchInputProps) {
                    handleInputBlur(e, searchInputProps);
                },
                onInputKeyDown: function (e, searchInputProps) {
                    handleInputKeyDown(e, searchInputProps);
                },
            };
        }; };
        /**
         * Custom Tab selection logic, at least until Downshift will implement selection on blur.
         * Also keeps focus on multiple selection dropdown when selecting by Tab.
         */
        _this.handleTabSelection = function (e, highlightedIndex, selectItemAtIndex, toggleMenu) {
            var _a = _this.state, open = _a.open, filteredItems = _a.filteredItems;
            var _b = _this.props, moveFocusOnTab = _b.moveFocusOnTab, multiple = _b.multiple, items = _b.items;
            if (open) {
                if (!_.isNil(highlightedIndex) && filteredItems.length && !items[highlightedIndex]['disabled']) {
                    selectItemAtIndex(highlightedIndex);
                    if (multiple && !moveFocusOnTab) {
                        e.preventDefault();
                    }
                }
                else {
                    toggleMenu();
                }
            }
        };
        _this.trySetLastSelectedItemAsActive = function () {
            var multiple = _this.props.multiple;
            var value = _this.state.value;
            if (!multiple || (_this.inputRef.current && _this.inputRef.current.selectionStart !== 0)) {
                return;
            }
            if (value.length > 0) {
                // If last element was already active, perform a 'reset' of activeSelectedIndex.
                if (_this.state.activeSelectedIndex === value.length - 1) {
                    _this.setState({ activeSelectedIndex: null }, function () {
                        _this.setStateAndInvokeHandler(['onActiveSelectedIndexChange'], null, {
                            activeSelectedIndex: value.length - 1,
                        });
                    });
                }
                else {
                    _this.setStateAndInvokeHandler(['onActiveSelectedIndexChange'], null, {
                        activeSelectedIndex: value.length - 1,
                    });
                }
            }
        };
        _this.tryRemoveItemFromValue = function () {
            var multiple = _this.props.multiple;
            var _a = _this.state, searchQuery = _a.searchQuery, value = _a.value;
            var inputElement = _this.inputRef.current;
            if (multiple &&
                (searchQuery === '' || (inputElement.selectionStart === 0 && inputElement.selectionEnd === 0)) &&
                value.length > 0) {
                _this.removeItemFromValue();
            }
        };
        _this.handleClear = function (e) {
            var _a = _this.getInitialAutoControlledState(_this.props), activeSelectedIndex = _a.activeSelectedIndex, highlightedIndex = _a.highlightedIndex, open = _a.open, searchQuery = _a.searchQuery, value = _a.value;
            _this.setStateAndInvokeHandler(['onChange', 'onActiveSelectedIndexChange', 'onHighlightedIndexChange'], e, {
                activeSelectedIndex: activeSelectedIndex,
                highlightedIndex: highlightedIndex,
                open: open,
                searchQuery: searchQuery,
                value: value,
            });
            _this.tryFocusSearchInput();
            _this.tryFocusTriggerButton();
        };
        _this.handleContainerClick = function () {
            _this.tryFocusSearchInput();
        };
        _this.handleTriggerButtonKeyDown = function (e, rtl) {
            switch (keyboardKey.getCode(e)) {
                case keyboardKey.ArrowLeft:
                    if (!rtl) {
                        _this.trySetLastSelectedItemAsActive();
                    }
                    return;
                case keyboardKey.ArrowRight:
                    if (rtl) {
                        _this.trySetLastSelectedItemAsActive();
                    }
                    return;
                default:
                    return;
            }
        };
        _this.handleListKeyDown = function (e, highlightedIndex, accessibilityInputPropsKeyDown, toggleMenu, selectItemAtIndex) {
            var keyCode = keyboardKey.getCode(e);
            switch (keyCode) {
                case keyboardKey.Tab:
                    _this.handleTabSelection(e, highlightedIndex, selectItemAtIndex, toggleMenu);
                    return;
                case keyboardKey.Escape:
                    accessibilityInputPropsKeyDown(e);
                    _this.tryFocusTriggerButton();
                    e.stopPropagation();
                    return;
                default:
                    var keyString = String.fromCharCode(keyCode);
                    if (/[a-zA-Z0-9]/.test(keyString)) {
                        _this.setHighlightedIndexOnCharKeyDown(keyString);
                    }
                    accessibilityInputPropsKeyDown(e);
                    return;
            }
        };
        _this.handleTriggerButtonOrListFocus = function () {
            _this.setState({ focused: true, isFromKeyboard: utils_1.isFromKeyboard() });
        };
        _this.handleTriggerButtonBlur = function (e) {
            if (_this.listRef.current !== e.relatedTarget) {
                _this.setState({ focused: false, isFromKeyboard: utils_1.isFromKeyboard() });
            }
        };
        _this.handleListBlur = function (e) {
            if (_this.buttonRef.current !== e.relatedTarget) {
                _this.setState({ focused: false, isFromKeyboard: utils_1.isFromKeyboard() });
            }
        };
        /**
         * Sets highlightedIndex to be the item that starts with the character keys the
         * user has typed. Only used in non-search dropdowns.
         *
         * @param keystring - The string the item needs to start with. It is composed by typing keys in fast succession.
         */
        _this.setHighlightedIndexOnCharKeyDown = function (keyString) {
            var _a = _this.state, highlightedIndex = _a.highlightedIndex, filteredItemStrings = _a.filteredItemStrings, startingString = _a.startingString;
            var newStartingString = "" + startingString + keyString.toLowerCase();
            var newHighlightedIndex = -1;
            _this.setStartingString(newStartingString);
            if (_.isNumber(highlightedIndex)) {
                newHighlightedIndex = _.findIndex(filteredItemStrings, function (item) { return item.startsWith(newStartingString); }, highlightedIndex + (startingString.length > 0 ? 0 : 1));
            }
            if (newHighlightedIndex < 0) {
                newHighlightedIndex = _.findIndex(filteredItemStrings, function (item) { return item.startsWith(newStartingString); });
            }
            if (newHighlightedIndex >= 0) {
                _this.setStateAndInvokeHandler(['onHighlightedIndexChange'], null, {
                    highlightedIndex: newHighlightedIndex,
                });
            }
        };
        /**
         * Calls setState and invokes event handler exposed to user.
         * We don't have the event object for most events coming from Downshift se we send an empty event
         * because we want to keep the event handling interface
         */
        _this.setStateAndInvokeHandler = function (handlerNames, event, newState) {
            var proposedValue = _.isNil(newState.value) ? _this.state.value : newState.value;
            // `proposedValue` should be normalized for single/multiple variations, `null` condition is
            // required as first item can be undefined
            var newValue = _this.props.multiple ? proposedValue : proposedValue[0] || null;
            _this.setState(newState);
            handlerNames.forEach(function (handlerName) {
                _.invoke(_this.props, handlerName, event, tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, _this.props), newState), { value: newValue }));
            });
        };
        _this.tryFocusTriggerButton = function () {
            if (!_this.props.search && _this.buttonRef.current) {
                _this.buttonRef.current.focus();
            }
        };
        _this.tryFocusSearchInput = function () {
            if (_this.props.search && _this.inputRef.current) {
                _this.inputRef.current.focus();
            }
        };
        /**
         * If there is no value we use the placeholder value
         * otherwise, for single selection we convert the value with itemToString
         * and for multiple selection we return empty string, the values are rendered by renderSelectedItems
         */
        _this.getSelectedItemAsString = function (value) {
            var _a = _this.props, itemToString = _a.itemToString, multiple = _a.multiple, placeholder = _a.placeholder, search = _a.search;
            if (!value) {
                return search ? '' : placeholder;
            }
            if (multiple) {
                return '';
            }
            return itemToString(value);
        };
        _this.getHighlightedIndexOnArrowKeyOpen = function (changes) {
            var _a = _this.state, filteredItems = _a.filteredItems, highlightedIndex = _a.highlightedIndex, value = _a.value;
            var _b = _this.props, highlightFirstItemOnOpen = _b.highlightFirstItemOnOpen, items = _b.items, multiple = _b.multiple, search = _b.search;
            var isArrowUp = changes.type === downshift_1.default.stateChangeTypes.keyDownArrowUp;
            var isArrowDown = changes.type === downshift_1.default.stateChangeTypes.keyDownArrowDown;
            var itemsLength = filteredItems.length;
            if (highlightedIndex) {
                return highlightedIndex;
            }
            if (highlightFirstItemOnOpen) {
                // otherwise, if highlightFirstItemOnOpen prop is provied, highlight first item.
                return 0;
            }
            if (!multiple && !search && value.length > 0) {
                // in single selection, if there is a selected item, highlight it.
                var offset = isArrowUp ? -1 : isArrowDown ? 1 : 0;
                var newHighlightedIndex = items.indexOf(value[0]) + offset;
                if (newHighlightedIndex >= itemsLength) {
                    return 0;
                }
                if (newHighlightedIndex < 0) {
                    return itemsLength - 1;
                }
                return newHighlightedIndex;
            }
            if (isArrowDown) {
                return 0;
            }
            if (isArrowUp) {
                return itemsLength - 1;
            }
            return null;
        };
        /**
         * Function that sets and cleans the selection message after it has been set,
         * so it is not read anymore via virtual cursor.
         */
        _this.setA11ySelectionMessage = function (a11ySelectionStatus) {
            _this.setState({ a11ySelectionStatus: a11ySelectionStatus });
            _this.clearA11ySelectionMessage();
        };
        _this.setStartingString = function (startingString) {
            _this.setState({ startingString: startingString });
            _this.clearStartingString();
        };
        _this.clearA11ySelectionMessage = _.debounce(function () {
            _this.setState({ a11ySelectionStatus: '' });
        }, Dropdown.a11yStatusCleanupTime);
        _this.clearStartingString = _.debounce(function () {
            _this.setState({ startingString: '' });
        }, Dropdown.charKeyPressedCleanupTime);
        return _this;
    }
    Dropdown.prototype.componentWillUnmount = function () {
        this.clearStartingString.cancel();
        this.clearA11ySelectionMessage.cancel();
    };
    Dropdown.prototype.getInitialAutoControlledState = function (_a) {
        var multiple = _a.multiple, search = _a.search;
        return {
            a11ySelectionStatus: '',
            activeSelectedIndex: multiple ? null : undefined,
            filteredItems: undefined,
            filteredItemStrings: undefined,
            focused: false,
            startingString: search ? undefined : '',
            open: false,
            highlightedIndex: this.props.highlightFirstItemOnOpen ? 0 : null,
            searchQuery: search ? '' : undefined,
            value: [],
            itemIsFromKeyboard: false,
            isFromKeyboard: false,
        };
    };
    /**
     * Used to compute the filtered items (by value and search query) and, if needed,
     * their string equivalents, in order to be used throughout the component.
     */
    Dropdown.getAutoControlledStateFromProps = function (props, state) {
        var items = props.items, itemToString = props.itemToString, itemToValue = props.itemToValue, multiple = props.multiple, search = props.search;
        var searchQuery = state.searchQuery, rawValue = state.value;
        // `normalizedValue` should be normilized always as it can be received from props
        var normalizedValue = _.isArray(rawValue) ? rawValue : [rawValue];
        var value = multiple ? normalizedValue : normalizedValue.slice(0, 1);
        var filteredItemsByValue = multiple ? _.differenceBy(items, value, itemToValue) : items;
        var filteredItemStrings = _.map(filteredItemsByValue, function (filteredItem) { return itemToString(filteredItem).toLowerCase(); });
        var modifiedState = {
            filteredItems: filteredItemsByValue,
            filteredItemStrings: filteredItemStrings,
            value: value,
        };
        if (search) {
            if (_.isFunction(search)) {
                modifiedState.filteredItems = search(filteredItemsByValue, searchQuery);
            }
            else {
                modifiedState.filteredItems = filteredItemsByValue.filter(function (item) {
                    return itemToString(item)
                        .toLowerCase()
                        .indexOf(searchQuery.toLowerCase()) !== -1;
                });
            }
        }
        return modifiedState;
    };
    Dropdown.prototype.renderComponent = function (_a) {
        var _this = this;
        var ElementType = _a.ElementType, classes = _a.classes, styles = _a.styles, variables = _a.variables, unhandledProps = _a.unhandledProps, rtl = _a.rtl;
        var _b;
        var _c = this.props, clearable = _c.clearable, clearIndicator = _c.clearIndicator, disabled = _c.disabled, search = _c.search, multiple = _c.multiple, getA11yStatusMessage = _c.getA11yStatusMessage, itemToString = _c.itemToString, toggleIndicator = _c.toggleIndicator;
        var _d = this.state, highlightedIndex = _d.highlightedIndex, open = _d.open, searchQuery = _d.searchQuery, value = _d.value;
        return (React.createElement(ElementType, tslib_1.__assign({ className: classes.root, onChange: this.handleChange }, unhandledProps),
            React.createElement(downshift_1.default, { isOpen: open, inputValue: search ? searchQuery : null, stateReducer: this.downshiftStateReducer, itemToString: itemToString, 
                // downshift does not work with arrays as selectedItem.
                selectedItem: multiple || !value.length ? null : value[0], getA11yStatusMessage: getA11yStatusMessage, highlightedIndex: highlightedIndex, onStateChange: this.handleStateChange, labelId: this.props['aria-labelledby'], environment: (_b = this.context.target) === null || _b === void 0 ? void 0 : _b.defaultView, inputId: this.props.searchInput && this.props.searchInput['id'] ? this.props.searchInput['id'] : undefined }, function (_a) {
                var getInputProps = _a.getInputProps, getItemProps = _a.getItemProps, getMenuProps = _a.getMenuProps, getRootProps = _a.getRootProps, getToggleButtonProps = _a.getToggleButtonProps, toggleMenu = _a.toggleMenu, highlightedIndex = _a.highlightedIndex, selectItemAtIndex = _a.selectItemAtIndex;
                var _b = getRootProps({ refKey: 'innerRef' }, { suppressRefError: true }), innerRef = _b.innerRef, accessibilityRootPropsRest = tslib_1.__rest(_b, ["innerRef"]);
                var showClearIndicator = clearable && value.length > 0;
                return (React.createElement(react_component_ref_1.Ref, { innerRef: innerRef },
                    React.createElement("div", { ref: _this.containerRef, className: classnames_1.default(exports.dropdownSlotClassNames.container, classes.container), onClick: search && !open ? _this.handleContainerClick : undefined },
                        React.createElement("div", { ref: _this.selectedItemsRef, className: classnames_1.default(exports.dropdownSlotClassNames.selectedItems, classes.selectedItems) },
                            multiple && _this.renderSelectedItems(variables, rtl),
                            search
                                ? _this.renderSearchInput(accessibilityRootPropsRest, rtl, highlightedIndex, getInputProps, selectItemAtIndex, toggleMenu, variables)
                                : _this.renderTriggerButton(styles, rtl, getToggleButtonProps)),
                        showClearIndicator
                            ? Box_1.default.create(clearIndicator, {
                                defaultProps: function () { return (tslib_1.__assign({ className: exports.dropdownSlotClassNames.clearIndicator, styles: styles.clearIndicator, accessibility: accessibility_1.indicatorBehavior }, (!search && { tabIndex: 0, role: 'button' }))); },
                                overrideProps: function (predefinedProps) { return ({
                                    onClick: function (e) {
                                        _.invoke(predefinedProps, 'onClick', e);
                                        _this.handleClear(e);
                                    },
                                }); },
                            })
                            : Box_1.default.create(toggleIndicator, {
                                defaultProps: function () { return ({
                                    className: exports.dropdownSlotClassNames.toggleIndicator,
                                    styles: styles.toggleIndicator,
                                    accessibility: accessibility_1.indicatorBehavior,
                                }); },
                                overrideProps: function (predefinedProps) { return ({
                                    onClick: function (e) {
                                        if (!disabled) {
                                            getToggleButtonProps({ disabled: disabled }).onClick(e);
                                        }
                                        _.invoke(predefinedProps, 'onClick', e);
                                    },
                                }); },
                            }),
                        _this.renderItemsList(styles, variables, highlightedIndex, toggleMenu, selectItemAtIndex, getMenuProps, getItemProps, getInputProps, rtl))));
            }),
            React.createElement(Portal_1.default, { open: !!this.props.getA11ySelectionMessage },
                React.createElement("div", { role: "status", "aria-live": "polite", "aria-relevant": "additions text", style: accessibilityStyles_1.screenReaderContainerStyles }, this.state.a11ySelectionStatus))));
    };
    Dropdown.prototype.renderTriggerButton = function (styles, rtl, getToggleButtonProps) {
        var _this = this;
        var _a = this.props, triggerButton = _a.triggerButton, disabled = _a.disabled;
        var value = this.state.value;
        var content = this.getSelectedItemAsString(value[0]);
        var triggerButtonId = triggerButton['id'] || this.defaultTriggerButtonId;
        var triggerButtonProps = getToggleButtonProps({
            disabled: disabled,
            onFocus: this.handleTriggerButtonOrListFocus,
            onBlur: this.handleTriggerButtonBlur,
            onKeyDown: function (e) {
                _this.handleTriggerButtonKeyDown(e, rtl);
            },
            'aria-label': undefined,
            'aria-labelledby': [this.props['aria-labelledby'], triggerButtonId].filter(function (l) { return !!l; }).join(' '),
        });
        var onClick = triggerButtonProps.onClick, onFocus = triggerButtonProps.onFocus, onBlur = triggerButtonProps.onBlur, onKeyDown = triggerButtonProps.onKeyDown, restTriggerButtonProps = tslib_1.__rest(triggerButtonProps, ["onClick", "onFocus", "onBlur", "onKeyDown"]);
        return (React.createElement(react_component_ref_1.Ref, { innerRef: this.buttonRef }, utils_1.createShorthand(Button_1.default, triggerButton, {
            defaultProps: function () { return (tslib_1.__assign({ className: exports.dropdownSlotClassNames.triggerButton, content: content,
                disabled: disabled, id: triggerButtonId, fluid: true, styles: styles.triggerButton }, restTriggerButtonProps)); },
            overrideProps: function (predefinedProps) { return ({
                onClick: function (e) {
                    onClick(e);
                    _.invoke(predefinedProps, 'onClick', e, predefinedProps);
                },
                onFocus: function (e) {
                    onFocus(e);
                    _.invoke(predefinedProps, 'onFocus', e, predefinedProps);
                },
                onBlur: function (e) {
                    if (!disabled) {
                        onBlur(e);
                    }
                    _.invoke(predefinedProps, 'onBlur', e, predefinedProps);
                },
                onKeyDown: function (e) {
                    if (!disabled) {
                        onKeyDown(e);
                    }
                    _.invoke(predefinedProps, 'onKeyDown', e, predefinedProps);
                },
            }); },
        })));
    };
    Dropdown.prototype.renderSearchInput = function (accessibilityComboboxProps, rtl, highlightedIndex, getInputProps, selectItemAtIndex, toggleMenu, variables) {
        var _this = this;
        var _a = this.props, inline = _a.inline, searchInput = _a.searchInput, multiple = _a.multiple, placeholder = _a.placeholder, disabled = _a.disabled;
        var _b = this.state, searchQuery = _b.searchQuery, value = _b.value;
        var noPlaceholder = searchQuery.length > 0 || (multiple && value.length > 0);
        return DropdownSearchInput_1.default.create(searchInput || {}, {
            defaultProps: function () { return ({
                className: exports.dropdownSlotClassNames.searchInput,
                placeholder: noPlaceholder ? '' : placeholder,
                inline: inline,
                variables: variables,
                inputRef: _this.inputRef,
                disabled: disabled,
            }); },
            overrideProps: this.handleSearchInputOverrides(highlightedIndex, rtl, selectItemAtIndex, toggleMenu, accessibilityComboboxProps, getInputProps),
        });
    };
    Dropdown.prototype.renderItemsList = function (styles, variables, highlightedIndex, toggleMenu, selectItemAtIndex, getMenuProps, getItemProps, getInputProps, rtl) {
        var _this = this;
        var _a = this.props, align = _a.align, offset = _a.offset, position = _a.position, search = _a.search, unstable_pinned = _a.unstable_pinned, list = _a.list;
        var open = this.state.open;
        var items = open ? this.renderItems(styles, variables, getItemProps, highlightedIndex) : [];
        var _b = getMenuProps({ refKey: 'innerRef' }, { suppressRefError: true }), innerRef = _b.innerRef, accessibilityMenuProps = tslib_1.__rest(_b, ["innerRef"]);
        // If it's just a selection, some attributes and listeners from Downshift input need to go on the menu list.
        if (!search) {
            var accessibilityInputProps_1 = getInputProps();
            accessibilityMenuProps['aria-activedescendant'] = accessibilityInputProps_1['aria-activedescendant'];
            accessibilityMenuProps['onKeyDown'] = function (e) {
                _this.handleListKeyDown(e, highlightedIndex, accessibilityInputProps_1['onKeyDown'], toggleMenu, selectItemAtIndex);
            };
        }
        return (React.createElement(react_component_ref_1.Ref, { innerRef: function (listElement) {
                react_component_ref_1.handleRef(_this.listRef, listElement);
                react_component_ref_1.handleRef(innerRef, listElement);
            } },
            React.createElement(positioner_1.Popper, tslib_1.__assign({ align: align, position: position, offset: offset, rtl: rtl, enabled: open, targetRef: this.containerRef, unstable_pinned: unstable_pinned, positioningDependencies: [items.length] }, positioner_1.getPopperPropsFromShorthand(list)), List_1.default.create(list, {
                defaultProps: function () { return (tslib_1.__assign(tslib_1.__assign({ className: exports.dropdownSlotClassNames.itemsList }, accessibilityMenuProps), { styles: styles.list, items: items, tabIndex: search ? undefined : -1, 'aria-hidden': !open })); },
                overrideProps: function (predefinedProps) { return ({
                    onFocus: function (e, listProps) {
                        _this.handleTriggerButtonOrListFocus();
                        _.invoke(predefinedProps, 'onClick', e, listProps);
                    },
                    onBlur: function (e, listProps) {
                        _this.handleListBlur(e);
                        _.invoke(predefinedProps, 'onBlur', e, listProps);
                    },
                }); },
            }))));
    };
    Dropdown.prototype.renderItems = function (styles, variables, getItemProps, highlightedIndex) {
        var _this = this;
        var _a = this.props, renderItem = _a.renderItem, checkable = _a.checkable, checkableIndicator = _a.checkableIndicator;
        var _b = this.state, filteredItems = _b.filteredItems, value = _b.value;
        var footerItem = this.renderItemsListFooter(styles);
        var headerItem = this.renderItemsListHeader(styles);
        var items = _.map(filteredItems, function (item, index) { return ({
            children: function () {
                var selected = value.indexOf(item) !== -1;
                return DropdownItem_1.default.create(item, {
                    defaultProps: function () { return (tslib_1.__assign({ className: exports.dropdownSlotClassNames.item, active: highlightedIndex === index, selected: selected,
                        checkable: checkable,
                        checkableIndicator: checkableIndicator, isFromKeyboard: _this.state.itemIsFromKeyboard, variables: variables }, (typeof item === 'object' &&
                        !item.hasOwnProperty('key') && {
                        key: item.header,
                    }))); },
                    overrideProps: _this.handleItemOverrides(item, index, getItemProps, selected),
                    render: renderItem,
                });
            },
        }); });
        if (footerItem) {
            items.push(footerItem);
        }
        return headerItem ? tslib_1.__spreadArrays([headerItem], items) : items;
    };
    Dropdown.prototype.renderItemsListHeader = function (styles) {
        var headerMessage = this.props.headerMessage;
        if (headerMessage) {
            return {
                children: function () {
                    return DropdownItem_1.default.create(headerMessage, {
                        defaultProps: function () { return ({
                            key: 'items-list-footer-message',
                            styles: styles.headerMessage,
                        }); },
                    });
                },
            };
        }
        return null;
    };
    Dropdown.prototype.renderItemsListFooter = function (styles) {
        var _a = this.props, loading = _a.loading, loadingMessage = _a.loadingMessage, noResultsMessage = _a.noResultsMessage, items = _a.items;
        if (loading) {
            return {
                children: function () {
                    return DropdownItem_1.default.create(loadingMessage, {
                        defaultProps: function () { return ({
                            key: 'loading-message',
                            styles: styles.loadingMessage,
                        }); },
                    });
                },
            };
        }
        if (items && items.length === 0) {
            return {
                children: function () {
                    return DropdownItem_1.default.create(noResultsMessage, {
                        defaultProps: function () { return ({
                            key: 'no-results-message',
                            styles: styles.noResultsMessage,
                        }); },
                    });
                },
            };
        }
        return null;
    };
    Dropdown.prototype.renderSelectedItems = function (variables, rtl) {
        var _this = this;
        var renderSelectedItem = this.props.renderSelectedItem;
        var value = this.state.value;
        if (value.length === 0) {
            return null;
        }
        return value.map(function (item, index) {
            // (!) an item matches DropdownItemProps
            return DropdownSelectedItem_1.default.create(item, {
                defaultProps: function () { return (tslib_1.__assign({ className: exports.dropdownSlotClassNames.selectedItem, active: _this.isSelectedItemActive(index), variables: variables }, (typeof item === 'object' &&
                    !item.hasOwnProperty('key') && {
                    key: item.header,
                }))); },
                overrideProps: _this.handleSelectedItemOverrides(item, rtl),
                render: renderSelectedItem,
            });
        });
    };
    Dropdown.prototype.handleSelectedItemKeyDown = function (e, item, predefinedProps, dropdownSelectedItemProps, rtl) {
        var _a = this.state, activeSelectedIndex = _a.activeSelectedIndex, value = _a.value;
        var previousKey = rtl ? keyboardKey.ArrowRight : keyboardKey.ArrowLeft;
        var nextKey = rtl ? keyboardKey.ArrowLeft : keyboardKey.ArrowRight;
        switch (keyboardKey.getCode(e)) {
            case keyboardKey.Delete:
            case keyboardKey.Backspace:
                this.handleSelectedItemRemove(e, item, predefinedProps, dropdownSelectedItemProps);
                break;
            case previousKey:
                if (value.length > 0 && !_.isNil(activeSelectedIndex) && activeSelectedIndex > 0) {
                    this.setStateAndInvokeHandler(['onActiveSelectedIndexChange'], null, {
                        activeSelectedIndex: activeSelectedIndex - 1,
                    });
                }
                break;
            case nextKey:
                if (value.length > 0 && !_.isNil(activeSelectedIndex)) {
                    if (activeSelectedIndex < value.length - 1) {
                        this.setState({ activeSelectedIndex: activeSelectedIndex + 1 });
                    }
                    else {
                        this.setState({ activeSelectedIndex: null });
                        if (this.props.search) {
                            e.preventDefault(); // prevents caret to forward one position in input.
                            this.inputRef.current.focus();
                        }
                        else {
                            this.buttonRef.current.focus();
                        }
                    }
                }
                break;
            default:
                break;
        }
        _.invoke(predefinedProps, 'onKeyDown', e, dropdownSelectedItemProps);
    };
    Dropdown.prototype.handleSelectedItemRemove = function (e, item, predefinedProps, dropdownSelectedItemProps) {
        this.setStateAndInvokeHandler(['onActiveSelectedIndexChange'], null, {
            activeSelectedIndex: null,
        });
        this.removeItemFromValue(item);
        this.tryFocusSearchInput();
        this.tryFocusTriggerButton();
        _.invoke(predefinedProps, 'onRemove', e, dropdownSelectedItemProps);
    };
    Dropdown.prototype.removeItemFromValue = function (item) {
        var getA11ySelectionMessage = this.props.getA11ySelectionMessage;
        var value = this.state.value;
        var poppedItem = item;
        if (poppedItem) {
            value = value.filter(function (currentElement) { return currentElement !== item; });
        }
        else {
            poppedItem = value.pop();
        }
        if (getA11ySelectionMessage && getA11ySelectionMessage.onRemove) {
            this.setA11ySelectionMessage(getA11ySelectionMessage.onRemove(poppedItem));
        }
        this.setStateAndInvokeHandler(['onChange'], null, { value: value });
    };
    Dropdown.displayName = 'Dropdown';
    Dropdown.deprecated_className = exports.dropdownClassName;
    Dropdown.a11yStatusCleanupTime = 500;
    Dropdown.charKeyPressedCleanupTime = 500;
    Dropdown.propTypes = tslib_1.__assign(tslib_1.__assign({}, utils_1.commonPropTypes.createCommon({
        accessibility: false,
        children: false,
        content: false,
    })), { activeSelectedIndex: PropTypes.number, align: PropTypes.oneOf(positioner_1.ALIGNMENTS), checkable: PropTypes.bool, checkableIndicator: customPropTypes.shorthandAllowingChildren, clearable: PropTypes.bool, clearIndicator: customPropTypes.shorthandAllowingChildren, defaultActiveSelectedIndex: PropTypes.number, defaultOpen: PropTypes.bool, defaultHighlightedIndex: PropTypes.number, defaultSearchQuery: PropTypes.string, defaultValue: PropTypes.oneOfType([customPropTypes.itemShorthand, customPropTypes.collectionShorthand]), disabled: PropTypes.bool, fluid: PropTypes.bool, getA11ySelectionMessage: PropTypes.object, getA11yStatusMessage: PropTypes.func, highlightFirstItemOnOpen: PropTypes.bool, highlightedIndex: PropTypes.number, inline: PropTypes.bool, inverted: PropTypes.bool, items: customPropTypes.collectionShorthand, itemToString: PropTypes.func, itemToValue: PropTypes.func, headerMessage: customPropTypes.itemShorthand, list: customPropTypes.itemShorthand, loading: PropTypes.bool, loadingMessage: customPropTypes.itemShorthand, moveFocusOnTab: PropTypes.bool, multiple: PropTypes.bool, noResultsMessage: customPropTypes.itemShorthand, offset: PropTypes.oneOfType([
            PropTypes.func,
            PropTypes.arrayOf(PropTypes.number),
        ]), onOpenChange: PropTypes.func, onSearchQueryChange: PropTypes.func, onChange: PropTypes.func, onActiveSelectedIndexChange: PropTypes.func, onHighlightedIndexChange: PropTypes.func, open: PropTypes.bool, placeholder: PropTypes.string, position: PropTypes.oneOf(positioner_1.POSITIONS), renderItem: PropTypes.func, renderSelectedItem: PropTypes.func, search: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]), searchQuery: PropTypes.string, searchInput: customPropTypes.itemShorthand, toggleIndicator: customPropTypes.shorthandAllowingChildren, triggerButton: customPropTypes.itemShorthand, unstable_pinned: PropTypes.bool, value: PropTypes.oneOfType([customPropTypes.itemShorthand, customPropTypes.collectionShorthand]) });
    Dropdown.defaultProps = {
        align: 'start',
        as: 'div',
        clearIndicator: {},
        itemToString: function (item) {
            if (!item || React.isValidElement(item)) {
                return '';
            }
            // targets DropdownItem shorthand objects
            return item.header || String(item);
        },
        itemToValue: function (item) {
            if (!item || React.isValidElement(item)) {
                return '';
            }
            // targets DropdownItem shorthand objects
            return item.header || String(item);
        },
        list: {},
        position: 'below',
        toggleIndicator: {},
        triggerButton: {},
    };
    Dropdown.autoControlledProps = ['activeSelectedIndex', 'highlightedIndex', 'open', 'searchQuery', 'value'];
    Dropdown.Item = DropdownItem_1.default;
    Dropdown.SearchInput = DropdownSearchInput_1.default;
    Dropdown.SelectedItem = DropdownSelectedItem_1.default;
    return Dropdown;
}(utils_1.AutoControlledComponent));
/**
 * A Dropdown allows user to select one or more values from a list of options.
 * Can be created with search and multi-selection capabilities.
 *
 * @accessibility
 * Implements [ARIA Combo Box](https://www.w3.org/TR/wai-aria-practices-1.1/#combobox) design pattern, uses aria-live to announce state changes.
 * @accessibilityIssues
 * [Issue 991203: VoiceOver doesn't narrate properly elements in the input/combobox](https://bugs.chromium.org/p/chromium/issues/detail?id=991203)
 */
exports.default = types_1.withSafeTypeForAs(Dropdown);
