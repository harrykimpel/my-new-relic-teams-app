"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var accessibility_1 = require("@fluentui/accessibility");
var react_component_nesting_registry_1 = require("@fluentui/react-component-nesting-registry");
var react_component_event_listener_1 = require("@fluentui/react-component-event-listener");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var customPropTypes = require("@fluentui/react-proptypes");
var _ = require("lodash");
var PropTypes = require("prop-types");
var React = require("react");
var keyboardKey = require("keyboard-key");
var utils_1 = require("./utils");
var utils_2 = require("../../utils");
var types_1 = require("../../types");
var Button_1 = require("../Button/Button");
var ButtonGroup_1 = require("../Button/ButtonGroup");
var Box_1 = require("../Box/Box");
var Header_1 = require("../Header/Header");
var Portal_1 = require("../Portal/Portal");
var Flex_1 = require("../Flex/Flex");
var DialogFooter_1 = require("./DialogFooter");
var dialogsCounterAttribute = 'fluent-dialogs-count';
exports.dialogClassName = 'ui-dialog';
exports.dialogSlotClassNames = {
    header: exports.dialogClassName + "__header",
    headerAction: exports.dialogClassName + "__headerAction",
    content: exports.dialogClassName + "__content",
    overlay: exports.dialogClassName + "__overlay",
    footer: exports.dialogClassName + "__footer",
};
var Dialog = /** @class */ (function (_super) {
    tslib_1.__extends(Dialog, _super);
    function Dialog() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.actionHandlers = {
            closeAndFocusTrigger: function (e) {
                _this.handleDialogCancel(e);
                e.stopPropagation();
                _.invoke(_this.triggerRef, 'current.focus');
            },
            close: function (e) { return _this.handleDialogCancel(e); },
        };
        _this.contentRef = React.createRef();
        _this.overlayRef = React.createRef();
        _this.triggerRef = React.createRef();
        _this.handleDialogCancel = function (e) {
            _.invoke(_this.props, 'onCancel', e, tslib_1.__assign(tslib_1.__assign({}, _this.props), { open: false }));
            _this.setState({ open: false });
        };
        _this.handleDialogConfirm = function (e) {
            _.invoke(_this.props, 'onConfirm', e, tslib_1.__assign(tslib_1.__assign({}, _this.props), { open: false }));
            _this.setState({ open: false });
        };
        _this.handleDialogOpen = function (e) {
            _.invoke(_this.props, 'onOpen', e, tslib_1.__assign(tslib_1.__assign({}, _this.props), { open: true }));
            _this.setState({ open: true });
        };
        _this.handleCancelButtonOverrides = function (predefinedProps) { return ({
            onClick: function (e, buttonProps) {
                _.invoke(predefinedProps, 'onClick', e, buttonProps);
                _this.handleDialogCancel(e);
            },
        }); };
        _this.handleConfirmButtonOverrides = function (predefinedProps) { return ({
            onClick: function (e, buttonProps) {
                _.invoke(predefinedProps, 'onClick', e, buttonProps);
                _this.handleDialogConfirm(e);
            },
        }); };
        _this.handleOverlayClick = function (e) {
            // Dialog has different conditions to close than Popup, so we don't need to iterate across all
            // refs
            var isInsideContentClick = utils_2.doesNodeContainClick(_this.contentRef.current, e, _this.context.target);
            var isInsideOverlayClick = utils_2.doesNodeContainClick(_this.overlayRef.current, e, _this.context.target);
            var shouldClose = !isInsideContentClick && isInsideOverlayClick;
            if (shouldClose) {
                _this.handleDialogCancel(e);
            }
        };
        _this.handleDocumentKeydown = function (getRefs) { return function (e) {
            // if focus was lost from Dialog, for e.g. when click on Dialog's content
            // and ESC is pressed, the opened Dialog should get closed and the trigger should get focus
            var lastOverlayRef = getRefs().pop();
            var isLastOpenedDialog = lastOverlayRef && lastOverlayRef.current === _this.overlayRef.current;
            if (keyboardKey.getCode(e) === keyboardKey.Escape && isLastOpenedDialog) {
                _this.handleDialogCancel(e);
                _.invoke(_this.triggerRef, 'current.focus');
            }
        }; };
        return _this;
    }
    Dialog.prototype.getInitialAutoControlledState = function () {
        return {
            open: false,
        };
    };
    Dialog.getAutoControlledStateFromProps = function (props, state) {
        return {
            contentId: utils_2.getOrGenerateIdFromShorthand('dialog-content-', props.content, state.contentId),
            headerId: utils_2.getOrGenerateIdFromShorthand('dialog-header-', props.header, state.headerId),
        };
    };
    Dialog.prototype.lockBodyScroll = function () {
        var openDialogs = (+this.context.target.body.getAttribute(dialogsCounterAttribute) || 0) + 1;
        this.context.target.body.setAttribute(dialogsCounterAttribute, "" + openDialogs);
        // Avoid to block scroll in nested dialogs
        if (openDialogs === 1) {
            utils_1.disableBodyScroll(this.context.target.body);
        }
    };
    Dialog.prototype.unlockBodyScroll = function () {
        var openDialogs = (+this.context.target.body.getAttribute(dialogsCounterAttribute) || 0) - 1;
        this.context.target.body.setAttribute(dialogsCounterAttribute, "" + openDialogs);
        // Only enables scroll if all dialogs are closed
        if (openDialogs === 0) {
            utils_1.enableBodyScroll(this.context.target.body);
            this.context.target.body.removeAttribute(dialogsCounterAttribute);
        }
    };
    Dialog.prototype.componentDidUpdate = function (_, prevState) {
        // Open -> Closed
        if (prevState.open && !this.state.open) {
            this.unlockBodyScroll();
        }
        // Closed -> Open
        if (!prevState.open && this.state.open) {
            this.lockBodyScroll();
        }
    };
    Dialog.prototype.componentDidMount = function () {
        if (this.state.open) {
            this.lockBodyScroll();
        }
    };
    Dialog.prototype.componentWillUnmount = function () {
        if (this.state.open) {
            this.unlockBodyScroll();
        }
    };
    Dialog.prototype.renderComponent = function (_a) {
        var _this = this;
        var accessibility = _a.accessibility, classes = _a.classes, ElementType = _a.ElementType, styles = _a.styles, unhandledProps = _a.unhandledProps, rtl = _a.rtl;
        var _b = this.props, actions = _b.actions, cancelButton = _b.cancelButton, closeOnOutsideClick = _b.closeOnOutsideClick, confirmButton = _b.confirmButton, content = _b.content, header = _b.header, headerAction = _b.headerAction, overlay = _b.overlay, trapFocus = _b.trapFocus, trigger = _b.trigger, footer = _b.footer;
        var open = this.state.open;
        var cancelElement = utils_2.createShorthand(Button_1.default, cancelButton, {
            overrideProps: this.handleCancelButtonOverrides,
        });
        var confirmElement = utils_2.createShorthand(Button_1.default, confirmButton, {
            defaultProps: function () { return ({
                primary: true,
            }); },
            overrideProps: this.handleConfirmButtonOverrides,
        });
        var dialogActions = (cancelElement || confirmElement) &&
            ButtonGroup_1.default.create(actions, {
                defaultProps: function () { return ({
                    styles: styles.actions,
                }); },
                overrideProps: {
                    content: (React.createElement(Flex_1.default, { gap: "gap.smaller" },
                        cancelElement,
                        confirmElement)),
                },
            });
        var dialogContent = (React.createElement(react_component_ref_1.Ref, { innerRef: this.contentRef },
            React.createElement(ElementType, tslib_1.__assign({ className: classes.root }, accessibility.attributes.popup, unhandledProps, utils_2.applyAccessibilityKeyHandlers(accessibility.keyHandlers.popup, unhandledProps)),
                Header_1.default.create(header, {
                    defaultProps: function () { return (tslib_1.__assign({ as: 'h2', className: exports.dialogSlotClassNames.header, styles: styles.header }, accessibility.attributes.header)); },
                }),
                utils_2.createShorthand(Button_1.default, headerAction, {
                    defaultProps: function () { return (tslib_1.__assign({ className: exports.dialogSlotClassNames.headerAction, styles: styles.headerAction, text: true, iconOnly: true }, accessibility.attributes.headerAction)); },
                }),
                Box_1.default.create(content, {
                    defaultProps: function () { return (tslib_1.__assign({ styles: styles.content, className: exports.dialogSlotClassNames.content }, accessibility.attributes.content)); },
                }),
                DialogFooter_1.default.create(footer, {
                    overrideProps: {
                        content: dialogActions,
                        className: exports.dialogSlotClassNames.footer,
                        styles: styles.footer,
                    },
                }))));
        var triggerAccessibility = {
            attributes: accessibility.attributes.trigger,
            keyHandlers: accessibility.keyHandlers.trigger,
        };
        return (React.createElement(Portal_1.default, { onTriggerClick: this.handleDialogOpen, open: open, trapFocus: trapFocus, trigger: trigger, triggerAccessibility: triggerAccessibility, triggerRef: this.triggerRef },
            React.createElement(react_component_nesting_registry_1.Unstable_NestingAuto, null, function (getRefs, nestingRef) { return (React.createElement(React.Fragment, null,
                React.createElement(react_component_ref_1.Ref, { innerRef: function (contentNode) {
                        _this.overlayRef.current = contentNode;
                        nestingRef.current = contentNode;
                    } }, Box_1.default.create(overlay, {
                    defaultProps: function () { return ({
                        className: exports.dialogSlotClassNames.overlay,
                        styles: styles.overlay,
                    }); },
                    overrideProps: { content: dialogContent },
                })),
                closeOnOutsideClick && (React.createElement(react_component_event_listener_1.EventListener, { listener: _this.handleOverlayClick, target: _this.context.target, type: "click", capture: true })),
                React.createElement(react_component_event_listener_1.EventListener, { listener: _this.handleDocumentKeydown(getRefs), target: _this.context.target, type: "keydown", capture: true }))); })));
    };
    Dialog.displayName = 'Dialog';
    Dialog.deprecated_className = exports.dialogClassName;
    Dialog.propTypes = tslib_1.__assign(tslib_1.__assign({}, utils_2.commonPropTypes.createCommon({
        children: false,
        content: 'shorthand',
    })), { actions: customPropTypes.itemShorthand, backdrop: PropTypes.bool, headerAction: customPropTypes.itemShorthand, cancelButton: customPropTypes.itemShorthand, closeOnOutsideClick: PropTypes.bool, confirmButton: customPropTypes.itemShorthand, defaultOpen: PropTypes.bool, header: customPropTypes.itemShorthand, onCancel: PropTypes.func, onConfirm: PropTypes.func, onOpen: PropTypes.func, open: PropTypes.bool, overlay: customPropTypes.itemShorthand, trapFocus: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]), trigger: PropTypes.any });
    Dialog.defaultProps = {
        accessibility: accessibility_1.dialogBehavior,
        actions: {},
        backdrop: true,
        closeOnOutsideClick: true,
        overlay: {},
        footer: {},
        trapFocus: true,
    };
    Dialog.autoControlledProps = ['open'];
    Dialog.Footer = DialogFooter_1.default;
    return Dialog;
}(utils_2.AutoControlledComponent));
/**
 * A Dialog displays important information on top of a page which requires a user's attention, confirmation, or interaction.
 * Dialogs are purposefully interruptive, so they should be used sparingly.
 *
 * @accessibility
 * Implements [ARIA Dialog (Modal)](https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal) design pattern.
 * @accessibilityIssues
 * [NVDA narrates dialog title and button twice](https://github.com/nvaccess/nvda/issues/10003)
 * [NVDA does not recognize the ARIA 1.1 values of aria-haspopup](https://github.com/nvaccess/nvda/issues/8235)
 * [Jaws does not announce token values of aria-haspopup](https://github.com/FreedomScientific/VFO-standards-support/issues/33)
 * [Issue 989517: VoiceOver narrates dialog content and button twice](https://bugs.chromium.org/p/chromium/issues/detail?id=989517)
 */
exports.default = types_1.withSafeTypeForAs(Dialog);
