"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var accessibility_1 = require("@fluentui/accessibility");
var react_bindings_1 = require("@fluentui/react-bindings");
var customPropTypes = require("@fluentui/react-proptypes");
var _ = require("lodash");
var PropTypes = require("prop-types");
var React = require("react");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var TreeItem_1 = require("./TreeItem");
var TreeTitle_1 = require("./TreeTitle");
var utils_1 = require("../../utils");
var types_1 = require("../../types");
var utils_2 = require("./utils");
exports.treeClassName = 'ui-tree';
var Tree = /** @class */ (function (_super) {
    tslib_1.__extends(Tree, _super);
    function Tree() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.treeRef = React.createRef();
        _this.itemsRef = new Map();
        _this.onFocusParent = function (parent) {
            var parentRef = _this.itemsRef.get(parent);
            if (!parentRef || !parentRef.current) {
                return;
            }
            parentRef.current.focus();
        };
        _this.setSelectedItemIds = function (e, selectedItemIds) {
            _.invoke(_this.props, 'onSelectedItemIdsChange', e, tslib_1.__assign(tslib_1.__assign({}, _this.props), { selectedItemIds: selectedItemIds }));
            _this.setState({
                selectedItemIds: selectedItemIds,
            });
        };
        _this.processItemsForSelection = function (e, treeItemProps, executeSelection) {
            var selectedItemIds = _this.state.selectedItemIds;
            var id = treeItemProps.id, selectableParent = treeItemProps.selectableParent, items = treeItemProps.items, expanded = treeItemProps.expanded;
            var treeItemHasSubtree = utils_2.hasSubtree(treeItemProps);
            var isExpandedSelectableParent = treeItemHasSubtree && selectableParent && expanded;
            // parent must be selectable and expanded in order to procced with selection, otherwise return
            if (treeItemHasSubtree && !(selectableParent && expanded)) {
                return;
            }
            // if the target is equal to currentTarget it means treeItem should be collapsed, not procced with selection
            if (treeItemHasSubtree && e.target === e.currentTarget && !executeSelection) {
                return;
            }
            // push all tree items under particular parent into selection array
            // not parent itself, therefore not procced with selection
            if (isExpandedSelectableParent) {
                if (_this.isAllGroupChecked(items)) {
                    var selectedItems_1 = _this.getAllSelectableChildrenId(items);
                    selectedItemIds = selectedItemIds.filter(function (id) { return selectedItems_1.indexOf(id) === -1; });
                }
                else {
                    var selectItems_1 = function (items) {
                        items.forEach(function (item) {
                            var selectble = item.hasOwnProperty('selectable') ? item.selectable : treeItemProps.selectable;
                            if (selectedItemIds.indexOf(item.id) === -1) {
                                if (item.items) {
                                    selectItems_1(item.items);
                                }
                                else if (selectble) {
                                    selectedItemIds.push(item.id);
                                }
                            }
                        });
                    };
                    selectItems_1(items);
                }
                _this.setSelectedItemIds(e, selectedItemIds);
                return;
            }
            // push/remove single tree item into selection array
            if (selectedItemIds.indexOf(id) === -1) {
                selectedItemIds.push(id);
            }
            else {
                selectedItemIds = selectedItemIds.filter(function (itemID) { return itemID !== id; });
            }
            _this.setSelectedItemIds(e, selectedItemIds);
        };
        _this.onTitleClick = function (e, treeItemProps, executeSelection) {
            if (executeSelection === void 0) { executeSelection = false; }
            var treeItemHasSubtree = utils_2.hasSubtree(treeItemProps);
            if (!treeItemProps) {
                return;
            }
            if (treeItemProps.selectable) {
                _this.processItemsForSelection(e, treeItemProps, executeSelection);
            }
            if (treeItemHasSubtree && !executeSelection && e.target === e.currentTarget) {
                _this.expandItems(e, treeItemProps);
            }
        };
        _this.onFocusFirstChild = function (itemId) {
            var currentElement = _this.itemsRef.get(itemId);
            if (!currentElement || !currentElement.current) {
                return;
            }
            var elementToBeFocused = react_bindings_1.getNextElement(_this.treeRef.current, currentElement.current);
            if (!elementToBeFocused) {
                return;
            }
            elementToBeFocused.focus();
        };
        _this.onSiblingsExpand = function (e, treeItemProps) {
            var _a = _this.props, exclusive = _a.exclusive, items = _a.items;
            if (exclusive) {
                return;
            }
            var id = treeItemProps.id;
            var activeItemIds = _this.state.activeItemIds;
            var siblings = utils_2.getSiblings(items, id);
            siblings.forEach(function (sibling) {
                if (utils_2.hasSubtree(sibling) && !_this.isActiveItem(sibling['id'])) {
                    activeItemIds.push(sibling['id']);
                }
            });
            if (utils_2.hasSubtree(treeItemProps) && !_this.isActiveItem(id)) {
                activeItemIds.push(id);
            }
            _this.setActiveItemIds(e, activeItemIds);
        };
        _this.setActiveItemIds = function (e, activeItemIds) {
            _.invoke(_this.props, 'onActiveItemIdsChange', e, tslib_1.__assign(tslib_1.__assign({}, _this.props), { activeItemIds: activeItemIds }));
            _this.setState({
                activeItemIds: activeItemIds,
            });
        };
        _this.getAllSelectableChildrenId = function (items) {
            return items.reduce(function (acc, item) {
                if (item.items) {
                    return tslib_1.__spreadArrays(acc, _this.getAllSelectableChildrenId(item.items));
                }
                return item.hasOwnProperty('selectable') && !item.selectable ? acc : tslib_1.__spreadArrays(acc, [item.id]);
            }, []);
        };
        _this.isIndeterminate = function (item) {
            if (!item.selectableParent || !item.items) {
                return false;
            }
            var items = item.items;
            var selectableItemIds = _this.getAllSelectableChildrenId(items);
            return !_this.isAllGroupChecked(items) && selectableItemIds.some(function (id) { return _this.state.selectedItemIds.indexOf(id) > -1; });
        };
        _this.isAllGroupChecked = function (items) {
            var selectableItemIds = _this.getAllSelectableChildrenId(items);
            return selectableItemIds.every(function (id) { return _this.state.selectedItemIds.indexOf(id) > -1; });
        };
        _this.contextValue = {
            onFocusParent: _this.onFocusParent,
            onSiblingsExpand: _this.onSiblingsExpand,
            onFocusFirstChild: _this.onFocusFirstChild,
            onTitleClick: _this.onTitleClick,
        };
        _this.isActiveItem = function (id) {
            var activeItemIds = _this.state.activeItemIds;
            return activeItemIds.indexOf(id) > -1;
        };
        _this.isSelectedItem = function (item) {
            var selectedItemIds = _this.state.selectedItemIds;
            if (item.selectableParent && item.items) {
                return _this.isAllGroupChecked(item.items);
            }
            return selectedItemIds && selectedItemIds.indexOf(item.id) > -1;
        };
        return _this;
    }
    Tree.getAutoControlledStateFromProps = function (nextProps, prevState) {
        var items = nextProps.items, selectable = nextProps.selectable;
        var activeItemIds = nextProps.activeItemIds, selectedItemIds = nextProps.selectedItemIds;
        if (selectable && items && !selectedItemIds) {
            if (!selectedItemIds && items) {
                selectedItemIds = prevState.selectedItemIds;
                var iterateItems_1 = function (items, selectedItems) {
                    if (selectedItems === void 0) { selectedItems = selectedItemIds; }
                    _.forEach(items, function (item) {
                        if (item['selected'] && selectedItemIds.indexOf(item['id']) === -1) {
                            selectedItems.push(item['id']);
                        }
                        if (item['items']) {
                            return iterateItems_1(item['items']);
                        }
                    });
                };
                iterateItems_1(items);
            }
        }
        if (!activeItemIds && items) {
            activeItemIds = prevState.activeItemIds;
            var expandedItemsGenerator_1 = function (items, acc) {
                if (acc === void 0) { acc = activeItemIds; }
                return _.reduce(items, function (acc, item) {
                    if (item['expanded'] && acc.indexOf(item['id']) === -1) {
                        acc.push(item['id']);
                    }
                    if (item['items']) {
                        return expandedItemsGenerator_1(item['items'], acc);
                    }
                    return acc;
                }, acc);
            };
            expandedItemsGenerator_1(items);
        }
        return {
            activeItemIds: activeItemIds,
            selectedItemIds: selectedItemIds,
        };
    };
    Tree.prototype.getInitialAutoControlledState = function () {
        return { activeItemIds: [], selectedItemIds: [] };
    };
    Tree.prototype.expandItems = function (e, treeItemProps) {
        var activeItemIds = this.state.activeItemIds;
        var id = treeItemProps.id;
        var _a = this.props, exclusive = _a.exclusive, items = _a.items;
        var siblings = utils_2.getSiblings(items, id);
        var activeItemIdIndex = activeItemIds.indexOf(id);
        if (activeItemIdIndex > -1) {
            activeItemIds = utils_2.removeItemAtIndex(activeItemIds, activeItemIdIndex);
        }
        else {
            if (exclusive) {
                siblings.some(function (sibling) {
                    var activeSiblingIdIndex = activeItemIds.indexOf(sibling['id']);
                    if (activeSiblingIdIndex > -1) {
                        activeItemIds = utils_2.removeItemAtIndex(activeItemIds, activeSiblingIdIndex);
                        return true;
                    }
                    return false;
                });
            }
            activeItemIds = tslib_1.__spreadArrays(activeItemIds, [id]);
        }
        this.setActiveItemIds(e, activeItemIds);
    };
    Tree.prototype.renderContent = function (accessibility) {
        var _this = this;
        var _a = this.props, items = _a.items, renderItemTitle = _a.renderItemTitle, selectable = _a.selectable;
        if (!items)
            return null;
        var renderItems = function (items, level, parent) {
            if (level === void 0) { level = 1; }
            return items.reduce(function (renderedItems, item, index) {
                var id = item.id;
                var isSubtree = utils_2.hasSubtree(item);
                var isSubtreeExpanded = isSubtree && _this.isActiveItem(id);
                var isSelectedItem = _this.isSelectedItem(item);
                var indeterminate = _this.isIndeterminate(item);
                if (!_this.itemsRef.has(id)) {
                    _this.itemsRef.set(id, React.createRef());
                }
                var renderedItem = TreeItem_1.default.create(item, {
                    defaultProps: function () { return ({
                        accessibility: accessibility.childBehaviors ? accessibility.childBehaviors.item : undefined,
                        expanded: isSubtreeExpanded,
                        selected: isSelectedItem,
                        selectable: selectable,
                        renderItemTitle: renderItemTitle,
                        id: id,
                        key: id,
                        parent: parent,
                        level: level,
                        index: index + 1,
                        contentRef: _this.itemsRef.get(id),
                        treeSize: items.length,
                        indeterminate: indeterminate,
                    }); },
                });
                return tslib_1.__spreadArrays(renderedItems, [
                    renderedItem
                ], (isSubtreeExpanded ? renderItems(item.items, level + 1, id) : []));
            }, []);
        };
        return renderItems(items);
    };
    Tree.prototype.renderComponent = function (_a) {
        var ElementType = _a.ElementType, classes = _a.classes, accessibility = _a.accessibility, unhandledProps = _a.unhandledProps;
        var _b = this.props, children = _b.children, renderedItems = _b.renderedItems;
        return (React.createElement(utils_2.TreeContext.Provider, { value: this.contextValue },
            React.createElement(react_component_ref_1.Ref, { innerRef: this.treeRef },
                React.createElement(ElementType, tslib_1.__assign({ className: classes.root }, accessibility.attributes.root, utils_1.rtlTextContainer.getAttributes({ forElements: [children] }), unhandledProps, utils_1.applyAccessibilityKeyHandlers(accessibility.keyHandlers.root, unhandledProps)), utils_1.childrenExist(children)
                    ? children
                    : renderedItems
                        ? renderedItems(this.renderContent(accessibility))
                        : this.renderContent(accessibility)))));
    };
    Tree.displayName = 'Tree';
    Tree.deprecated_className = exports.treeClassName;
    Tree.propTypes = tslib_1.__assign(tslib_1.__assign({}, utils_1.commonPropTypes.createCommon({
        content: false,
    })), { activeItemIds: customPropTypes.collectionShorthand, selectedItemIds: customPropTypes.collectionShorthand, defaultActiveItemIds: customPropTypes.collectionShorthand, defaultSelectedItemIds: customPropTypes.collectionShorthand, exclusive: PropTypes.bool, selectable: PropTypes.bool, items: customPropTypes.collectionObjectShorthand, onActiveItemIdsChange: PropTypes.func, onSelectedItemIdsChange: PropTypes.func, renderItemTitle: PropTypes.func, renderedItems: PropTypes.func });
    Tree.defaultProps = {
        as: 'div',
        accessibility: accessibility_1.treeBehavior,
    };
    Tree.autoControlledProps = ['activeItemIds', 'selectedItemIds'];
    Tree.Item = TreeItem_1.default;
    Tree.Title = TreeTitle_1.default;
    return Tree;
}(utils_1.AutoControlledComponent));
Tree.create = utils_1.createShorthandFactory({
    Component: Tree,
    mappedArrayProp: 'items',
});
/**
 * A Tree displays data organised in tree hierarchy.
 *
 * @accessibility
 * Implements [ARIA TreeView](https://www.w3.org/TR/wai-aria-practices-1.1/#TreeView) design pattern.
 * @accessibilityIssues
 * [Treeview - JAWS doesn't narrate position for each tree item](https://github.com/FreedomScientific/VFO-standards-support/issues/338)
 * [Aria compliant trees are read as empty tables](https://bugs.chromium.org/p/chromium/issues/detail?id=1048770)
 */
exports.default = types_1.withSafeTypeForAs(Tree);
