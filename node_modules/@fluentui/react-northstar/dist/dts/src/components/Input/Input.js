"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var accessibility_1 = require("@fluentui/accessibility");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var customPropTypes = require("@fluentui/react-proptypes");
var React = require("react");
var PropTypes = require("prop-types");
var classnames_1 = require("classnames");
var _ = require("lodash");
var utils_1 = require("../../utils");
var types_1 = require("../../types");
var Box_1 = require("../Box/Box");
exports.inputClassName = 'ui-input';
exports.inputSlotClassNames = {
    input: exports.inputClassName + "__input",
    icon: exports.inputClassName + "__icon",
};
var Input = /** @class */ (function (_super) {
    tslib_1.__extends(Input, _super);
    function Input() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.inputRef = React.createRef();
        _this.actionHandlers = {
            clear: function (e) {
                if (_this.props.clearable && _this.state.value !== '') {
                    e.stopPropagation();
                    e.nativeEvent && e.nativeEvent.stopPropagation();
                    _this.handleOnClear(e);
                }
            },
        };
        _this.handleIconOverrides = function (predefinedProps) { return ({
            onClick: function (e) {
                if (!_this.props.disabled) {
                    _this.handleOnClear(e);
                    _this.inputRef.current.focus();
                }
                _.invoke(predefinedProps, 'onClick', e, _this.props);
            },
        }); };
        _this.handleChange = function (e) {
            if (_this.props.disabled) {
                return;
            }
            var value = _.get(e, 'target.value');
            _.invoke(_this.props, 'onChange', e, tslib_1.__assign(tslib_1.__assign({}, _this.props), { value: value }));
            _this.setState({ value: value });
        };
        _this.handleOnClear = function (e) {
            if (_this.props.clearable) {
                _.invoke(_this.props, 'onChange', e, tslib_1.__assign(tslib_1.__assign({}, _this.props), { value: '' }));
                _this.setState({ value: '' });
            }
        };
        _this.computeIcon = function () {
            var _a = _this.props, clearable = _a.clearable, icon = _a.icon;
            var value = _this.state.value;
            if (clearable && value.length !== 0) {
                return {};
            }
            return icon || null;
        };
        return _this;
    }
    Input.getAutoControlledStateFromProps = function (props, state) {
        var value = state.value;
        return {
            hasValue: !!value && value.length !== 0,
        };
    };
    Input.prototype.renderComponent = function (_a) {
        var _this = this;
        var accessibility = _a.accessibility, ElementType = _a.ElementType, unhandledProps = _a.unhandledProps, styles = _a.styles, variables = _a.variables;
        var _b = this.props, className = _b.className, input = _b.input, inputRef = _b.inputRef, type = _b.type, wrapper = _b.wrapper, disabled = _b.disabled;
        var _c = this.state.value, value = _c === void 0 ? '' : _c;
        var _d = utils_1.partitionHTMLProps(unhandledProps), htmlInputProps = _d[0], restProps = _d[1];
        return Box_1.default.create(wrapper, {
            defaultProps: function () { return (tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, accessibility.attributes.root), { className: classnames_1.default(exports.inputClassName, className), children: (React.createElement(React.Fragment, null,
                    React.createElement(react_component_ref_1.Ref, { innerRef: function (inputElement) {
                            react_component_ref_1.handleRef(_this.inputRef, inputElement);
                            react_component_ref_1.handleRef(inputRef, inputElement);
                        } }, Box_1.default.create(input || type, {
                        defaultProps: function () { return (tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, htmlInputProps), { as: 'input', disabled: disabled,
                            type: type,
                            value: value, className: exports.inputSlotClassNames.input, styles: styles.input, onChange: _this.handleChange }), utils_1.applyAccessibilityKeyHandlers(accessibility.keyHandlers.input, htmlInputProps))); },
                    })),
                    Box_1.default.create(_this.computeIcon(), {
                        defaultProps: function () { return ({
                            className: exports.inputSlotClassNames.icon,
                            styles: styles.icon,
                        }); },
                        overrideProps: _this.handleIconOverrides,
                    }))), styles: styles.root }), restProps)); },
            overrideProps: {
                as: (wrapper && wrapper.as) || ElementType,
            },
        });
    };
    Input.deprecated_className = exports.inputClassName;
    Input.displayName = 'Input';
    Input.propTypes = tslib_1.__assign(tslib_1.__assign({}, utils_1.commonPropTypes.createCommon({
        content: false,
    })), { clearable: PropTypes.bool, defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number]), disabled: PropTypes.bool, fluid: PropTypes.bool, icon: customPropTypes.shorthandAllowingChildren, iconPosition: PropTypes.oneOf(['start', 'end']), input: customPropTypes.itemShorthand, inputRef: customPropTypes.ref, inline: PropTypes.bool, inverted: PropTypes.bool, onChange: PropTypes.func, type: PropTypes.string, value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]), wrapper: customPropTypes.wrapperShorthand });
    Input.defaultProps = {
        accessibility: accessibility_1.inputBehavior,
        type: 'text',
        wrapper: {},
        iconPosition: 'end',
    };
    Input.autoControlledProps = ['value'];
    return Input;
}(utils_1.AutoControlledComponent));
/**
 * An Input is a field used to elicit an input from a user.
 *
 * @accessibility
 * For good screen reader experience set `aria-label` or `aria-labelledby` attribute for input.
 */
exports.default = types_1.withSafeTypeForAs(Input);
