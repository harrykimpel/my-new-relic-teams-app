"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var PropTypes = require("prop-types");
var classnames_1 = require("classnames");
var utils_1 = require("../../utils");
var types_1 = require("../../types");
exports.layoutClassName = 'ui-layout';
exports.layoutSlotClassNames = {
    start: exports.layoutClassName + "__start",
    main: exports.layoutClassName + "__main",
    end: exports.layoutClassName + "__end",
    gap: exports.layoutClassName + "__gap",
    reducedStart: exports.layoutClassName + "--reduced__start",
    reducedMain: exports.layoutClassName + "--reduced__main",
    reducedEnd: exports.layoutClassName + "--reduced__end",
};
var Layout = /** @class */ (function (_super) {
    tslib_1.__extends(Layout, _super);
    function Layout() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Layout.prototype.renderComponent = function (_a) {
        var ElementType = _a.ElementType, classes = _a.classes, unhandledProps = _a.unhandledProps;
        var _b = this.props, reducing = _b.reducing, disappearing = _b.disappearing, start = _b.start, main = _b.main, end = _b.end, renderStartArea = _b.renderStartArea, renderMainArea = _b.renderMainArea, renderEndArea = _b.renderEndArea, renderGap = _b.renderGap;
        var startArea = renderStartArea(tslib_1.__assign(tslib_1.__assign({}, this.props), { classes: classes }));
        var mainArea = renderMainArea(tslib_1.__assign(tslib_1.__assign({}, this.props), { classes: classes }));
        var endArea = renderEndArea(tslib_1.__assign(tslib_1.__assign({}, this.props), { classes: classes }));
        if (!startArea && !mainArea && !endArea) {
            return React.createElement(ElementType, tslib_1.__assign({}, unhandledProps, { className: classes.root }));
        }
        var activeAreas = [startArea, mainArea, endArea].filter(Boolean);
        var isSingleArea = activeAreas.length === 1;
        // disappear: render the content directly without wrapping layout or area elements
        if (disappearing && isSingleArea) {
            return start || main || end;
        }
        if (reducing && isSingleArea) {
            var composedClasses = classnames_1.default(classes.root, startArea && exports.layoutSlotClassNames.reducedStart, mainArea && exports.layoutSlotClassNames.reducedMain, endArea && exports.layoutSlotClassNames.reducedEnd);
            return (React.createElement(ElementType, tslib_1.__assign({}, unhandledProps, { className: composedClasses }), start || main || end));
        }
        return (React.createElement(ElementType, tslib_1.__assign({}, unhandledProps, { className: classes.root }),
            startArea,
            startArea && mainArea && renderGap(tslib_1.__assign(tslib_1.__assign({}, this.props), { classes: classes })),
            mainArea,
            (startArea || mainArea) && endArea && renderGap(tslib_1.__assign(tslib_1.__assign({}, this.props), { classes: classes })),
            endArea));
    };
    Layout.deprecated_className = exports.layoutClassName;
    Layout.displayName = 'Layout';
    Layout.propTypes = tslib_1.__assign(tslib_1.__assign({}, utils_1.commonPropTypes.createCommon({
        accessibility: false,
        children: false,
        content: false,
    })), { debug: PropTypes.bool, renderStartArea: PropTypes.func, renderMainArea: PropTypes.func, renderEndArea: PropTypes.func, renderGap: PropTypes.func, rootCSS: PropTypes.object, start: PropTypes.any, startCSS: PropTypes.object, startSize: PropTypes.string, main: PropTypes.any, mainCSS: PropTypes.object, mainSize: PropTypes.string, end: PropTypes.any, endCSS: PropTypes.object, endSize: PropTypes.string, justifyItems: PropTypes.any, alignItems: PropTypes.any, gap: PropTypes.string, reducing: PropTypes.bool, disappearing: PropTypes.bool, vertical: PropTypes.bool });
    Layout.defaultProps = {
        startSize: 'auto',
        mainSize: '1fr',
        endSize: 'auto',
        // TODO: when an area is another Layout, do not wrap them in an extra div
        // TODO: option 1) higher value layouts could use start={Layout.create(start)} to ensure Areas are layout root
        renderStartArea: function (_a) {
            var start = _a.start, classes = _a.classes;
            return (start && (React.createElement("div", tslib_1.__assign({ className: classnames_1.default(exports.layoutSlotClassNames.start, classes.start) }, utils_1.rtlTextContainer.getAttributes({ forElements: [start] })), start)));
        },
        renderMainArea: function (_a) {
            var main = _a.main, classes = _a.classes;
            return (main && (React.createElement("div", tslib_1.__assign({ className: classnames_1.default(exports.layoutSlotClassNames.main, classes.main) }, utils_1.rtlTextContainer.getAttributes({ forElements: [main] })), main)));
        },
        renderEndArea: function (_a) {
            var end = _a.end, classes = _a.classes;
            return (end && (React.createElement("div", tslib_1.__assign({ className: classnames_1.default(exports.layoutSlotClassNames.end, classes.end) }, utils_1.rtlTextContainer.getAttributes({ forElements: [end] })), end)));
        },
        // Heads up!
        // IE11 Doesn't support grid-gap, insert virtual columns instead
        renderGap: function (_a) {
            var gap = _a.gap, classes = _a.classes;
            return gap && React.createElement("span", { className: classnames_1.default(exports.layoutSlotClassNames.gap, classes.gap) });
        },
    };
    return Layout;
}(utils_1.UIComponent));
/**
 * (DEPRECATED) A layout is a utility for arranging the content of a component.
 */
exports.default = types_1.withSafeTypeForAs(Layout);
