"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var accessibility_1 = require("@fluentui/accessibility");
var react_bindings_1 = require("@fluentui/react-bindings");
var react_component_event_listener_1 = require("@fluentui/react-component-event-listener");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var customPropTypes = require("@fluentui/react-proptypes");
var _ = require("lodash");
var classnames_1 = require("classnames");
var PropTypes = require("prop-types");
var React = require("react");
var utils_1 = require("../../utils");
var Menu_1 = require("./Menu");
var Box_1 = require("../Box/Box");
var types_1 = require("../../types");
var positioner_1 = require("../../utils/positioner");
exports.menuItemClassName = 'ui-menu__item';
exports.menuItemSlotClassNames = {
    submenu: exports.menuItemClassName + "__submenu",
    wrapper: exports.menuItemClassName + "__wrapper",
    indicator: exports.menuItemClassName + "__indicator",
};
var MenuItem = /** @class */ (function (_super) {
    tslib_1.__extends(MenuItem, _super);
    function MenuItem() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.menuRef = React.createRef();
        _this.itemRef = React.createRef();
        _this.handleWrapperBlur = function (e) {
            if (!_this.props.inSubmenu && !e.currentTarget.contains(e.relatedTarget)) {
                _this.trySetMenuOpen(false, e);
            }
        };
        _this.actionHandlers = {
            performClick: function (event) { return !event.defaultPrevented && _this.handleClick(event); },
            openMenu: function (event) { return _this.openMenu(event); },
            closeAllMenusAndFocusNextParentItem: function (event) { return _this.closeAllMenus(event); },
            closeMenu: function (event) { return _this.closeMenu(event); },
            closeMenuAndFocusTrigger: function (event) { return _this.closeMenu(event, true); },
            doNotNavigateNextParentItem: function (event) {
                event.stopPropagation();
            },
            closeAllMenus: function (event) { return _this.closeAllMenus(event); },
        };
        _this.outsideClickHandler = function (e) {
            if (!_this.isSubmenuOpen())
                return;
            if (!utils_1.doesNodeContainClick(_this.itemRef.current, e, _this.context.target) &&
                !utils_1.doesNodeContainClick(_this.menuRef.current, e, _this.context.target)) {
                _this.trySetMenuOpen(false, e);
            }
        };
        _this.performClick = function (e) {
            var _a = _this.props, active = _a.active, menu = _a.menu;
            if (menu) {
                if (utils_1.doesNodeContainClick(_this.menuRef.current, e, _this.context.target)) {
                    // submenu was clicked => close it and propagate
                    _this.trySetMenuOpen(false, e, function () { return react_bindings_1.focusAsync(_this.itemRef.current); });
                }
                else {
                    // the menuItem element was clicked => toggle the open/close and stop propagation
                    _this.trySetMenuOpen(active ? !_this.state.menuOpen : true, e);
                    e.stopPropagation();
                    e.preventDefault();
                }
            }
        };
        _this.handleClick = function (e) {
            var disabled = _this.props.disabled;
            if (disabled) {
                e.preventDefault();
                return;
            }
            _this.performClick(e);
            _.invoke(_this.props, 'onClick', e, _this.props);
        };
        _this.handleBlur = function (e) {
            _this.setState({ isFromKeyboard: false });
            _.invoke(_this.props, 'onBlur', e, _this.props);
        };
        _this.handleFocus = function (e) {
            _this.setState({ isFromKeyboard: utils_1.isFromKeyboard() });
            _.invoke(_this.props, 'onFocus', e, _this.props);
        };
        _this.isSubmenuOpen = function () {
            var menu = _this.props.menu;
            var menuOpen = _this.state.menuOpen;
            return !!(menu && menuOpen);
        };
        _this.closeAllMenus = function (e) {
            if (!_this.isSubmenuOpen()) {
                return;
            }
            var inSubmenu = _this.props.inSubmenu;
            _this.trySetMenuOpen(false, e, function () {
                if (!inSubmenu) {
                    react_bindings_1.focusAsync(_this.itemRef.current);
                }
            });
            // avoid spacebar scrolling the page
            if (!inSubmenu) {
                e.preventDefault();
            }
        };
        _this.closeMenu = function (e, forceTriggerFocus) {
            if (!_this.isSubmenuOpen()) {
                return;
            }
            var inSubmenu = _this.props.inSubmenu;
            var shouldStopPropagation = inSubmenu || _this.props.vertical;
            _this.trySetMenuOpen(false, e, function () {
                if (forceTriggerFocus || shouldStopPropagation) {
                    react_bindings_1.focusAsync(_this.itemRef.current);
                }
            });
            if (forceTriggerFocus || shouldStopPropagation) {
                e.stopPropagation();
            }
        };
        _this.openMenu = function (e) {
            var menu = _this.props.menu;
            var menuOpen = _this.state.menuOpen;
            if (menu && !menuOpen) {
                _this.trySetMenuOpen(true, e);
                _.invoke(_this.props, 'onActiveChanged', e, tslib_1.__assign(tslib_1.__assign({}, _this.props), { active: true }));
                e.stopPropagation();
                e.preventDefault();
            }
        };
        return _this;
    }
    MenuItem.prototype.renderComponent = function (_a) {
        var _this = this;
        var ElementType = _a.ElementType, classes = _a.classes, accessibility = _a.accessibility, unhandledProps = _a.unhandledProps, styles = _a.styles, rtl = _a.rtl;
        var _b = this.props, children = _b.children, content = _b.content, icon = _b.icon, wrapper = _b.wrapper, menu = _b.menu, primary = _b.primary, secondary = _b.secondary, active = _b.active, vertical = _b.vertical, indicator = _b.indicator, disabled = _b.disabled;
        var menuOpen = this.state.menuOpen;
        var menuItemInner = utils_1.childrenExist(children) ? (children) : (React.createElement(react_component_ref_1.Ref, { innerRef: this.itemRef },
            React.createElement(ElementType, tslib_1.__assign({ className: classes.root, disabled: disabled, onBlur: this.handleBlur, onFocus: this.handleFocus }, accessibility.attributes.root, accessibility.keyHandlers.root, unhandledProps, (!wrapper && { onClick: this.handleClick }), utils_1.applyAccessibilityKeyHandlers(accessibility.keyHandlers.root, unhandledProps)),
                Box_1.default.create(icon, {
                    defaultProps: function () { return ({
                        styles: styles.icon,
                        as: 'span',
                    }); },
                }),
                Box_1.default.create(content, {
                    defaultProps: function () { return ({ as: 'span', styles: styles.content }); },
                }),
                menu &&
                    Box_1.default.create(indicator, {
                        defaultProps: function () { return ({
                            as: 'span',
                            className: exports.menuItemSlotClassNames.indicator,
                            styles: styles.indicator,
                            accessibility: accessibility_1.indicatorBehavior,
                        }); },
                    }))));
        var maybeSubmenu = menu && active && menuOpen ? (React.createElement(React.Fragment, null,
            React.createElement(react_component_ref_1.Ref, { innerRef: this.menuRef },
                React.createElement(positioner_1.Popper, tslib_1.__assign({ align: vertical ? 'top' : rtl ? 'end' : 'start', position: vertical ? (rtl ? 'before' : 'after') : 'below', targetRef: this.itemRef }, positioner_1.getPopperPropsFromShorthand(menu)), Menu_1.default.create(menu, {
                    defaultProps: function () { return ({
                        accessibility: accessibility_1.submenuBehavior,
                        className: exports.menuItemSlotClassNames.submenu,
                        vertical: true,
                        primary: primary,
                        secondary: secondary,
                        styles: styles.menu,
                        submenu: true,
                        indicator: indicator,
                    }); },
                }))),
            React.createElement(react_component_event_listener_1.EventListener, { listener: this.outsideClickHandler, target: this.context.target, type: "click" }))) : null;
        if (wrapper) {
            return Box_1.default.create(wrapper, {
                defaultProps: function () { return (tslib_1.__assign(tslib_1.__assign({ className: classnames_1.default(exports.menuItemSlotClassNames.wrapper, classes.wrapper) }, accessibility.attributes.wrapper), utils_1.applyAccessibilityKeyHandlers(accessibility.keyHandlers.wrapper, wrapper))); },
                overrideProps: function () { return ({
                    children: (React.createElement(React.Fragment, null,
                        menuItemInner,
                        maybeSubmenu)),
                    onClick: _this.handleClick,
                    onBlur: _this.handleWrapperBlur,
                }); },
            });
        }
        return menuItemInner;
    };
    MenuItem.prototype.trySetMenuOpen = function (newValue, e, onStateChanged) {
        this.setState({ menuOpen: newValue });
        // The reason why post-effect is not passed as callback to trySetState method
        // is that in 'controlled' mode the post-effect is applied before final re-rendering
        // which cause a broken behavior: for e.g. when it is needed to focus submenu trigger on ESC.
        // TODO: all DOM post-effects should be applied at componentDidMount & componentDidUpdated stages.
        onStateChanged && onStateChanged();
        _.invoke(this.props, 'onMenuOpenChange', e, tslib_1.__assign(tslib_1.__assign({}, this.props), { menuOpen: newValue }));
    };
    MenuItem.displayName = 'MenuItem';
    MenuItem.deprecated_className = exports.menuItemClassName;
    MenuItem.propTypes = tslib_1.__assign(tslib_1.__assign({}, utils_1.commonPropTypes.createCommon()), { active: PropTypes.bool, disabled: PropTypes.bool, icon: customPropTypes.shorthandAllowingChildren, iconOnly: PropTypes.bool, index: PropTypes.number, itemPosition: PropTypes.number, itemsCount: PropTypes.number, onClick: PropTypes.func, onFocus: PropTypes.func, onBlur: PropTypes.func, pills: PropTypes.bool, pointing: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['start', 'end'])]), primary: customPropTypes.every([customPropTypes.disallow(['secondary']), PropTypes.bool]), secondary: customPropTypes.every([customPropTypes.disallow(['primary']), PropTypes.bool]), underlined: PropTypes.bool, vertical: PropTypes.bool, wrapper: PropTypes.oneOfType([PropTypes.node, PropTypes.object]), menu: PropTypes.oneOfType([customPropTypes.itemShorthand, customPropTypes.collectionShorthand]), menuOpen: PropTypes.bool, defaultMenuOpen: PropTypes.bool, onActiveChanged: PropTypes.func, inSubmenu: PropTypes.bool, indicator: customPropTypes.shorthandAllowingChildren, onMenuOpenChange: PropTypes.func });
    MenuItem.defaultProps = {
        as: 'a',
        accessibility: accessibility_1.menuItemBehavior,
        wrapper: { as: 'li' },
        indicator: {},
    };
    MenuItem.autoControlledProps = ['menuOpen'];
    return MenuItem;
}(utils_1.AutoControlledComponent));
MenuItem.create = utils_1.createShorthandFactory({ Component: MenuItem, mappedProp: 'content' });
/**
 * A MenuItem is an actionable item within a Menu.
 */
exports.default = types_1.withSafeTypeForAs(MenuItem);
