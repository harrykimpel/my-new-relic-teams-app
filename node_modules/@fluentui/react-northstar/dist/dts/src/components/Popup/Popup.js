"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var accessibility_1 = require("@fluentui/accessibility");
var react_bindings_1 = require("@fluentui/react-bindings");
var react_component_event_listener_1 = require("@fluentui/react-component-event-listener");
var react_component_nesting_registry_1 = require("@fluentui/react-component-nesting-registry");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var customPropTypes = require("@fluentui/react-proptypes");
var keyboardKey = require("keyboard-key");
var _ = require("lodash");
var PropTypes = require("prop-types");
var React = require("react");
// @ts-ignore
var react_fela_1 = require("react-fela");
var utils_1 = require("../../utils");
var positioner_1 = require("../../utils/positioner");
var PopupContent_1 = require("./PopupContent");
var factories_1 = require("../../utils/factories");
var createReferenceFromContextClick_1 = require("./createReferenceFromContextClick");
var isRightClick_1 = require("../../utils/isRightClick");
var PortalInner_1 = require("../Portal/PortalInner");
exports.popupClassName = 'ui-popup';
/**
 * A Popup displays a non-modal, often rich content, on top of its target element.
 */
var Popup = function (props) {
    var context = React.useContext(react_fela_1.ThemeContext);
    var _a = react_bindings_1.useTelemetry(Popup.displayName, context.telemetry), setStart = _a.setStart, setEnd = _a.setEnd;
    setStart();
    var accessibility = props.accessibility, align = props.align, autoFocus = props.autoFocus, inline = props.inline, children = props.children, contentRef = props.contentRef, flipBoundary = props.flipBoundary, on = props.on, mountNode = props.mountNode, mouseLeaveDelay = props.mouseLeaveDelay, offset = props.offset, overflowBoundary = props.overflowBoundary, pointing = props.pointing, position = props.position, positionFixed = props.positionFixed, renderContent = props.renderContent, tabbableTrigger = props.tabbableTrigger, target = props.target, trapFocus = props.trapFocus, trigger = props.trigger, unstable_pinned = props.unstable_pinned;
    var _b = react_bindings_1.useAutoControlled({
        initialValue: false,
        defaultValue: props.defaultOpen,
        value: props.open,
    }), open = _b[0], setOpen = _b[1];
    var _c = React.useState(false), isOpenedByRightClick = _c[0], setIsOpenedByRightClick = _c[1];
    var closeTimeoutId = React.useRef();
    var popupContentRef = React.useRef();
    var pointerTargetRef = React.useRef();
    var triggerRef = React.useRef();
    // focusable element which has triggered Popup, can be either triggerDomElement or the element inside it
    var triggerFocusableRef = React.useRef();
    var rightClickReferenceObject = React.useRef();
    var getA11yProps = react_bindings_1.useAccessibility(accessibility, {
        debugName: Popup.displayName,
        actionHandlers: {
            closeAndFocusTrigger: function (e) {
                e.preventDefault();
                close(e, function () { return _.invoke(triggerFocusableRef.current, 'focus'); });
            },
            close: function (e) {
                close(e);
            },
            toggle: function (e) {
                e.preventDefault();
                trySetOpen(!open, e);
            },
            open: function (e) {
                e.preventDefault();
                setPopupOpen(true, e);
            },
            preventScroll: function (e) {
                e.preventDefault();
            },
        },
        mapPropsToBehavior: function () { return ({
            disabled: false,
            isOpenedByRightClick: isOpenedByRightClick,
            on: on,
            trapFocus: trapFocus,
            tabbableTrigger: tabbableTrigger,
            trigger: trigger,
        }); },
        rtl: context.rtl,
    });
    var handleDocumentClick = function (getRefs) { return function (e) {
        if (isOpenedByRightClick && isOutsidePopupElement(getRefs(), e)) {
            trySetOpen(false, e);
            return;
        }
        if (isOutsidePopupElementAndOutsideTriggerElement(getRefs(), e)) {
            trySetOpen(false, e);
        }
    }; };
    var handleDocumentKeyDown = function (getRefs) { return function (e) {
        var keyCode = keyboardKey.getCode(e);
        var isMatchingKey = keyCode === keyboardKey.Enter || keyCode === keyboardKey.Spacebar;
        if (isMatchingKey && isOutsidePopupElementAndOutsideTriggerElement(getRefs(), e)) {
            trySetOpen(false, e);
        }
        // if focus was lost from Popup and moved to body, for e.g. when click on popup content
        // and ESC is pressed, the last opened Popup should get closed and the trigger should get focus
        var lastContentRef = getRefs().pop();
        var isLastOpenedPopup = lastContentRef && lastContentRef.current === popupContentRef.current;
        var activeDocument = context.target;
        var bodyHasFocus = activeDocument.activeElement === activeDocument.body;
        if (keyCode === keyboardKey.Escape && bodyHasFocus && isLastOpenedPopup) {
            close(e, function () { return _.invoke(triggerFocusableRef.current, 'focus'); });
        }
    }; };
    var isOutsidePopupElementAndOutsideTriggerElement = function (refs, e) {
        var isOutsidePopup = isOutsidePopupElement(refs, e);
        var isInsideTrigger = triggerRef.current && utils_1.doesNodeContainClick(triggerRef.current, e, context.target);
        return isOutsidePopup && !isInsideTrigger;
    };
    var isOutsidePopupElement = function (refs, e) {
        var isInsideNested = _.some(refs, function (childRef) {
            return utils_1.doesNodeContainClick(childRef.current, e, context.target);
        });
        var isOutsidePopup = popupContentRef.current && !isInsideNested;
        return isOutsidePopup;
    };
    var getTriggerProps = function (triggerElement) {
        var triggerProps = {};
        var normalizedOn = _.isArray(on) ? on : [on];
        /**
         * The focus is adding the focus, blur and click event (always opening on click)
         * If focus and context are provided, there is no need to add onClick
         */
        if (_.includes(normalizedOn, 'focus')) {
            triggerProps.onFocus = function (e) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                if (utils_1.isFromKeyboard()) {
                    trySetOpen(true, e);
                }
                _.invoke.apply(_, tslib_1.__spreadArrays([triggerElement, 'props.onFocus', e], args));
            };
            triggerProps.onBlur = function (e) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                if (shouldBlurClose(e)) {
                    trySetOpen(false, e);
                }
                _.invoke.apply(_, tslib_1.__spreadArrays([triggerElement, 'props.onBlur', e], args));
            };
            if (!_.includes(normalizedOn, 'context')) {
                triggerProps.onClick = function (e) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    setPopupOpen(true, e);
                    _.invoke.apply(_, tslib_1.__spreadArrays([triggerElement, 'props.onClick', e], args));
                };
            }
        }
        /**
         * The click is toggling the open state of the popup
         */
        if (_.includes(normalizedOn, 'click')) {
            triggerProps.onClick = function (e) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                trySetOpen(!open, e);
                _.invoke.apply(_, tslib_1.__spreadArrays([triggerElement, 'props.onClick', e], args));
            };
        }
        /**
         * The context is opening the popup
         */
        if (_.includes(normalizedOn, 'context')) {
            triggerProps.onContextMenu = function (e) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                setPopupOpen(!open, e);
                _.invoke.apply(_, tslib_1.__spreadArrays([triggerElement, 'props.onContextMenu', e], args));
                e.preventDefault();
            };
        }
        /**
         * The hover is adding the mouseEnter, mouseLeave, blur and click event (always opening on click)
         * If hover and context are provided, there is no need to add onClick
         */
        if (_.includes(normalizedOn, 'hover')) {
            triggerProps.onMouseEnter = function (e) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                setPopupOpen(true, e);
                utils_1.setWhatInputSource(context.target, 'mouse');
                _.invoke.apply(_, tslib_1.__spreadArrays([triggerElement, 'props.onMouseEnter', e], args));
            };
            triggerProps.onMouseLeave = function (e) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                setPopupOpen(false, e);
                _.invoke.apply(_, tslib_1.__spreadArrays([triggerElement, 'props.onMouseLeave', e], args));
            };
            if (!_.includes(normalizedOn, 'context')) {
                triggerProps.onClick = function (e) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    setPopupOpen(true, e);
                    _.invoke.apply(_, tslib_1.__spreadArrays([triggerElement, 'props.onClick', e], args));
                };
            }
            triggerProps.onBlur = function (e) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                if (shouldBlurClose(e)) {
                    trySetOpen(false, e);
                }
                _.invoke.apply(_, tslib_1.__spreadArrays([triggerElement, 'props.onBlur', e], args));
            };
        }
        return triggerProps;
    };
    var getContentProps = function (predefinedProps) {
        var contentHandlerProps = {};
        var normalizedOn = _.isArray(on) ? on : [on];
        /**
         * The focus is adding the focus and blur events on the content
         */
        if (_.includes(normalizedOn, 'focus')) {
            contentHandlerProps.onFocus = function (e, contentProps) {
                trySetOpen(true, e);
                predefinedProps && _.invoke(predefinedProps, 'onFocus', e, contentProps);
            };
            contentHandlerProps.onBlur = function (e, contentProps) {
                if (shouldBlurClose(e)) {
                    trySetOpen(false, e);
                }
                predefinedProps && _.invoke(predefinedProps, 'onBlur', e, contentProps);
            };
        }
        /**
         * The hover is adding the mouseEnter, mouseLeave and click event (always opening on click)
         */
        if (_.includes(normalizedOn, 'hover')) {
            contentHandlerProps.onMouseEnter = function (e, contentProps) {
                setPopupOpen(true, e);
                predefinedProps && _.invoke(predefinedProps, 'onMouseEnter', e, contentProps);
            };
            contentHandlerProps.onMouseLeave = function (e, contentProps) {
                setPopupOpen(false, e);
                predefinedProps && _.invoke(predefinedProps, 'onMouseLeave', e, contentProps);
            };
            contentHandlerProps.onClick = function (e, contentProps) {
                setPopupOpen(true, e);
                predefinedProps && _.invoke(predefinedProps, 'onClick', e, contentProps);
            };
        }
        return contentHandlerProps;
    };
    var shouldBlurClose = function (e) {
        return (!e.currentTarget ||
            !popupContentRef.current ||
            (!e.currentTarget.contains(e.relatedTarget) && !popupContentRef.current.contains(e.relatedTarget)));
    };
    var renderPopperChildren = function (_a) {
        var placement = _a.placement, scheduleUpdate = _a.scheduleUpdate;
        var content = renderContent ? renderContent(scheduleUpdate) : props.content;
        var popupContent = Popup.Content.create(content || {}, {
            defaultProps: function () {
                return getA11yProps('popup', tslib_1.__assign(tslib_1.__assign({}, getContentProps()), { placement: placement,
                    pointing: pointing, pointerRef: pointerTargetRef, trapFocus: trapFocus,
                    autoFocus: autoFocus }));
            },
            overrideProps: getContentProps,
        });
        return (React.createElement(react_component_nesting_registry_1.Unstable_NestingAuto, null, function (getRefs, nestingRef) { return (React.createElement(React.Fragment, null,
            React.createElement(react_component_ref_1.Ref, { innerRef: function (domElement) {
                    popupContentRef.current = domElement;
                    react_component_ref_1.handleRef(contentRef, domElement);
                    nestingRef.current = domElement;
                } }, popupContent),
            React.createElement(react_component_event_listener_1.EventListener, { listener: handleDocumentClick(getRefs), target: context.target, type: "click", capture: true }),
            React.createElement(react_component_event_listener_1.EventListener, { listener: handleDocumentClick(getRefs), target: context.target, type: "contextmenu", capture: true }),
            React.createElement(react_component_event_listener_1.EventListener, { listener: handleDocumentKeyDown(getRefs), target: context.target, type: "keydown", capture: true }),
            isOpenedByRightClick && (React.createElement(React.Fragment, null,
                React.createElement(react_component_event_listener_1.EventListener, { listener: dismissOnScroll, target: context.target, type: "wheel", capture: true }),
                React.createElement(react_component_event_listener_1.EventListener, { listener: dismissOnScroll, target: context.target, type: "touchmove", capture: true }))))); }));
    };
    var dismissOnScroll = function (e) {
        trySetOpen(false, e);
    };
    var trySetOpen = function (newValue, event) {
        var isOpenedByRightClick = newValue && isRightClick_1.default(event);
        // when new state 'open' === 'true', save the last focused element
        if (newValue) {
            updateTriggerFocusableRef();
            updateContextPosition(isOpenedByRightClick && event.nativeEvent);
        }
        setOpen(newValue);
        setIsOpenedByRightClick(isOpenedByRightClick);
        _.invoke(props, 'onOpenChange', event, tslib_1.__assign(tslib_1.__assign({}, props), { open: newValue }));
    };
    var setPopupOpen = function (newOpen, e) {
        clearTimeout(closeTimeoutId.current);
        newOpen ? trySetOpen(true, e) : schedulePopupClose(e);
    };
    var schedulePopupClose = function (e) {
        closeTimeoutId.current = setTimeout(function () {
            trySetOpen(false, e);
        }, mouseLeaveDelay);
    };
    var close = function (e, onClose) {
        if (open) {
            trySetOpen(false, e);
            onClose && onClose();
            e.stopPropagation();
        }
    };
    /**
     * Save DOM element which had focus before Popup opens.
     * Can be either trigger DOM element itself or the element inside it.
     */
    var updateTriggerFocusableRef = function () {
        var activeDocument = context.target;
        var activeElement = activeDocument.activeElement;
        triggerFocusableRef.current =
            triggerRef.current && triggerRef.current.contains(activeElement)
                ? activeElement
                : triggerRef.current;
    };
    var updateContextPosition = function (nativeEvent) {
        rightClickReferenceObject.current = nativeEvent ? createReferenceFromContextClick_1.default(nativeEvent) : null;
    };
    if (process.env.NODE_ENV !== 'production') {
        React.useEffect(function () {
            if (inline && trapFocus) {
                // eslint-disable-next-line no-console
                console.warn('Using "trapFocus" in inline popup leads to broken behavior for screen reader users.');
            }
            if (!inline && autoFocus) {
                // eslint-disable-next-line no-console
                console.warn('Beware, "autoFocus" prop will just grab focus at the moment of mount and will not trap it. As user is able to TAB out from popup, better use "inline" prop to keep correct tab order.');
            }
        }, [autoFocus, inline, trapFocus]);
    }
    React.useEffect(function () {
        if (open) {
            // when new state 'open' === 'true', save the last focused element
            updateTriggerFocusableRef();
        }
    });
    var triggerNode = utils_1.childrenExist(children) ? children : trigger;
    var triggerProps = getTriggerProps(triggerNode);
    var contentElement = open && (React.createElement(positioner_1.Popper, { pointerTargetRef: pointerTargetRef, align: align, flipBoundary: flipBoundary, position: position, positionFixed: positionFixed, offset: offset, overflowBoundary: overflowBoundary, rtl: context.rtl, unstable_pinned: unstable_pinned, targetRef: rightClickReferenceObject.current || target || triggerRef, children: renderPopperChildren }));
    var triggerElement = triggerNode && (React.createElement(react_component_ref_1.Ref, { innerRef: triggerRef }, React.cloneElement(triggerNode, getA11yProps('trigger', triggerProps))));
    var element = (React.createElement(React.Fragment, null,
        triggerElement,
        open && (inline ? contentElement : React.createElement(PortalInner_1.default, { mountNode: mountNode }, contentElement))));
    setEnd();
    return element;
};
Popup.displayName = 'Popup';
Popup.propTypes = tslib_1.__assign(tslib_1.__assign({}, utils_1.commonPropTypes.createCommon({
    as: false,
    content: false,
})), { align: PropTypes.oneOf(positioner_1.ALIGNMENTS), defaultOpen: PropTypes.bool, inline: PropTypes.bool, mountNode: customPropTypes.domNode, mouseLeaveDelay: PropTypes.number, offset: PropTypes.oneOfType([
        PropTypes.func,
        PropTypes.arrayOf(PropTypes.number),
    ]), flipBoundary: PropTypes.oneOfType([
        PropTypes.object,
        PropTypes.arrayOf(PropTypes.object),
        PropTypes.oneOf(['clippingParents', 'window', 'scrollParent']),
    ]), overflowBoundary: PropTypes.oneOfType([
        PropTypes.object,
        PropTypes.arrayOf(PropTypes.object),
        PropTypes.oneOf(['clippingParents', 'window', 'scrollParent']),
    ]), on: PropTypes.oneOfType([
        PropTypes.oneOf(['hover', 'click', 'focus', 'context']),
        PropTypes.arrayOf(PropTypes.oneOf(['click', 'focus', 'context'])),
        PropTypes.arrayOf(PropTypes.oneOf(['hover', 'focus', 'context'])),
    ]), open: PropTypes.bool, onOpenChange: PropTypes.func, pointing: PropTypes.bool, position: PropTypes.oneOf(positioner_1.POSITIONS), positionFixed: PropTypes.bool, renderContent: PropTypes.func, target: PropTypes.any, trigger: customPropTypes.every([customPropTypes.disallow(['children']), PropTypes.any]), tabbableTrigger: PropTypes.bool, unstable_pinned: PropTypes.bool, content: customPropTypes.shorthandAllowingChildren, contentRef: customPropTypes.ref, trapFocus: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]), autoFocus: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]) });
Popup.defaultProps = {
    accessibility: accessibility_1.popupBehavior,
    align: 'start',
    position: 'above',
    on: 'click',
    mouseLeaveDelay: 500,
    tabbableTrigger: true,
};
Popup.handledProps = Object.keys(Popup.propTypes);
Popup.Content = PopupContent_1.default;
Popup.create = factories_1.createShorthandFactory({ Component: Popup, mappedProp: 'content' });
exports.default = Popup;
